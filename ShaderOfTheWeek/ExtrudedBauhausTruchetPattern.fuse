--[[--/*

  ExtrudedBauhausTruchetPattern.fuse

  Based on https://www.shadertoy.com/view/dl2fzz a WebGL shader created by Shane.
  Converted to DCTL and embeddet into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT).
  Place this file in your Fusion's and/or DaVinci Resolve's 'Fuses/' folder to use it.

*/--]]--




-- /*
local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()



-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,
  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  })



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------

-- */
ShaderParameters =
[[

  float  iResolution[2];
  float  iTime;
  float  iMouse[4];
  int    iFrame;
  bool   RANDOM_MATERIALS;
  bool   SWIZZLE_PALETTE;
  bool   LINES;
  int    COLOR_VARIETY;
  float  METAL_AMOUNT;
  float  GOLD_AMOUNT;
  float  Roughness;
  float  matType;
  float  reflectance;
  float  ViewXY[2];
  float  ViewZ;
  float  LightXY[2];
  float  LightZ;
  float  Scale;
  float  Alpha;
  bool   Vignette;
  float  focD;
  float  coc;

  int    width,height;
  int    compOrder;

]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel compatibility code
-- // ------------------------------------------------------------------------

-- */
ShaderCompatibilityCode =
[[


#if defined(DEVICE_IS_METAL)
  #define in
  #define out thread
  #define inout thread
#else
  #define in
  #define out
  #define inout
#endif

#undef USE_NATIVE_METAL_IMPL
#undef USE_NATIVE_CUDA_IMPL
#undef USE_NATIVE_OPENCL_IMPL

  // 0 to use the generic implementations; 1 for Metal, OpenCL, Cuda specific code if existing

  #if 1
    #if defined(DEVICE_IS_METAL)
      #define USE_NATIVE_METAL_IMPL   1
    #elif defined(DEVICE_IS_CUDA)
      #define USE_NATIVE_CUDA_IMPL    1
    #elif defined(DEVICE_IS_OPENCL)
      #define USE_NATIVE_OPENCL_IMPL  1
    #endif
  #endif

  #if defined(USE_NATIVE_METAL_IMPL)

    #define swi2(A,a,b)     (A).a##b
    #define swi3(A,a,b,c)   (A).a##b##c
    #define swi4(A,a,b,c,d) (A).a##b##c##d

    #define swi2S(a,b,c,d)   a.b##c = d
    #define swi3S(a,b,c,d,e) a.b##c##d = e

  #else

    #define swi2(A,a,b)     to_float2((A).a,(A).b)
    #define swi3(A,a,b,c)   to_float3((A).a,(A).b,(A).c)
    #define swi4(A,a,b,c,d) to_float4((A).a,(A).b,(A).c,(A).d)

    #define swi2S(a,b,c,d)   {float2 tmp = d; (a).b = tmp.x; (a).c = tmp.y;}
    #define swi3S(a,b,c,d,e) {float3 tmp = e; (a).b = tmp.x; (a).c = tmp.y; (a).d = tmp.z;}
    #define swi4S(a,b,c,d,e,f) {float4 tmp = f; (a).b = tmp.x; (a).c = tmp.y; (a).d = tmp.z; (a).e = tmp.w;}

  #endif

// ----------------------------------------------------------------------------------------------------------
// mat2 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float2x2 mat2;

  #define to_mat2(A,B,C,D)   mat2((A),(B),(C),(D))

  #define mul_f2_mat2(A,B)   ((A)*(B))
  #define mul_mat2_f2(A,B)   ((A)*(B))

#else

  typedef struct { float2 r0; float2 r1; } mat2;

  __DEVICE__ inline mat2 to_mat2      ( float  a, float  b, float c, float d)  { mat2 t; t.r0.x = a; t.r0.y = b; t.r1.x = c; t.r1.y = d;         return t; }

  __DEVICE__ inline float2 mul_f2_mat2( float2 v, mat2 m )
  {
    float2 t; t.x = v.x*m.r0.x + v.y*m.r0.y; t.y = v.x*m.r1.x + v.y*m.r1.y; return t;
  }

  __DEVICE__ inline float2 mul_mat2_f2( mat2 m, float2 v )
  {
    float2 t; t.x = v.x*m.r0.x + v.y*m.r1.x; t.y = v.x*m.r0.y + v.y*m.r1.y; return t;
  }

#endif // end of mat2 implementation

// ----------------------------------------------------------------------------------------------------------
// mat3 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float3x3 mat3;

  __DEVICE__ inline mat3 to_mat3_f3( float3 a, float3 b, float3 c ) { return mat3(a,b,c); }
  __DEVICE__ inline float3 mul_mat3_f3( mat3 B, float3 A) { return (B*A); }

#else

  typedef struct { float3 r0; float3 r1; float3 r2; } mat3;

  __DEVICE__ inline mat3 to_mat3_f3( float3 A, float3 B, float3 C)
  {
    mat3 D;
    D.r0 = A;
    D.r1 = B;
    D.r2 = C;
    return D;
  }

__DEVICE__ inline float3 mul_mat3_f3( mat3 B, float3 A) {
    float3 C;

    C.x = A.x * B.r0.x + A.y * B.r1.x + A.z * B.r2.x;
    C.y = A.x * B.r0.y + A.y * B.r1.y + A.z * B.r2.y;
    C.z = A.x * B.r0.z + A.y * B.r1.z + A.z * B.r2.z;
    return C;
  }

#endif // end of mat3 implementation

#if defined(USE_NATIVE_METAL_IMPL)

 #define mod_f(a,b)  fmod((a),(b))

 #define sin_f3(i) sin(i)
 #define cos_f3(i) cos(i)
 #define abs_f2(a) _fabs(a)
 #define sign_f3(a) sign(a)
 #define pow_f3(a,b) pow(a,b)
 #define pow_f4(a,b) pow(a,b)

#else

  #if defined(USE_NATIVE_OPENCL_IMPL)

    #define reflect(I,N) (I-2.0f*dot(N,I)*N)

    #define fract(a) ((a)-_floor(a))  // oder Pointer bauen: gentype fract(gentype x, gentype *itpr)

 #define mod_f(a,b) _fmod(a,b)
 #define sin_f3(i) sin(i)
 #define cos_f3(i) cos(i)
 #define abs_f2(a) fabs(a)
 #define sign_f3(a) sign(a)
 #define pow_f3(a,b) pow(a,b)
 #define pow_f4(a,b) pow(a,b)

 #else // Generic

 #if defined(DEVICE_IS_OPENCL)
   __DEVICE__ float3 reflect(float3 I, float3 N) {return I - 2.0f * dot(N, I) * N;}
 #endif

    #define fract(a) ((a)-_floor(a))

 #define mod_f(a,b) ((a)-(b)*_floor((a)/(b)))
 #define sin_f3(i) to_float3( _sinf((i).x), _sinf((i).y), _sinf((i).z))
 #define cos_f3(i) to_float3( _cosf((i).x), _cosf((i).y), _cosf((i).z))
 #define abs_f2(a) to_float2(_fabs((a).x), _fabs((a).y))
 #define sign_f3(a) to_float3((a).x==0.0f?0.0f:(a).x>0.0f?1.0f:-1.0f, (a).y==0.0f?0.0f:(a).y>0.0f?1.0f:-1.0f,(a).z==0.0f?0.0f:(a).z>0.0f?1.0f:-1.0f)
 #define pow_f3(a,b) to_float3(_powf((a).x,(b).x),_powf((a).y,(b).y),_powf((a).z,(b).z))
 #define pow_f4(a,b) to_float4(_powf((a).x,(b).x),_powf((a).y,(b).y),_powf((a).z,(b).z),_powf((a).w,(b).w))

  #endif

#endif


]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel implementation
-- // ------------------------------------------------------------------------

-- */
ShaderKernelCode =
[[

// ----------------------------------------------------------------------------------
// - Buffer A                                                                       -
// ----------------------------------------------------------------------------------
// Connect Buffer A 'Previsualization: Buffer A' to iChannel0
// Connect Buffer A 'Texture: Rusty Metal' to iChannel1
// Connect Buffer A 'Texture: RGBA Noise Small' to iChannel2


#define texture(ch,uv) _tex2DVecN(ch, (uv).x, (uv).y, 15)

/*

    Extruded Bauhaus Truchet Pattern
    --------------------------------

    This is an extruded Bauhaus Truchet pattern with a very simplistic
    Cook-Torrance diffuse and specular lighting scheme applied to give
    the vague appearance of hard ceramic and metal tiles.

    When not path tracing, I tend to get a bit lazy with material lighting
    routines. Most of the time, I can make things look the way I want by
    tweaking the diffuse and specular powers. However, if you want a bit
    more material realism, it's probably a good idea to drop in some kind
    of BRDF (bidirectional reflectance distribution function) routine,
    which is what I've done here.

    I hacked a very basic BRDF routine together pretty quickly some time
    ago, and it works well enough for the purpose of this example, but I
    wouldn't use it for anything other than a basic introduction. By the
    way, if you're an expert on the process, and I've made a mistake that
    can't be ignored, feel free to let me know.

    The Bauhaus pattern itself is nothing special. You can find them in
    abundance online, but I haven't seen them in variable heightmap form,
    so I thought it'd be fun to do that. Technically speaking, the example
    is interesting in the sense that every cell is only rendered once,
    which is made possible using a cell wall intersection trick that I've
    covered previously.

    I've included a heap of define options below, for anyone interested in
    playing around with different design settings.



    Other examples:

    // A much nicer implementation.
    Disney Principled BRDF - markusm
    https://www.shadertoy.com/view/XdyyDd


*/


// Paint on some edging.
#define EDGES

// Put some rivet holes on random objects.
#define HOLES

// Ratio of metallic tiles to dielectric (non-conducting) ones.
// Values range from zero (no metallic tiles) to one (all metallic).
//#define METAL_AMOUNT 0.35f // Range: [0, 1].

// The color variety... I wasn't sure what to call this. Lower
// numbers mean fewer colors. Changing the variety of colors used
// changes the feel. I prefer fewer, but everyone's different.
//
// Greyscale 0, One color: 1, Two colors: 2, Four colors, 3
//#define COLOR_VARIETY 2

// An override to display random material values and colors.
//#define RANDOM_MATERIALS

// Swizzle the palette from orange to purple based colors.
//#define SWIZZLE_PALETTE

// Relative amount of metallic tiles that are gold. For initial
// design reasons, the default is undefined.
//#define GOLD_AMOUNT 0.35f // Range: [0, 1].

// Subtle textured lines.
//#define LINES


// Object ID: Either the back plane, extruded object or beacons.
//int objID;

// Standard 2D rotation formula.
__DEVICE__ mat2 rot2(in float a){ float c = _cosf(a), s = _sinf(a); return to_mat2(c, -s, s, c); }

// IQ's float2 to float hash.
//float hash21(float2 p){  return fract(_sinf(dot(p, to_float2(27.619f, 57.583f)))*43758.5453f); }

union Zahl
 {
   float2  _Float; //32bit float
   uint2   _Uint;  //32bit unsigend integer
 };


// Fabrice's fork of "Integer Hash - III" by IQ: https://shadertoy.com/view/4tXyWN
__DEVICE__ float hash21(float2 f){

    union Zahl z;
    z._Float = f;
    //uvec2 p = floatBitsToUint(f);
    uint2 p = z._Uint;

    //p = 1664525U*(p>>1U^swi2(p,y,x));
    //p = 1664525U*(make_uint2(p.x>>1U^p.y, p.y>>1U^p.x));

    p.x = 1664525U*(p.x>>1U^p.y);
    p.y = 1664525U*(p.y>>1U^p.x);

    return (float)(1103515245U*(p.x^(p.y>>3U)))/(float)(0xffffffffU);
}


// Hacked together from IQ, Nimitz and Fabrice's hash functions.
__DEVICE__ float3 hash23(in float2 f){

    union Zahl z;
    z._Float = f;
    //uvec2 p = floatBitsToUint(f);
    uint2 p = z._Uint;

    uint  n = 1103515245U*((p.x)^(p.y>>3U));
    // Converting a uint to a uvec3:
    // These numbers came from here:
    // Quality hashes collection WebGL2 - Nimitz.
    // https://www.shadertoy.com/view/Xt3cDn
    //uint3 u3 = make_uint3(1, 16807U, 48271U);
    uint3 u3 = {1, 16807U, 48271U};

    return to_float3(((u3.x*n) >> 1) & 0x7fffffffU,((u3.y*n) >> 1) & 0x7fffffffU,((u3.z*n) >> 1) & 0x7fffffffU)/(float)(0x7fffffff);

    // Dave Hoskins's reliable hash function.
    //vec3 p3 = fract(swi3(f,x,y,x)*to_float3(0.1031f, 0.1030f, 0.0973f));
    //p3 += dot(p3, swi3(p3,y,x,z) + 423.123f);
    //return fract((swi3(p3,x,x,y)+swi3(p3,y,z,z))*swi3(p3,z,y,x));
}


// Tri-Planar blending function: Based on an old Nvidia writeup:
// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html
__DEVICE__ float3 tex3D(__TEXTURE2D__ tex, in float3 p, in float3 n){

    // Ryan Geiss effectively multiplies the first line by 7.0f It took me a while to realize that
    // it's largely redundant, due to the division process that follows. I'd never noticed on
    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)
    n = _fmaxf(n*n - 0.2f, to_float3_s(0.001f)); // _fmaxf(_fabs(n), 0.001f), etc.
    n /= dot(n, to_float3_s(1));
    //n /= length(n);

    // Texure samples. One for each plane.
    float3 tx = swi3(texture(tex, swi2(p,y,z)),x,y,z);
    float3 ty = swi3(texture(tex, swi2(p,z,x)),x,y,z);
    float3 tz = swi3(texture(tex, swi2(p,x,y)),x,y,z);

    // Multiply each texture plane by its normal dominance factor.... or however you wish
    // to describe it. For instance, if the normal faces up or down, the "ty" texture sample,
    // represnting the XZ plane, will be used, which makes sense.

    // Textures are stored in sRGB (I think), so you have to convert them to linear space
    // (squaring is a rough approximation) prior to working with them... or something like that. :)
    // Once the final color value is gamma corrected, you should see correct looking colors.
    return mul_mat3_f3(to_mat3_f3(tx*tx, ty*ty, tz*tz),n); // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;

}



// Height map value, which is just the pixel's greyscale value.
//vec3 hm3(in float2 p){ return texture(iChannel2, p*563.837f, -100.0f).xyz; }
__DEVICE__ float3 hm3(in float2 p){ return hash23(p); }

// IQ's extrusion formula.
__DEVICE__ float opExtrusion(in float sdf, in float pz, in float h, in float sf){

    // Slight rounding. A little nicer, but slower.
    float2 w = to_float2( sdf, _fabs(pz) - h) + sf;
    return _fminf(_fmaxf(w.x, w.y), 0.0f) + length(_fmaxf(w, to_float2_s(0.0f))) - sf;
}


// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)
//float scale = 1.0f/1.5f;

// Global cell boundary distance variables.
//float3 gDir; // Cell traversing direction.
//float3 gRd; // Ray direction.
//float gCD; // Cell boundary distance.

//float2 gIP;

// An extended square grid 2D Truchet routine: Split into square tiles
// as per usual, then produce the distance fields and ID for simple
// shapes inside them. The kinds of shapes you render is up to you.
//
// This is 2D function called once per raymarching iteration, so it
// needs to be reasonably quick, but not blindingly fast. I also wanted
// it to be a little bit readable, so I didn't go out of my way to
// tweak it. If speed was the goal, then I'd be more inclined to render
// it to a backbuffer, rather than turn it into an unreadable mess, but
// to each their own.
__DEVICE__ void tr(inout float2 *oP, inout float3 *d, inout float2 id[3], int oID, float scale, bool RANDOM_MATERIALS, float iTime, inout float2 *gIP){

    float2 p = *oP;

    // Row and column offset variable.
    float2 offs = to_float2_s(0);
    // Row and column ID.
    float2 ii = _floor(p/scale);
    /*
    // Offset columns.
    if(mod_f(ii.x, 2.0f)<0.5f){
        p.y -= scale/2.0f;
        offs.y += 0.5f;
    }
    */
    /*
    // Offset rows.
    if(mod_f(ii.y, 2.0f)<0.5f){
        p.x -= scale/2.0f;
        offs.x += 0.5f;
    } */


    if (!RANDOM_MATERIALS)
    {
      // Animated offset columns.
      // Time, beginning at random intervals.
      float t = iTime/8.0f + hash21(to_float2(2, ii.x));
      float iT = _floor(t); // Integer time increments to keep track of position.
      float fT = t - iT; // Fractional time increment used for animation.

      // Smoothly slide the columns at random time intervals.
      float dir = mod_f(ii.x, 2.0f)<0.5f ? -1.0f : 1.0f;
      p.y += dir*(smoothstep(0.0f, 0.0625f, fT) + 0.25f)*scale;
      offs.y = dir*(iT + 0.25f);
    }

    // Positional cell ID and local coordinates. If you didn't want to shift
    // rows and columns, you wouldn't need any of the code above, nor would you
    // need the three lines below.
    float2 ip = _floor(p/scale);
    p -= (ip + 0.5f)*scale;

    ip += offs; // Update the positional cell ID with the sliding offset.
    *gIP = ip; // Record the ID for usage elsewhere.
    *oP = p; // Record the local position.

    // Random local coordinate rotation.
    float rnd = hash21(ip + 0.05f);
    p = mul_f2_mat2(p , rot2(_floor(rnd*64.0f)*3.14159f/2.0f));

     // A second random number that determines what kind of tile to draw.
    float rnd2 = hash21(ip + 0.1f);


    // Three distances and IDs, to represent up to three shapes per cell.
    *d = to_float3_s(1e5);
    //id = vec2[3](to_float2_s(0), to_float2_s(0), to_float2_s(0));
    id[0] = to_float2_s(0.0f);
    id[1] = to_float2_s(0.0f);
    id[2] = to_float2_s(0.0f);

    // Based on the random choice above, render one of three types of
    // tiles. I hacked this together to get the job done, so there'd no
    // doubt be more efficient ways to do this, but this seems fast
    // enough on my machine, and it's readable enough, so it'll do.
    if(rnd2<0.3f){
        // Triangles.

        // Square boundary.
        float2 q = abs_f2(p);
        float sq = _fmaxf(q.x, q.y) - 0.5f*scale;

        // The diagonal center line.
        q = p;
        (*d).x = (p.x + p.y)*0.7071f;
        id[0] = ip - 0.25f; // ID for this side of the line.

        // The other side of the diagonal line.
        (*d).y = _fmaxf(sq, -(*d).x);
        id[1] = ip + 0.25f; // ID for the other side.

        // Use the square boundary to render the other two lines.
        // This will leave you with two triangles... Probably not
        // real distance field values, but no one will notice.
        *d = _fmaxf(*d, to_float3_s(sq));

        oID = 0; // Record the overall square cell ID.
    }
    else if(rnd2<0.5f){

        // Square with central circle tile.

        // Circle.
        float2 q = p;
        (*d).x = length(q) - 1.0f/2.0f*0.7071f*scale + 0.05f;
        id[0] = ip; // Center ID for the circle.

        // The remainder of the rectangle.
        q = abs_f2(p);
        (*d).y = _fmaxf(q.x - 0.5f*scale, q.y - 0.5f*scale);
        (*d).y = _fmaxf((*d).y, -(*d).x);
        id[1] = ip + to_float2(-0.25f, 0); // Off to the side for the remainder.

        oID = 1; // Square cell ID.
    }
    else {

        // Three circular arcs.

        // Square boundary.
        float2 q = abs_f2(p);
        float sq = _fmaxf(q.x, q.y) - 0.5f*scale;

        float qrtr = length(p - 0.5f*scale) - 0.5f*scale; // Quarter.
        float semi = length(p - 0.5f*scale) - 1.0f*scale; // Semi circle.

        (*d).x = qrtr; // Inner quarter.
        id[0] = ip - 0.25f;

        (*d).y = _fmaxf(semi, -qrtr); // Middle arc.
        id[1] = ip + to_float2_s(0);

        (*d).z = _fmaxf(sq, -semi); // Outer quarter.
        id[2] = ip + 0.25f;

        // Using the square boundary to form the three bounded arcs.
        *d = _fmaxf(*d, to_float3_s(sq));

        oID = 2; // Square cell ID.
    }

    // Shape border line width.
    float lw = 0.015f*scale;
    *d += lw;

    // Rivet offset distance.
    float rvO = (1.0f/2.0f - 1.0f/4.0f*0.7071f)*scale;

    // Rivet nole distance.
    float rv = 0.0f;

    // Rivet holes.
    if(oID == 1){
        // Square corner holes.
        float2 q = abs_f2(p) - rvO;
        rv = length(q);
    }
    else {

        // Triangle holes and corner arc holes.
        float2 q = p;
        rv = length(q - rvO);
        rv = _fminf(rv, length(q + rvO));

        if(oID == 2){
           // Central arc rivet position.
           float2 arcR = to_float2(rvO, -(1.0f*scale - lw)/4.0f);
           rv = _fminf(rv, _fminf(length(p - arcR), length(swi2(p,y,x) - arcR)));
        }
    }

    // Smaller rivet holes when using edging.
    #ifdef EDGES
    float hw = 0.035f;
    #else
    float hw = 0.045f;
    #endif

    // Use CSG for some random rivet holes.
    #ifdef HOLES
    if(hash21(ip + 0.08f)<0.35f){
       *d = _fmaxf(*d, to_float3_s(-(rv - hw*scale)));
    }
    #endif
}


// The scene's distance function: There'd be faster ways to do this, but it's
// more readable this way. Plus, this  is a pretty simple scene, so it's
// efficient enough.
__DEVICE__ float m(float3 p, float scale, bool RANDOM_MATERIALS, float iTime, inout float2 *gIP, float3 gDir, float3 gRd, inout float *gCD, inout int *objID ){

    // Back plane.
    float fl = -p.z;

    // 2D Truchet distance, for the extrusion cross section.
    float3 d; float2 id[3]; int oID = 0;
    float2 gP = swi2(p,x,y);
    tr(&gP, &d, id, oID, scale, RANDOM_MATERIALS, iTime, gIP);

    // Extrude the 2D Truchet object along the Z-plane.
    //vec3 h3 = to_float3_aw(hm(id[0]), hm(id[1]), hm(id[2]))*0.25f + 0.05f;
    // A bit of face beveling to reflect the light a little more.
    float3 bev = _fminf(-d*6.0f, to_float3_s(0.2f))*0.03f; // 03;
    float3 h3 = hm3(*gIP)*0.25f + 0.05f;
    float obj = opExtrusion(d.x, p.z, h3.x, 0.015f) - bev.x;
    obj = _fminf(obj, opExtrusion(d.y, p.z, h3.y, 0.015f) - bev.y);
    if(oID==0) obj = _fminf(obj, opExtrusion(d.z, p.z, h3.z, 0.015f) - bev.z);

    // Directional ray collision with the square cell boundaries.
    float2 rC = (swi2(gDir,x,y)*scale - gP)/swi2(gRd,x,y); // For 2D, this will work too.

    // Minimum of all distances, plus not allowing negative distances, which
    // stops the ray from tracing backwards... I'm not entirely sure it's
    // necessary here, but it stops artifacts from appearing with other
    // non-rectangular grids.
    //gCD = _fmaxf(min(_fminf(rC.x, rC.y), rC.z), 0.0f) + 0.0015f;
    *gCD = _fmaxf(_fminf(rC.x, rC.y), 0.0f) + 0.0015f; // Adding a touch to advance to the next cell.

    // Object ID.
    *objID = fl<obj? 0 : 1;

    // Minimum distance for the scene.
    return _fminf(fl, obj);
}

// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited
// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)
__DEVICE__ float softShadow(float3 ro, float3 lp, float3 n, float k, float scale, bool RANDOM_MATERIALS, float iTime, inout float2 *gIP, inout float3 *gDir, inout float3 *gRd, inout float *gCD, inout int *objID){

    // More would be nicer. More is always nicer, but not affordable for slower machines.
    const int iter = 32;

    ro += n*0.0015f; // Bumping the shadow off the hit point.

    float3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.0f;
    float t = 0.0f;
    float end = _fmaxf(length(rd), 0.0001f);
    rd /= end;

    //rd = normalize(rd + (hash33R(ro + n) - 0.5f)*0.03f);
    // Set the global ray direction varibles -- Used to calculate
    // the cell boundary distance inside the "map" function.
    *gDir = sign_f3(rd)*0.5f;
    *gRd = rd;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest
    // number to give a decent shadow is the best one to choose.
    for (int i = 0; i<iter; i++){
        float d = m(ro + rd*t, scale, RANDOM_MATERIALS, iTime, gIP, *gDir, *gRd, gCD, objID);
        shade = _fminf(shade, k*d/t);
        //shade = _fminf(shade, smoothstep(0.0f, 1.0f, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += _fminf(h, 0.2f), dist += clamp(h, 0.01f, stepDist), etc.
        t += clamp(_fminf(d*0.7f, *gCD), 0.01f, 0.25f);

        // Early exits from accumulative distance function calls tend to be a good thing.
        if (d<0.0f || t>end) break;
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add
    // AO also just for kicks. :)
    return _fmaxf(shade, 0.0f);
}


// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)
// Anyway, I like this one. I'm assuming it's based on IQ's original.
__DEVICE__ float calcAO(in float3 p, in float3 n, float scale, bool RANDOM_MATERIALS, float iTime, inout float2 *gIP, float3 gDir, float3 gRd, inout float *gCD, inout int *objID){

    float sca = 2.0f, occ = 0.0f;
    for( int i = 0; i<5; i++ ){

        float hr = (float)(i + 1)*0.15f/5.0f;
        float d = m(p + n*hr, scale, RANDOM_MATERIALS, iTime, gIP, gDir, gRd, gCD, objID);
        occ += (hr - d)*sca;
        sca *= 0.7f;

        // Deliberately redundant line that may or may not stop the
        // compiler from unrolling.
        if(sca>1e5) break;
    }

    return clamp(1.0f - occ, 0.0f, 1.0f);
}

// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.
__DEVICE__ float3 nr(in float3 p, float scale, bool RANDOM_MATERIALS, float iTime, inout float2 *gIP, float3 gDir, float3 gRd, inout float *gCD, inout int *objID) {

    const float2 e = to_float2(0.001f, 0);

    //return normalize(to_float3(m(p + swi3(e,x,y,y)) - m(p - swi3(e,x,y,y)), m(p + swi3(e,y,x,y)) - m(p - swi3(e,y,x,y)),
    //                           m(p + swi3(e,y,y,x)) - m(p - swi3(e,y,y,x))));

    // This mess is an attempt to speed up compiler time by contriving a break... It's
    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.
    float sgn = 1.0f;
    float mp[6];
    float3 e6[3] = {swi3(e,x,y,y), swi3(e,y,x,y), swi3(e,y,y,x)};
    for(int i = 0; i<6; i++){
        mp[i] = m(p + sgn*e6[i/2], scale, RANDOM_MATERIALS, iTime, gIP, gDir, gRd, gCD, objID);
        sgn = -sgn;
        if(sgn>2.0f) break; // Fake conditional break;
    }

    return normalize(to_float3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));
}


///////////////////////////
#define PI 3.14159265f

// Microfaceted normal distribution function.
__DEVICE__ float D_GGX(float NoH, float roughness) {
    float alpha = _powf(roughness, 4.0f);
    float b = (NoH*NoH*(alpha - 1.0f) + 1.0f);
    return alpha/(PI*b*b);
}

// Surface geometry function.
__DEVICE__ float G1_GGX_Schlick(float NoV, float roughness) {
    //float r = roughness; // original
    float r = 0.5f + 0.5f*roughness; // Disney remapping.
    float k = (r*r)/2.0f;
    float denom = NoV*(1.0f - k) + k;
    return _fmaxf(NoV, 0.001f)/denom;
}

__DEVICE__ float G_Smith(float NoV, float NoL, float roughness) {
    float g1_l = G1_GGX_Schlick(NoL, roughness);
    float g1_v = G1_GGX_Schlick(NoV, roughness);
    return g1_l*g1_v;
}

// Bidirectional Reflectance Distribution Function (BRDF).
//
// If you want a quick crash course in BRDF, see the following:
// Microfacet BRDF: Theory and Implementation of Basic PBR Materials
// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s
//
__DEVICE__ float3 BRDF(float3 col, float3 n, float3 l, float3 v,
                       float type, float rough, float fresRef){

  float3 h = normalize(v + l); // Half vector.

  // Standard BRDF dot product calculations.
  float nv = clamp(dot(n, v), 0.0f, 1.0f);
  float nl = clamp(dot(n, l), 0.0f, 1.0f);
  float nh = clamp(dot(n, h), 0.0f, 1.0f);
  float vh = clamp(dot(v, h), 0.0f, 1.0f);


  // Specular microfacet (Cook- Torrance) BRDF.
  //
  // F0 for dielectics in range [0., .16]
  // Default FO is (0.16f * .5^2) = .04
  // Common Fresnel values, F(0), or F0 here.
  // Water: 0.02f, Plastic: 0.05f, Glass: 0.08f, Diamond: .17
  // Copper: to_float3(0.95f, 0.64f, 0.54f), Aluminium: to_float3(0.91f, 0.92f, 0.92f), Gold: to_float3(1, 0.71f, 0.29f),
  // Silver: to_float3(0.95f, 0.93f, 0.88f), Iron: to_float3(0.56f, 0.57f, 0.58f).
  float3 f0 = to_float3_s(0.16f*(fresRef*fresRef));
  // For metals, the base color is used for F0.
  f0 = _mix(f0, col, type);
  float3 F = f0 + (1.0f - f0)*_powf(1.0f - vh, 5.0f);  // Fresnel-Schlick reflected light term.
  // Microfacet distribution... Most dominant term.
  float D = D_GGX(nh, rough);
  // Geometry self shadowing term.
  float G = G_Smith(nv, nl, rough);
  // Combining the terms above.
  float3 spec = F*D*G/(4.0f*_fmaxf(nv, 0.001f));

  // Diffuse calculations.
  float3 diff = to_float3_s(nl);
  diff *= 1.0f - F; // If not specular, use as diffuse (optional).
  diff *= (1.0f - type); // No diffuse for metals.

  // Combining diffuse and specular.
  // You could specify a specular color, multiply it by the base
  // color, or multiply by a constant. It's up to you.
  return (col*diff + spec*PI);

}
////////////////////

union A2F
 {
   float3  F;    //32bit float
   float  A[3];  //32bit unsigend integer
 };


__KERNEL__ void ExtrudedBauhausTruchetPatternFuse__Buffer_A(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0,  __TEXTURE2D__ iChannel1,  __TEXTURE2D__ iChannel2, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  int    iFrame      = params->iFrame;
  float4 c   = to_float4_s(0.0f);
  float2 u   = to_float2(fusion_x,fusion_y);


  bool   RANDOM_MATERIALS = params->RANDOM_MATERIALS;
  bool   SWIZZLE_PALETTE = params->SWIZZLE_PALETTE;
  bool   LINES = params->LINES;
  int    COLOR_VARIETY = params->COLOR_VARIETY;
  float  METAL_AMOUNT = params->METAL_AMOUNT;
  float  GOLD_AMOUNT = params->GOLD_AMOUNT;
  float  Roughness = params->Roughness;
  float  matType = params->matType;
  float  reflectance = params->reflectance;
  float2 ViewXY = to_float2(params->ViewXY[0], params->ViewXY[1]);
  float  ViewZ = params->ViewZ;
  float2 LightXY = to_float2(params->LightXY[0], params->LightXY[1]);
  float  LightZ = params->LightZ;
  float  Scale = params->Scale;
  float  Alpha = params->Alpha;
  bool   Vignette = params->Vignette;
  float  focD = params->focD;
  float  coc = params->coc;

  // --------

    u+=0.5f;


    // Aspect correct coordinates. Only one line necessary.
    u = (u - iResolution*0.5f)/iResolution.y;

    // Unit direction vector, camera origin and light position.
    float3 r = normalize(to_float3_aw(u, 1)+to_float3_aw(ViewXY,ViewZ)), o = to_float3(0, iTime/2.0f, -3), l = o + to_float3(0.5f, 1, 1.5f) + to_float3_aw(LightXY,LightZ);
    //to_float3(-2.5f, 2.5f, -1.25f);
    // Rotating the camera about the XY plane.
    swi2S(r,y,z, mul_mat2_f2(rot2(0.15f),swi2(r,y,z)));
    swi2S(r,x,z, mul_mat2_f2(rot2(-_cosf(iTime*3.14159f/32.0f)/8.0f),swi2(r,x,z)));
    swi2S(r,x,y, mul_mat2_f2(rot2(_sinf(iTime*3.14159f/32.0f)/8.0f),swi2(r,x,y)));

    // Mouse camera movement.
    if(iMouse.z>1.0f){
        swi2S(r,y,z, mul_f2_mat2(swi2(r,y,z) , rot2(-0.5f*(iMouse.y - iResolution.y*0.5f)/iResolution.y*3.1459f)));
        swi2S(r,x,z, mul_f2_mat2(swi2(r,x,z) , rot2(-0.25f*(iMouse.x - iResolution.x*0.5f)/iResolution.x*3.1459f)));
    }

    // Standard raymarching setup.
    float d, t = hash21(swi2(r,x,y)*57.0f + fract(iTime))*0.5f;

    // Set the global ray direction varibles -- Used to calculate
    // the cell boundary distance inside the "map" function.
    float3 gDir = sign_f3(r)*0.5f;
    float3 gRd = r;
    float gCD = 0.0f;
    int objID = 0;

    float scale = 1.0f/1.5f * Scale;

    float2 gIP = to_float2_s(0.0f);

    // Raymarch.
    for(int i = 0; i<96; i++){
        float3 p = o + r*t;
        d = m(p, scale, RANDOM_MATERIALS, iTime, &gIP, gDir, gRd, &gCD, &objID); // Surface distance.
        // Surface hit -- No far plane break, since it's just the floor.
        if(_fabs(d)<0.001f) break;
        t += _fminf(d*0.9f, gCD);  // Advance the overall distance closer to the surface.
    }

    // Object ID: Back plane (0), or the metaballs (1).
    int gObjID = objID;

    // Hit point and normal.
    float3 p = o + r*t, n = nr(p, scale, RANDOM_MATERIALS, iTime, &gIP, gDir, gRd, &gCD, &objID);


    // Basic point lighting.
    float3 ld = l - p;
    float lDist = length(ld);
    ld /= lDist; // Light direction vector.
    float at = 1.0f/(1.0f + lDist*lDist*0.05f); // Attenuation.

    // Very, very cheap shadows -- Not used here.
    //float sh = _fminf(min(m(p + ld*0.08f), m(p + ld*0.16f)), _fminf(m(p + ld*0.24f), m(p + ld*0.32f)))/0.08f*1.5f;
    //sh = clamp(sh, 0.0f, 1.0f);
    float sh = softShadow(p, l, n, 8.0f, scale, RANDOM_MATERIALS, iTime, &gIP, &gDir, &gRd, &gCD, &objID); // Shadows.
    float ao = calcAO(p, n, scale, RANDOM_MATERIALS, iTime, &gIP, gDir, gRd, &gCD, &objID); // Ambient occlusion.

    /*
    // Old diffuse and specular calculations.
    float df = _fmaxf(dot(n, ld), 0.0f); // Diffuse.
    float sp = _powf(_fmaxf(dot(reflect(r, n), ld), 0.0f), 32.0f); // Specular.
    float fr = _powf(_fmaxf(1.0f + dot(r, n), 0.0f), 2.0f); // Fresnel.

    // UV texture coordinate holder.
    float2 uv = swi2(p,x,y);
    */

    // 2D Truchet face distace -- Used to render borders, etc.
    //scale *= 3.0f;
    float3 _d3;
    float2 vID[3]; int oID = 0;
    float2 p2 = swi2(p,x,y);
    tr(&p2, &_d3, vID, oID, scale, RANDOM_MATERIALS, iTime, &gIP);

    union A2F d3;
    d3.F = _d3;
    // Minimum tile object index.
    int index = (d3.F.x<d3.F.y && d3.F.x<d3.F.z)? 0 : d3.F.y<d3.F.z? 1 : 2;
    // 2D object face distance and ID.
    float obj2D = d3.A[index];
    float2 id = vID[index]*scale;

    // Object heights.
    union A2F h3;
    h3.F = hm3(gIP)*0.25f + 0.05f;

    float h = h3.A[index];

    // Texture position.
    float3 txP = to_float3_aw(p2, p.z);
    float3 txN = n;
    float3 tx = tex3D(iChannel1, txP/2.0f, txN);//to_float3_s(0.25f);//

    // Subtle lines for a bit of texture.
    float lSc, pat;
    if(LINES)
    {
      lSc = 24.0f;
      pat = (_fabs(fract((p2.x - p2.y)*lSc - 0.5f) - 0.5f) - 0.125f)/lSc;
    }

    // Standard material properties: Roughness, matType and reflectance.
    //
      float roughness   = 0.2f; // Lower roughness reflects more light, as expected.
//    float matType     = 0.0f; // Dielectric (non conducting): 0, or metallic: 1.
//    float reflectance = 0.5f; // Reflective strength.

    // Object color.
    float3 oCol = to_float3_s(0);

    // Use whatever logic to color the individual scene components. I made it
    // all up as I went along, but things like edges, textured line patterns,
    // etc, seem to look OK.
    //
    if(gObjID == 0){

       // Floor -- Redundant here, but I've included it anyway.
       oCol = to_float3_s(0.125f);
       matType = 1.0f; // Metallic material.
       roughness = 0.5f + Roughness;
    }
    else if(gObjID==1){

        // Extruded Truchet:

        // Noise texture, used for a hacky scratched surface look.
        // Usually, you'd tailor this to specific material needs.
        float3 txR = txP;
        swi2S(txR,x,y, mul_f2_mat2(swi2(txR,x,y) , rot2(-3.14159f/6.0f)));
        float3 rTx = tex3D(iChannel2, txR*to_float3(0.5f, 3, 0.5f), txN);
        float rGr = dot(rTx, to_float3(0.299f, 0.587f, 0.114f));

        // The tile base color.
        float sRnd = hash21(id + 0.01f); // Random tile component value.

        //sRnd = id.x;
        float3 sCol = 0.5f + 0.45f*cos_f3(6.2831f*sRnd/8.0f + (to_float3(0, 1, 2) + 0.05f));//to_float3(1, 0.15f, 0.45f);
        sCol = pow_f3(sCol, to_float3_s(1.5f));

        if(COLOR_VARIETY >= 2)
          if(hash21(id + 0.27f)<0.35f) sCol = swi3(sCol,z,y,x); //yzx


        if(COLOR_VARIETY >= 3)
        {
            if(SWIZZLE_PALETTE)
              if(hash21(id + 0.15f)<0.35f) sCol = _mix(sCol, swi3(sCol,y,x,z), 0.5f);
            else
              if(hash21(id + 0.15f)<0.35f) sCol = _mix(sCol, swi3(sCol,x,z,y), 0.5f);
        }

        // Face rim and face distance values for edge rendering.
        float b = _fabs(obj2D) - 0.01f;
        float pH = p.z + h - 0.04f;
        b = _fmaxf(b, (p.z + h - 0.02f));

        float sf = 0.01f; // Smoothing factor.
        float ew = 0.02f; // Edge width.

        if(RANDOM_MATERIALS)
        {
          float rRnd = hash21(gIP + 0.11f);
          sCol = 0.5f + 0.45f*cos_f3(6.2831f*rRnd + to_float3(0, 1, 2)*hash21(gIP + 0.4f)*1.5f);
        }

        #ifdef EDGES
            float rW = 0.035f; // Rim width.

            oCol = sCol;
            oCol = _mix(oCol*0.8f, oCol*0.15f, (1.0f - smoothstep(0.0f, sf, pH)));
            oCol = _mix(oCol, _mix(_fminf(sCol*1.4f, to_float3_s(1.0f)), to_float3_s(1), 0.2f), (1.0f - smoothstep(0.0f, sf, pH + ew)));
            oCol = _mix(oCol, oCol*0.15f, (1.0f - smoothstep(0.0f, sf, obj2D + rW)));

            if(LINES)
              // If applicable, apply lines to the inner face color.
              sCol = _mix(sCol*1.15f, sCol*0.7f, (1.0f - smoothstep(0.0f, sf, pat)));

            oCol = _mix(oCol, sCol, (1.0f - smoothstep(0.0f, sf, obj2D + rW + ew)));
        #else
            swi3S(oCol,x,y,z, sCol);
            if(LINES)
            {
              // If applicable, apply lines to the inner face color.
              pat = _fmaxf(pat, pH + 0.02f);
              oCol = _mix(oCol, oCol*0.15f, (1.0f - smoothstep(0.0f, sf, _fabs(pH + 0.02f) - ew/2.0f)));
              oCol = _mix(oCol*1.1f, swi3(oCol,x,y,z)*0.7f, (1.0f - smoothstep(0.0f, sf, pat)));
            }
        #endif

        // Greyscale value, calculated prior to gradient coloring.
        float gr = dot(swi3(oCol,x,y,z), to_float3(0.299f, 0.587f, 0.114f));

        // Subtle face color gradient.
        oCol = _mix(oCol, swi3(oCol,x,z,y), clamp(-p2.y - 0.125f, 0.0f, 1.0f));
        //swi3(oCol,x,y,z) = _mix(swi3(oCol,x,y,z), swi3(oCol,x,z,y), clamp(obj2D/scale*3.0f + 0.5f, 0.0f, 1.0f));

        if(COLOR_VARIETY == 0)
          swi3S(oCol,x,y,z, to_float3_s(gr*_sqrtf(gr)*1.5f));

        if(SWIZZLE_PALETTE)
          oCol = swi3(oCol,y,z,x);

        if(!RANDOM_MATERIALS)
        {
          if(hash21(id + 0.2f)<METAL_AMOUNT){
          //if(hash21(gIP + 0.2f)<0.25f){ // gPI: Square cell ID.
          //if(mod_f(_floor(gIP.x) + _floor(gIP.y), 2.0f)>0.5f){

              // Metal material.

              // Mostly grey with tiny leftover color residue.
              oCol = _mix(oCol, to_float3_s(gr), 0.9f);

              // Gold. Interesting, but a bit much for this example,
              // so the default is set to zero.
              if(GOLD_AMOUNT)
                if(hash21(id + 0.43f)<GOLD_AMOUNT) swi3S(oCol,x,y,z, swi3(oCol,x,y,z) * to_float3(1, 0.75f, 0.4f)*2.5f);


              matType = 1.0f; // Metallic material.
              swi3S(oCol,x,y,z, swi3(oCol,x,y,z) * (tx*1.0f + 0.5f));
              roughness = 0.6f  + Roughness;
              //roughness *= gr*2.0f;
              roughness *= rGr*0.6f + 0.4f;

              // Metallic materials look dark when compared to their non-conducting
              // dielectric equivalent, so for design sake, we're artificially
              // inflating the brightness.
              //sCol *= 1.5f;
          }
          else {
              // Dielectic material.
              roughness = 0.3f  + Roughness;
              roughness *= (rGr*0.4f + 0.6f);
              oCol *= tx*0.6f + 0.9f;
          }
        }

        if(RANDOM_MATERIALS)
        {
          roughness = hash21(gIP + 0.31f)*(rGr*0.5f + 0.5f) + Roughness;
          matType = step(0.5f, hash21(gIP + 0.32f));
          reflectance = hash21(gIP + 0.33f);
          oCol *= tx*2.5f + 0.2f;// + 0.5f;
        }
    }

    /*
    // Requires "St Peter's Basillica" cube map loaded into "iChannel3".
    // Specular reflection.
    float3 hv = normalize(-r + ld); // Half vector.
    float3 ref = reflect(r, n); // Surface reflection.
    float4 refTx = texture(iChannel3, -swi3(ref,y,z,x), 1.0f); refTx *= refTx; // Cube map.
    float spRef = _powf(_fmaxf(dot(hv, n), 0.0f), 8.0f); // Specular reflection.
    //spRef = _mix(spRef/4.0f, spRef, 1.0f - smoothstep(0.0f, 0.01f, d + 0.05f));
    float rf = (matType < 0.5f)? 0.25f : 2.0f;//_mix(0.25f, 4.0f, 1.0f - smoothstep(0.0f, 0.01f, d + 0.05f));
    oCol += oCol*reflectance*spRef*swi3(refTx,z,y,x)*rf; //smoothstep(0.03f, 1.0f, spRef)
    */

    // I wanted to use a little more than a constant for ambient light this
    // time around, but without having to resort to sophisticated methods, then I
    // remembered Blackle's example, here:
    // Quick Lighting Tech - blackle
    // https://www.shadertoy.com/view/ttGfz1
    float am = _powf(length(sin_f3(n*2.0f)*0.5f + 0.5f)/_sqrtf(3.0f), 2.0f)*1.5f; // Studio.
    //float am = length(_sinf(n*2.0f)*0.5f + 0.5f)/_sqrtf(3.0f)*smoothstep(-1.0f, 1.0f, -n.z); // Outdoor.

    // Cook-Torrance based lighting.
    float3 ct = BRDF(oCol, n, ld, -r, matType, roughness + Roughness, reflectance);

    // Combining the ambient and microfaceted terms to form the final color:
    // None of it is technically correct, but it does the job. Note the hacky
    // ambient shadow term. Shadows on the microfaceted metal doesn't look
    // right without it... If an expert out there knows of simple ways to
    // improve this, feel free to let me know. :)
    swi3S(c,x,y,z, (oCol*am*(sh*0.5f + 0.5f) + ct*(sh))*ao*at);

    // Save the linear color to the backbuffer.
    c = to_float4_aw(_fmaxf(swi3(c,x,y,z), to_float3_s(0.0f)), t);

// Debug
//c = to_float4_aw(d3.F,1.0f);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, c);
}

// ----------------------------------------------------------------------------------
// - Image                                                                          -
// ----------------------------------------------------------------------------------
// Connect Image 'Previsualization: Buffer A' to iChannel0

/*
    Extruded Bauhaus Truchet Pattern
    --------------------------------

    See "Buffer A" for an explanation.

*/

// Just a very basic depth of field routine -- I find a lot of it is
// common sense. Basically, you store the scene distance from the camera
// in the fourth channel, then use it to determine how blurry you want
// your image to be at that particular distance.
//
// For instance, in this case, I want pixels that are 2.5f units away from
// the camera to be in focus (not blurred) and for things to get more
// blurry as you move away from that point -- aptly named the focal point
// for non camera people. :)
//
// I based this on old code of mine, but adopted things that I found in
// IQ and Nesvi7's examples, which you can find here:
//
// Ladybug - IQ
// https://www.shadertoy.com/view/4tByz3
//
// Cube surface II - Nesvi7
// https://www.shadertoy.com/view/Mty3DV
//
__DEVICE__ float3 _DpthFld(__TEXTURE2D__ iCh, float2 uv, float focD, float coc){

    // Focal point and circle of confusion.
//    const float focD = 2.5f, coc = 0.5f;
    // Linear distance from either side of the focal point.
    float l = _fabs(_tex2DVecN(iCh,uv.x,uv.y,15).w - focD - coc) - coc;
    // Using it to calculate the DOF.
    float dof = clamp(l/coc, 0.0f, 2.0f);

    // Combine samples. Samples with a larger DOF value are taken further
    // away from the original point, and as such appear blurrier.
    float3 _acc = to_float3_s(0);

    for(int i = 0; i<25; i++){
        // Accumulate samples.
        _acc += swi3(texture(iCh, uv + (to_float2(i/5, i%5) - 2.0f)/to_float2(800, 450)*dof),x,y,z);
        //acc.x *= dof/2.0f;
    }

    // Return the new variably blurred value.
    _acc /= 25.0f;
    return _acc;
    //return _acc /= 25.0f;

    // Visual debug representation of DOF value.
    //return to_float3_aw(length(dof)*450.0f/2.5f);
}


// Standard 2D rotation formula.
//mat2 rot2(in float a){ float c = _cosf(a), s = _sinf(a); return mat2(c, -s, s, c); }


__KERNEL__ void ExtrudedBauhausTruchetPatternFuse(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0,  __TEXTURE2D__ iChannel1,  __TEXTURE2D__ iChannel2, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  int    iFrame      = params->iFrame;
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  bool   RANDOM_MATERIALS = params->RANDOM_MATERIALS;
  bool   SWIZZLE_PALETTE = params->SWIZZLE_PALETTE;
  bool   LINES = params->LINES;
  int    COLOR_VARIETY = params->COLOR_VARIETY;
  float  METAL_AMOUNT = params->METAL_AMOUNT;
  float  GOLD_AMOUNT = params->GOLD_AMOUNT;
  float  Roughness = params->Roughness;
  float  matType = params->matType;
  float  reflectance = params->reflectance;
  float2 ViewXY = to_float2(params->ViewXY[0], params->ViewXY[1]);
  float  ViewZ = params->ViewZ;
  float2 LightXY = to_float2(params->LightXY[0], params->LightXY[1]);
  float  LightZ = params->LightZ;
  float  Scale = params->Scale;
  float  Alpha = params->Alpha;
  bool   Vignette = params->Vignette;
  float  focD = params->focD;
  float  coc = params->coc;

  // --------

    mat2 dummyMat2;
    mat3 dummyMat3;

    // Screen oordinates.
    float2 uv = fragCoord/iResolution;

    float4 col = swi4(_DpthFld(iChannel0, uv, focD, coc),x,y,z,z);

    // Retrieving the stored color.
    //vec4 col = _tex2DVecN(iChannel0,uv.x,uv.y,15);

    // Subtle vignette.
    if(Vignette)
      col *= _powf(16.0f*uv.x*uv.y*(1.0f - uv.x)*(1.0f - uv.y) , 1.0f/32.0f);

    // Rough gamma correction and screen presentation.
    fragColor = pow_f4(_fmaxf(col, to_float4_s(0.0f)), to_float4_s(1.0f/2.2f));
    fragColor.w = Alpha;

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
]]
-- /*



-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ShaderFuse.begin_create()

  ----- Inspector Panel Controls

  
  -- Speed Slider
  
  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",
  })
  
  -- iMouse Controls
  
  InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    --INP_Passive = true,
    INPID_PreviewControl = "CrosshairControl",
  })
  
  InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    --INP_Passive = true,
    INPID_PreviewControl = "CrosshairControl",
    INP_Disabled = true,
  })
  
  InMouseDrag = self:AddInput("Mouse Button Pressed", "iMouseClick", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = false,
    --INP_Passive = true,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0,
  })
  InRANDOM_MATERIALSCheckbox = self:AddInput("RANDOM_MATERIALS", "RANDOM_MATERIALS", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  InSWIZZLE_PALETTECheckbox = self:AddInput("SWIZZLE_PALETTE", "SWIZZLE_PALETTE", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  InLINESCheckbox = self:AddInput("LINES", "LINES", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  InCOLOR_VARIETYSlider = self:AddInput("COLOR_VARIETY", "COLOR_VARIETY", {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_MinScale       = 0,
      INP_MaxScale       = 3,
      INP_Default        = 2,
      INP_Integer        = true,
  })

  InMETAL_AMOUNTSlider = self:AddInput("METAL_AMOUNT", "METAL_AMOUNT", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.35,
      })

  InGOLD_AMOUNTSlider = self:AddInput("GOLD_AMOUNT", "GOLD_AMOUNT", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.35,
      })

  InRoughnessSlider = self:AddInput("Roughness", "Roughness", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 2.0,
          INP_Default        = 0.0,
      })

  InmatTypeSlider = self:AddInput("matType", "matType", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 5.0,
          INP_Default        = 0.0,
      })

  InreflectanceSlider = self:AddInput("reflectance", "reflectance", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 3.0,
          INP_Default        = 0.5,
      })

  InViewXYPoint = self:AddInput("ViewXY", "ViewXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InViewZSlider = self:AddInput("ViewZ", "ViewZ", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InLightXYPoint = self:AddInput("LightXY", "LightXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InLightZSlider = self:AddInput("LightZ", "LightZ", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InScaleSlider = self:AddInput("Scale", "Scale", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.5,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InAlphaSlider = self:AddInput("Alpha", "Alpha", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 1.0,
      })

  InVignetteCheckbox = self:AddInput("Vignette", "Vignette", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  InfocDSlider = self:AddInput("focD", "focD", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 2.5,
      })

  IncocSlider = self:AddInput("coc", "coc", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.5,
      })



  Sep3 = self:AddInput(string.rep("_", 152), "Separator3", {
    LINKID_DataType     = "Text",
    INPID_InputControl  = "LabelControl",
    INP_External        = false,
    INP_Passive         = true,
    IC_Visible          = true,
    INP_DoNotifyChanged = true,
    IC_NoLabel          = true,
  })
  
  
  InEdges = self:AddInput("Edges", "Edges", {
    LINKID_DataType = "Number",
    INPID_InputControl  = "MultiButtonControl",
    INP_Default         = 3.0,
    INP_Integer         = true,
    INP_DoNotifyChanged = true,
    INP_External        = false,
    MBTNC_ForceButtons  = true,
    INP_MinScale        = 0,
    INP_MaxScale        = 3,
    INP_MinAllowed      = 0,
    INP_MaxAllowed      = 3,
    MBTNC_ShowBasicButton = true,
    MBTNC_StretchToFit  = false, --true,
    MBTNC_ShowToolTip   = true,
    { MBTNC_AddButton = "Canvas", MBTNCD_ButtonWidth = 4/16, },
    { MBTNC_AddButton = "Wrap",MBTNCD_ButtonWidth = 3/16, },
    { MBTNC_AddButton = "Duplicate", MBTNCD_ButtonWidth = 5/16, },
    { MBTNC_AddButton = "Mirror", MBTNCD_ButtonWidth = 4/16, }, 
   }) 

  InDebugImage = self:AddInput("DebugImage", "DebugImage", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Final", },
    { CCS_AddString = "BufferA", },
    CC_LabelPosition = "Horizontal",
  })

  ----- Size & Depth
  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
    INP_DoNotifyChanged = true,
    INP_Default        = 0,
    INP_Integer        = true,
    ICD_Width          = 1,
	  { CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	  { CCS_AddString  = "Image0", },
    { CCS_AddString  = "1920x1080", },
	  { CCS_AddString  = "1200x675", },
	  { CCS_AddString  = "800x450", },
	  { CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
  
  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default      = 3,
    INP_Integer      = true,
    ICD_Width        = 1,
    { CCS_AddString  = "Default", },
	  { CCS_AddString  = "int8", },
	  { CCS_AddString  = "int16", },
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
    ICS_ControlPage  = "Image",
  })
  
  InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false }) 

  ----- In/Out

  InChannel0 = self:AddInput( "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
  InChannel1 = self:AddInput( "iChannel1",  "iChannel1",  { LINKID_DataType = "Image", LINK_Main = 2, INP_Required = false  })
  InChannel2 = self:AddInput( "iChannel2",  "iChannel2",  { LINKID_DataType = "Image", LINK_Main = 3,LINK_Visible = false, INP_Required = false  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main       = 1,
  })


  ShaderFuse.end_create()

end



-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------
function DefineEdges(edges, nodeX)

    --This gets the value of our input image for us to modify inside the kernel
    if edges == 0 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 1 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_WRAP, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 2 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_DUPLICATE, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 3 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 4 then
      --print("Sampler 4")
    end
end



MULTIBUFFER = true
if MULTIBUFFER then   -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  ImgAttrs_Global = {
          { IMG_Channel = "Red", },
          { IMG_Channel = "Green", },
          { IMG_Channel = "Blue", },
          { IMG_Channel = "Alpha", },
          IMG_Width = Width,
          IMG_Height = Height,
          IMG_DeferAlloc = false,
          }

  Image_Buff_GlobalA = Image(ImgAttrs_Global)
end


function Process(req)

	-- Imagesize and Depth
  if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InChannel0:GetValue(req) ~= nil) then
			   Width = InChannel0:GetValue(req).Width
			   Height = InChannel0:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value 
		end
	end	
  
  -- Alle ( int und float )
  if (InDepth:GetValue(req).Value > 0) then
	  if InDepth:GetValue(req).Value == 1 then 
	    SourceDepth = 5 
    else 
	    if InDepth:GetValue(req).Value == 2 then 
	        SourceDepth = 6 
	    else 
	        if InDepth:GetValue(req).Value == 3 then 
 		        SourceDepth = 7 
		    	else
			      SourceDepth = 8
	        end
		  end
	  end
	end

  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth  = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }

  local dst   = Image(imgattrs)
  local black = Pixel({R=0,G=0,B=0,A=0})
  dst:Fill(black)

if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  dstA = Image {IMG_Like = dst, IMG_DeferAlloc = true}
end

  if req:IsPreCalc() then
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end


if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA = DVIPComputeNode(req,
    "ExtrudedBauhausTruchetPatternFuse__Buffer_A", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
else
    node = DVIPComputeNode(req,
    "ExtrudedBauhausTruchetPatternFuse", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
end
  -- Extern texture or create a new one

  iChannel0 = InChannel0:GetValue(req)

  if iChannel0==nil then
    iChannel0 = Image(imgattrs)
    iChannel0:Fill(black)
  end

  iChannel1 = InChannel1:GetValue(req)

  if iChannel1==nil then
    iChannel1 = Image(imgattrs)
    iChannel1:Fill(black)
  end

  iChannel2 = InChannel2:GetValue(req)

  if iChannel2==nil then
    iChannel2 = Image(imgattrs)
    iChannel2:Fill(black)
  end

  -- DCTL parameters

  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    params = nodeA:GetParamBlock(ShaderParameters)
  else  
    params = node:GetParamBlock(ShaderParameters)
  end  

  params.iResolution[0] = dst.Width
  params.iResolution[1] = dst.Height
  params.iTime = (req.Time / framerate) * InFrequency:GetValue(req).Value
  
  -- iMouse
  
  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)
  
  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y
  
  if InMouseDrag:GetValue(req).Value ~= 0 then
    if params.iMouse[2]==-1 and params.iMouse[3]==-1 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = -1
    params.iMouse[3] = -1
  end
  
  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end
  
  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  if params.iMouse[2] == -1 and params.iMouse[3] == -1 then
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  else
    params.iMouse[2] = params.iMouse[2] * Width
    params.iMouse[3] = params.iMouse[3] * Height
  end
  params.iFrame = req.Time

  params.RANDOM_MATERIALS = InRANDOM_MATERIALSCheckbox:GetValue(req).Value
  params.SWIZZLE_PALETTE = InSWIZZLE_PALETTECheckbox:GetValue(req).Value
  params.LINES = InLINESCheckbox:GetValue(req).Value
  params.COLOR_VARIETY = InCOLOR_VARIETYSlider:GetValue(req).Value
  params.METAL_AMOUNT = InMETAL_AMOUNTSlider:GetValue(req).Value
  params.GOLD_AMOUNT = InGOLD_AMOUNTSlider:GetValue(req).Value
  params.Roughness = InRoughnessSlider:GetValue(req).Value
  params.matType = InmatTypeSlider:GetValue(req).Value
  params.reflectance = InreflectanceSlider:GetValue(req).Value
  params.ViewXY = {InViewXYPoint:GetValue(req).X,InViewXYPoint:GetValue(req).Y}
  params.ViewZ = InViewZSlider:GetValue(req).Value
  params.LightXY = {InLightXYPoint:GetValue(req).X,InLightXYPoint:GetValue(req).Y}
  params.LightZ = InLightZSlider:GetValue(req).Value
  params.Scale = InScaleSlider:GetValue(req).Value
  params.Alpha = InAlphaSlider:GetValue(req).Value
  params.Vignette = InVignetteCheckbox:GetValue(req).Value
  params.focD = InfocDSlider:GetValue(req).Value
  params.coc = IncocSlider:GetValue(req).Value
  -- Resolution

  params.width  = dst.Width
  params.height = dst.Height

  -- Per channel time and resolution


    local edges = InEdges:GetValue(req).Value

  -- Set parameters and add I/O
  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA:SetParamBlock(params)
    --nodeA:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, nodeA)
    
    
  else   
    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)
    
    node:AddInput("iChannel0",iChannel0) -- TODO: add a better channel name
    node:AddInput("iChannel1",iChannel1) -- TODO: add a better channel name
    node:AddInput("iChannel2",iChannel2) -- TODO: add a better channel name
    node:AddOutput("dst", dst)
  end
  
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA:AddInput("iChannel0",Image_Buff_GlobalA)  -- Anpassen !!
    nodeA:AddInput("iChannel1",iChannel0)  -- Anpassen !!
    nodeA:AddInput("iChannel2",iChannel1)  -- Anpassen !!
    nodeA:AddOutput("dst", dstA)

    local ok = nodeA:RunSession(req)

    if (not ok) then
      dstA = nil
      dump(nodeA:GetErrorLog())
    end
    
    Image_Buff_GlobalA = dstA

  
    -------------------------- ImageKernel----------------------------------------
    node = DVIPComputeNode(req,
      "ExtrudedBauhausTruchetPatternFuse", ShaderCompatibilityCode..ShaderKernelCode,
      "Params", ShaderParameters
    )

    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)

    node:AddInput("iChannel0", Image_Buff_GlobalA)  -- Anpassen !!
    node:AddInput("iChannel1", iChannel0)           -- Anpassen !!
    node:AddInput("iChannel2", iChannel1)           -- Anpassen !!
    node:AddOutput("dst", dst)
 
  end -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  
  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    dump(node:GetErrorLog())
	end

  OutImage:Set(req,dst)
  
  
    --Debugging
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER
    InDebugImage:SetAttrs({ IC_Visible = true })
    
    if (InDebugImage:GetValue(req).Value == 1) then OutImage:Set(req, Image_Buff_GlobalA) end
  else
    InDebugImage:SetAttrs({ IC_Visible = false })
  end
    
  
  collectgarbage();
end



-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

function NotifyChanged(inp, param, time)
 	if (param ~= nil) then

		if inp == InSize then
		  if param.Value == 1 then
			  InWidth:SetAttrs({ IC_Visible = true })
			  InHeight:SetAttrs({ IC_Visible = true })
		  else
			  InWidth:SetAttrs({ IC_Visible = false })
			  InHeight:SetAttrs({ IC_Visible = false })
		  end
		  
		  if param.Value == 3 then --1920x1080
			  InWidth:SetSource(Number(1920),0,0)
			  InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			  InWidth:SetSource(Number(1200),0,0)
			  InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			  InWidth:SetSource(Number(800),0,0)
			  InHeight:SetSource(Number(450),0,0)
		  end
 	    if param.Value == 6 then --640x360
		    InWidth:SetSource(Number(640),0,0)
		    InHeight:SetSource(Number(360),0,0)
		  end
		end 

 	end
end


-- */
