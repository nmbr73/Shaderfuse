--[[--/*

  TinyHideout.fuse

  Based on https://www.shadertoy.com/view/DlKBDh a WebGL shader created by _pwd_.
  Converted to DCTL and embeddet into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT).
  Place this file in your Fusion's and/or DaVinci Resolve's 'Fuses/' folder to use it.

*/--]]--




-- /*
local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()



-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,
  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  })



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------

-- */
ShaderParameters =
[[

  float  iResolution[2];
  float  iTime;
  float  iMouse[4];
  float  ColLeafs[4];
  float  ColGround[4];
  float  ColGroundTOP[4];
  float  ColPlate[4];
  float  ColWalls[4];
  float  ColRoof[4];
  float  ColEntrance[4];
  float  ColWindow[4];
  float  ColDust[4];
  float  ColSand[4];
  float  ColSky1[4];
  float  ColSky2[4];
  float  ColWater[4];
  float  BLOOM_SIZE;
  float  BLOOM_THRESHOLD;
  float  BLOOM_RANGE;
  float  BLOOM_FRAME_BLEND;

  int    width,height;
  int    compOrder;

]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel compatibility code
-- // ------------------------------------------------------------------------

-- */
ShaderCompatibilityCode =
[[


#if defined(DEVICE_IS_METAL)
  #define in
  #define out thread
  #define inout thread
#else
  #define in
  #define out
  #define inout
#endif

#undef USE_NATIVE_METAL_IMPL
#undef USE_NATIVE_CUDA_IMPL
#undef USE_NATIVE_OPENCL_IMPL

  // 0 to use the generic implementations; 1 for Metal, OpenCL, Cuda specific code if existing

  #if 1
    #if defined(DEVICE_IS_METAL)
      #define USE_NATIVE_METAL_IMPL   1
    #elif defined(DEVICE_IS_CUDA)
      #define USE_NATIVE_CUDA_IMPL    1
    #elif defined(DEVICE_IS_OPENCL)
      #define USE_NATIVE_OPENCL_IMPL  1
    #endif
  #endif

  #if defined(USE_NATIVE_METAL_IMPL)

    #define swi2(A,a,b)     (A).a##b
    #define swi3(A,a,b,c)   (A).a##b##c

    #define swi2S(a,b,c,d)   a.b##c = d
    #define swi3S(a,b,c,d,e) a.b##c##d = e

  #else

    #define swi2(A,a,b)     to_float2((A).a,(A).b)
    #define swi3(A,a,b,c)   to_float3((A).a,(A).b,(A).c)

    #define swi2S(a,b,c,d)   {float2 tmp = d; (a).b = tmp.x; (a).c = tmp.y;}
    #define swi3S(a,b,c,d,e) {float3 tmp = e; (a).b = tmp.x; (a).c = tmp.y; (a).d = tmp.z;}
    #define swi4S(a,b,c,d,e,f) {float4 tmp = f; (a).b = tmp.x; (a).c = tmp.y; (a).d = tmp.z; (a).e = tmp.w;}

  #endif

// ----------------------------------------------------------------------------------------------------------
// mat3 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float3x3 mat3;

  __DEVICE__ inline mat3 to_mat3( float a, float b, float c, float d, float e, float f, float g, float h, float i)
  {
    return mat3(a,b,c,d,e,f,g,h,i);
  }

  __DEVICE__ inline mat3 to_mat3_f3( float3 a, float3 b, float3 c ) { return mat3(a,b,c); }
  __DEVICE__ inline float3 mul_mat3_f3( mat3 B, float3 A) { return (B*A); }

#else

  typedef struct { float3 r0; float3 r1; float3 r2; } mat3;

  __DEVICE__ inline mat3 to_mat3( float  a, float  b, float c,   float d, float e, float f,   float g, float h, float i)
  {
    mat3 t;
    t.r0.x = a; t.r0.y = b; t.r0.z = c;
    t.r1.x = d; t.r1.y = e; t.r1.z = f;
    t.r2.x = g; t.r2.y = h; t.r2.z = i;
    return t;
  }

  __DEVICE__ inline mat3 to_mat3_f3( float3 A, float3 B, float3 C)
  {
    mat3 D;
    D.r0 = A;
    D.r1 = B;
    D.r2 = C;
    return D;
  }

__DEVICE__ inline float3 mul_mat3_f3( mat3 B, float3 A) {
    float3 C;

    C.x = A.x * B.r0.x + A.y * B.r1.x + A.z * B.r2.x;
    C.y = A.x * B.r0.y + A.y * B.r1.y + A.z * B.r2.y;
    C.z = A.x * B.r0.z + A.y * B.r1.z + A.z * B.r2.z;
    return C;
  }

#endif // end of mat3 implementation

// ----------------------------------------------------------------------------------------------------------
// mat4 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float4x4 mat4;

  __DEVICE__ inline mat4 to_mat4( float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o, float p)
  {
    return mat4(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
  }

  __DEVICE__ inline float4 mul_mat4_f4( mat4 B, float4 A) { return (B*A); }

#else

  typedef struct { float4 r0; float4 r1; float4 r2; float4 r3; } mat4;

  __DEVICE__ inline mat4 to_mat4( float  a, float  b, float c,   float d, float e, float f,   float g, float h, float i, float j, float k, float l, float m, float n, float o, float p)
  {
    mat4 t;
    t.r0.x = a; t.r0.y = b; t.r0.z = c; t.r0.w = d;
    t.r1.x = e; t.r1.y = f; t.r1.z = g; t.r1.w = h;
    t.r2.x = i; t.r2.y = j; t.r2.z = k; t.r2.w = l;
    t.r3.x = m; t.r3.y = n; t.r3.z = o; t.r3.w = p;
    return t;
  }

__DEVICE__ inline float4 mul_mat4_f4( mat4 B, float4 A)
  {
    float4 C;
    C.x = A.x * B.r0.x + A.y * B.r1.x + A.z * B.r2.x + A.w * B.r3.x;
    C.y = A.x * B.r0.y + A.y * B.r1.y + A.z * B.r2.y + A.w * B.r3.y;
    C.z = A.x * B.r0.z + A.y * B.r1.z + A.z * B.r2.z + A.w * B.r3.z;
    C.w = A.x * B.r0.w + A.y * B.r1.w + A.z * B.r2.w + A.w * B.r3.w;
    return C;
}

#endif // end of mat4 implementation

#if defined(USE_NATIVE_METAL_IMPL)

 #define fract_f3(A) fract(A)

 #define mod_f(a,b)  fmod((a),(b))
 #define mod_f2(value,divisor) fmod(value,divisor)
 #define mod_f2f2(value,divisor) fmod(value,divisor)

 #define sin_f3(i) sin(i)
 #define abs_f2(a) _fabs(a)
 #define abs_f3(a) _fabs(a)
 #define sqrt_f3(a) _sqrtf(a)
 #define sign_f(a) sign(a)
 #define pow_f3(a,b) pow(a,b)

#else

  #if defined(USE_NATIVE_OPENCL_IMPL)

    #define reflect(I,N) (I-2.0f*dot(N,I)*N)

    #define fract(a) ((a)-_floor(a))  // oder Pointer bauen: gentype fract(gentype x, gentype *itpr)

 #define fract_f3(A) to_float3(fract((A).x),fract((A).y),fract((A).z))
 #define mod_f(a,b) _fmod(a,b)
 #define mod_f2(value,divisor) _fmod(value,divisor)
 #define mod_f2f2(value,divisor) _fmod(value,divisor)
 #define sin_f3(i) sin(i)
 #define abs_f2(a) fabs(a)
 #define abs_f3(a) fabs(a)
 #define sqrt_f3(a) _sqrtf(a)
 #define sign_f(a) sign(a)
 #define pow_f3(a,b) pow(a,b)

 #else // Generic

    #define fract(a) ((a)-_floor(a))

 #define fract_f3(A) to_float3(fract((A).x),fract((A).y),fract((A).z))
 #define mod_f(a,b) ((a)-(b)*_floor((a)/(b)))
 #define mod_f2(value,divisor) to_float2(mod_f((value).x, (divisor)),mod_f((value).y, (divisor)))
 #define mod_f2f2(value,divisor) to_float2(mod_f((value).x, (divisor).x),mod_f((value).y, (divisor).y))
 #define sin_f3(i) to_float3( _sinf((i).x), _sinf((i).y), _sinf((i).z))
 #define abs_f2(a) to_float2(_fabs((a).x), _fabs((a).y))
 #define abs_f3(a) to_float3(_fabs((a).x), _fabs((a).y),_fabs((a).z))
 #define sqrt_f3(a) to_float3(_sqrtf((a).x),_sqrtf((a).y),_sqrtf((a).z))
 #define sign_f(a) (a==0.0f?0.0f:a>0.0f?1.0f:-1.0f)
 #define pow_f3(a,b) to_float3(_powf((a).x,(b).x),_powf((a).y,(b).y),_powf((a).z,(b).z))

  #endif

#endif


]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel implementation
-- // ------------------------------------------------------------------------

-- */
ShaderKernelCode =
[[

// ----------------------------------------------------------------------------------
// - Common                                                                         -
// ----------------------------------------------------------------------------------
#define texture(ch,uv) _tex2DVecN(ch, (uv).x, (uv).y, 15)

//////////////////////////////////////////////////////////////////////////////////////
// defines & constants
//////////////////////////////////////////////////////////////////////////////////////

#define ANIMATE_WATER 1

//Bloom
//#define BLOOM_SIZE      (0.5f)
//#define BLOOM_THRESHOLD (1.01f)
//#define BLOOM_RANGE     (0.3f)
//#define BLOOM_FRAME_BLEND (0.2f)

//utility defines
#define ZERO   0 //(_fminf(1,0))
#define X_AXIS to_float3(1,0,0)
#define Y_AXIS to_float3(0,1,0)
#define Z_AXIS to_float3(0,0,1)

#define PI 3.14159265f
#define TAU (2*PI)
#define PHI (_sqrtf(5)*0.5f + 0.5f)

// Materials
#define MAT_WOOD  101
#define MAT_LEAFS 102
#define MAT_UNDERWATER 301
#define MAT_PLANT 701
#define MAT_STONE 801

#define MAT_GROUNDPLATE 203
#define MAT_GROUNDPLATE_TOP 204
#define MAT_BASEPLATE 205
#define MAT_WALLS 206
#define MAT_ROOF 207
#define MAT_ENTRANCE 208
#define MAT_WINDOW 209
#define MAT_DUST 210



//////////////////////////////////////////////////////////////////////////////////////
// utility functions
//////////////////////////////////////////////////////////////////////////////////////
  __DEVICE__ inline mat3 multi( float B, mat3 A)
  {
  return to_mat3_f3(A.r0 * B, A.r1 * B, A.r2 * B);
  }

  __DEVICE__ inline mat3 inverse( mat3 A)
  {
   mat3 R;
   float result[3][3];
   float a[3][3] = {{A.r0.x, A.r0.y, A.r0.z},
                    {A.r1.x, A.r1.y, A.r1.z},
                    {A.r2.x, A.r2.y, A.r2.z}};

   float det = a[0][0] * a[1][1] * a[2][2]
             + a[0][1] * a[1][2] * a[2][0]
             + a[0][2] * a[1][0] * a[2][1]
             - a[2][0] * a[1][1] * a[0][2]
             - a[2][1] * a[1][2] * a[0][0]
             - a[2][2] * a[1][0] * a[0][1];
   if( det != 0.0 )
   {
     result[0][0] = a[1][1] * a[2][2] - a[1][2] * a[2][1];
     result[0][1] = a[2][1] * a[0][2] - a[2][2] * a[0][1];
     result[0][2] = a[0][1] * a[1][2] - a[0][2] * a[1][1];
     result[1][0] = a[2][0] * a[1][2] - a[1][0] * a[2][2];
     result[1][1] = a[0][0] * a[2][2] - a[2][0] * a[0][2];
     result[1][2] = a[1][0] * a[0][2] - a[0][0] * a[1][2];
     result[2][0] = a[1][0] * a[2][1] - a[2][0] * a[1][1];
     result[2][1] = a[2][0] * a[0][1] - a[0][0] * a[2][1];
     result[2][2] = a[0][0] * a[1][1] - a[1][0] * a[0][1];

     R = to_mat3_f3(make_float3(result[0][0], result[0][1], result[0][2]),
                    make_float3(result[1][0], result[1][1], result[1][2]),
                    make_float3(result[2][0], result[2][1], result[2][2]));
     return multi( 1.0f / det, R);
   }
   R = to_mat3_f3(make_float3(1.0f, 0.0f, 0.0f), make_float3(0.0f, 1.0f, 0.0f), make_float3(0.0f, 0.0f, 1.0f));
   return R;
  }


__DEVICE__ mat3 rotation(float3 axis, float angle)
{
    //axis = normalize(axis);
    float s = _sinf(angle);
    float c = _cosf(angle);
    float oc = 1.0f - c;

    return inverse(to_mat3(oc * axis.x * axis.x + c,
                           oc * axis.x * axis.y - axis.z * s,
                           oc * axis.z * axis.x + axis.y * s,
                           oc * axis.x * axis.y + axis.z * s,
                           oc * axis.y * axis.y + c,
                           oc * axis.y * axis.z - axis.x * s,
                           oc * axis.z * axis.x - axis.y * s,
                           oc * axis.y * axis.z + axis.x * s,
                           oc * axis.z * axis.z + c));
}

__DEVICE__ float3 rotateX(float3 pos, float alpha) {
    mat4 trans = to_mat4(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, _cosf(alpha), -_sinf(alpha), 0.0f, 0.0f, _sinf(alpha), _cosf(alpha), 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);
    return swi3((mul_mat4_f4(trans , to_float4_aw(pos, 1.0f))),x,y,z);
}


__DEVICE__ float3 rotateY(float3 pos, float alpha) {
    mat4 trans2 = to_mat4(_cosf(alpha), 0.0f, _sinf(alpha), 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,-_sinf(alpha), 0.0f, _cosf(alpha), 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);
    return swi3((mul_mat4_f4(trans2 , to_float4_aw(pos, 1.0f))),x,y,z);
}


//////////////////////////////////////////////////////////////////////////////////////
// sdf blend & domain repetition (
//////////////////////////////////////////////////////////////////////////////////////

//HG
__DEVICE__ float fOpUnionRound(float a, float b, float r)
{
  float2 u = _fmaxf(to_float2(r - a,r - b), to_float2_s(0));
  return _fmaxf(r, _fminf (a, b)) - length(u);
}

__DEVICE__ float pModPolar(inout float2 *p, float repetitions)
{
  float angle = 2.0f*PI/repetitions;
  float a = _atan2f((*p).y, (*p).x) + angle/2.0f;
  float r = length(*p);
  float c = _floor(a/angle);
  a = mod_f(a,angle) - angle/2.0f;
  *p = to_float2(_cosf(a), _sinf(a))*r;
  // For an odd number of repetitions, fix cell index of the cell in -x direction
  // (cell index would be e.g. -5 and 5 in the two halves of the cell):
  if (_fabs(c) >= (repetitions/2.0f)) c = _fabs(c);
  return c;
}

// Repeat in two dimensions
__DEVICE__ float2 pMod2(inout float2 *p, float2 size) {
  float2 c = _floor((*p + size*0.5f)/size);
  *p = mod_f2f2(*p + size*0.5f,size) - size*0.5f;
  return c;
}

// Same, but mirror every second cell so all boundaries match
__DEVICE__ float2 pModMirror2(inout float2 *p, float2 size) {
  float2 halfsize = size*0.5f;
  float2 c = _floor((*p + halfsize)/size);
  *p = mod_f2f2(*p + halfsize, size) - halfsize;
  *p *= mod_f2(c,(2))*2.0f - to_float2_s(1.0f);
  return c;
}

__DEVICE__ float fOpIntersectionRound(float a, float b, float r)
{
  float2 u = _fmaxf(to_float2(r + a,r + b), to_float2_s(0));
  return _fminf(-r, _fmaxf (a, b)) + length(u);
}

__DEVICE__ float fOpDifferenceRound (float a, float b, float r)
{
  return fOpIntersectionRound(a, -b, r);
}

//IQ
__DEVICE__ float opSmoothUnion( float d1, float d2, float k )
{
    float h = clamp( 0.5f + 0.5f*(d2-d1)/k, 0.0f, 1.0f );
    return _mix( d2, d1, h ) - k*h*(1.0f-h);
}

//IQ
__DEVICE__ float opSubtraction( float d1, float d2 )
{
    return _fmaxf(-d1,d2);
}

// min/max polynomial
__DEVICE__ float smin( float a, float b, float k )
{
  float h = clamp( 0.5f + 0.5f*(b-a)/k, 0.0f, 1.0f );
  return _mix( b, a, h ) - k*h*(1.0f-h);
}
__DEVICE__ float smax(float a, float b, float k)
{
    return smin(a, b, -k);
}

__DEVICE__ float smoothDiff(float d2, float d1, float k) {
    float h = clamp(0.5f - 0.5f * (d2 + d1) / k, 0.0f, 1.0f );
    return _mix(d2, -d1, h ) + k * h * (1.0f - h);
}



//////////////////////////////////////////////////////////////////////////////////////
// basic sdf shapes
//////////////////////////////////////////////////////////////////////////////////////

__DEVICE__ float sdSphere( float3 p, float s )
{
    return length(p)-s;
}

__DEVICE__ float sdBox( float3 p, float3 b )
{
    float3 d = abs_f3(p) - b;
    return _fminf(_fmaxf(d.x,_fmaxf(d.y,d.z)),0.0f) + length(_fmaxf(d,to_float3_s(0.0f)));
}

__DEVICE__ float sdRoundBox( float3 p, float3 b, float r )
{
  float3 q = abs_f3(p) - b;
  return length(_fmaxf(q,to_float3_s(0.0f))) + _fminf(_fmaxf(q.x,_fmaxf(q.y,q.z)),0.0f) - r;
}

__DEVICE__ float sdRoundBaseBox( float3 p, float3 b, float r )
{
    float b1 = sdRoundBox(p,b,r);
    float b2 = sdRoundBox(p + to_float3(-0.08f,0.0f,0.3f),to_float3(0.07f, 0.005f, 0.05f),r);

    return _fminf(b1,b2);
}

__DEVICE__ float sdCone(float3 p, float3 a, float3 b, float ra, float rb)
{
    float rba  = rb-ra;
    float baba = dot(b-a,b-a);
    float papa = dot(p-a,p-a);
    float paba = dot(p-a,b-a)/baba;
    float x = _sqrtf( papa - paba*paba*baba );
    float cax = _fmaxf(0.0f,x-((paba<0.5f)?ra:rb));
    float cay = _fabs(paba-0.5f)-0.5f;
    float k = rba*rba + baba;
    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0f, 1.0f );
    float cbx = x-ra - f*rba;
    float cby = paba - f;
    float s = (cbx < 0.0f && cay < 0.0f) ? -1.0f : 1.0f;
    return s*_sqrtf( _fminf(cax*cax + cay*cay*baba, cbx*cbx + cby*cby*baba) );
}

__DEVICE__ float sdEllipsoid( in float3 p, in float3 r ) // approximated
{
    float k0 = length(p/r);
    float k1 = length(p/(r*r));
    return k0*(k0-1.0f)/k1;
}

__DEVICE__ float dot2( in float2 v ) { return dot(v,v); }
__DEVICE__ float dot2_f3( in float3 v ) { return dot(v,v); }
__DEVICE__ float ndot( in float2 a, in float2 b ) { return a.x*b.x - a.y*b.y; }
__DEVICE__ float udTriangle( float3 p, float3 a, float3 b, float3 c )
{
  float3 ba = b - a; float3 pa = p - a;
  float3 cb = c - b; float3 pb = p - b;
  float3 ac = a - c; float3 pc = p - c;
  float3 nor = cross( ba, ac );

  return _sqrtf(
    (sign_f(dot(cross(ba,nor),pa)) +
     sign_f(dot(cross(cb,nor),pb)) +
     sign_f(dot(cross(ac,nor),pc))<2.0f)
     ?
     _fminf( _fminf(
     dot2_f3(ba*clamp(dot(ba,pa)/dot2_f3(ba),0.0f,1.0f)-pa),
     dot2_f3(cb*clamp(dot(cb,pb)/dot2_f3(cb),0.0f,1.0f)-pb) ),
     dot2_f3(ac*clamp(dot(ac,pc)/dot2_f3(ac),0.0f,1.0f)-pc) )
     :
     dot(nor,pa)*dot(nor,pa)/dot2_f3(nor) );
}



//////////////////////////////////////////////////////////////////////////////////////
// sdf shape combinations
//////////////////////////////////////////////////////////////////////////////////////



// Draws chimney´s edges
__DEVICE__ float chimneyEdges(float3 p)
{

    float b = sdRoundBox(p + to_float3(0.25f, -0.44f, -0.1f), to_float3(0.049f, 0.005f, 0.049f), 0.008f);
    float c = sdRoundBox( p + to_float3(0.25f, -0.46f, -0.1f), to_float3(0.011f, 0.017f, 0.011f), 0.011f);
    float d = smoothDiff(b, c, 0.02f);

    return d;
}

// Draws rooftop
__DEVICE__ float roofTop(float3 p, float3 r)
{
  float3 b = r;
  p.x = _fabs(p.x);
  p.y += p.x*0.4f;
  return length(_fmaxf(abs_f3(p)-b, to_float3_s(0.0f)))-0.03f;
}

// Draws house´s walls and fit walls with rooftop
__DEVICE__ float wallsAndRoof(float3 p, float3 dim, float r)
{
    float v = 0.0f;
    float c = 0.0f;

    c = roofTop(p + to_float3(0.0f, -0.23f, 0.0f), to_float3(0.366f, 0.03f, 0.366f));
    v = sdRoundBox(p, dim, r);

    return _fmaxf(v,-c);
}

__DEVICE__ float treeTrunk(float3 pos)
{
    float r = 1e10;

    r = sdCone(pos, to_float3(0.73f,0.0f,0.35f), to_float3(0.73f,0.23f,0.35f), 0.02f, 0.02f );
    r += _sinf(30.0f*pos.x)*_sinf(50.0f*pos.y)*_sinf(30.0f*pos.z) * 0.01f;

    r = _fminf(r, sdCone(pos, to_float3(-0.25f,0.0f,0.61f), to_float3(-0.25f,0.18f,0.61f), 0.017f, 0.018f ));
    r += _sinf(30.0f*pos.x)*_sinf(30.0f*pos.y)*_sinf(30.0f*pos.z) * 0.01f;

    return r;
}



#ifdef NotUsed
float3 cellpos;
float3 signvec;
float3 subpos;
float fsign;

__DEVICE__ float cf(float3 pos, inout float3 *cellpos, inout float3 *signvec, inout float3 *subpos, inout float *fsign ) {

  *cellpos=pos-_floor(pos);

  *signvec=2.0f*step(0.5f,*cellpos)-1.0f;
  *fsign=(*signvec).x*(*signvec).y*(*signvec).z;

  *subpos=abs_f3(abs_f3(*cellpos-0.5f)-0.25f);

  return *fsign*(_fmaxf(_fmaxf((*subpos).x,(*subpos).y),(*subpos).z)-0.25f);

}
#endif



__DEVICE__ float treeLeafs(float3 pos)
{
    float r = 1e10;

    float3 leafsDomainL = pos - to_float3(0.53f, 0.42f, 0.0f);
    float3 leafsDomainR = pos - to_float3(-0.53f, 0.42f, 0.0f);

    r = _fminf(r, sdRoundBox(leafsDomainL - to_float3(0.20f, -0.19f, 0.35f), to_float3(0.07f, 0.08f, 0.07f), 0.029f));
    r = _fminf(r, sdRoundBox(leafsDomainL - to_float3(0.28f, -0.10f, 0.35f), to_float3(0.02f, 0.025f, 0.02f), 0.029f));
    r = _fminf(r, sdRoundBox(leafsDomainL - to_float3(0.23f, -0.08f, 0.40f), to_float3(0.024f, 0.024f, 0.024f), 0.029f));
    r = _fminf(r, sdRoundBox(leafsDomainL - to_float3(0.13f, -0.16f, 0.29f), to_float3(0.02f, 0.02f, 0.02f), 0.029f));

    r = _fminf(r, sdRoundBox(leafsDomainR - to_float3(0.29f, -0.24f, 0.61f), to_float3(0.048f, 0.058f, 0.048f), 0.029f));
    r = _fminf(r, sdRoundBox(leafsDomainR - to_float3(0.24f, -0.23f, 0.65f), to_float3(0.02f, 0.02f, 0.02f), 0.029f));

    return r + 0.02f;
}



//float g1=0.0f,g2=0.0f,g3=0.0f;

__DEVICE__ float3 rot_f3(in float3 p,float3 a,float t){
  a=normalize(a);
  float3 u=cross(a,p),v=cross(a,u);
  p=u*_sinf(t)+v*_cosf(t)+a*dot(a,p);
  return p;
}

__DEVICE__ float2 rot(in float2 p,float t){
    p=p*_cosf(t)+to_float2(-p.y,p.x)*_sinf(t);
    return p;
}

// rewrote 20/12/01
__DEVICE__ float2 sFold45(in float2 p)
{
  float2 v=normalize(to_float2(1,-1));
  float g=dot(p,v);
  p-=(g-_sqrtf(g*g+5e-5f))*v;
  return p;
}

__DEVICE__ float stella(float3 p, float s)
{
    p=sqrt_f3(p*p+0.00005f); // https://iquilezles.org/articles/functions
    swi2S(p,x,z, sFold45(swi2(p,x,z)));
    swi2S(p,y,z, sFold45(swi2(p,y,z)));
    return dot(p,normalize(to_float3(1,1,-1)))-s;
}


#define seed 2576.0f
#define hash(p)fract_f3(sin_f3((p)*12345.5f))
__DEVICE__ float stellas(float3 p, float gTime)
{
    p.y-= gTime;
    float c=5.0f;
    float3 e=_floor(p/c);
    e = sin_f3(11.0f*(2.5f*e+3.0f*swi3(e,y,z,x)+1.345f));
    p-=e*0.5f;
    p=mod_f(p,c)-c*0.5f;
    p=rot_f3(p,hash(e+66.887f)-0.5f,gTime*1.5f);
    return _fminf(0.7f,stella(p,0.06f));
}

__DEVICE__ float rand_f2(float2 co)
{
    return fract(_sinf(dot(swi2(co,x,y) ,to_float2(12.9898f,78.233f))) * 43758.5453f);
}

__DEVICE__ float rand(float n)
{
    return fract(_sinf(n * 12.9898f) * 43758.5453f);
}

__DEVICE__ float2 rand2(float2 p)
{
  float r = 523.0f*_sinf(dot(p, to_float2(53.3158f, 43.6143f)));
  return to_float2(fract(15.32354f * r), fract(17.25865f * r));
}


//////////////////////////////////////////////////////////////////////////////////////
// main sdf
//////////////////////////////////////////////////////////////////////////////////////

__DEVICE__ float2 map(in float3 pos, float gTime)
{
    float2 res = to_float2( 1.0f, 0.0f );
    #define opMin(_v, _m)    res = (_v < res.x) ? to_float2(_v, _m) : res

    float bottomGround = sdRoundBox(pos + to_float3(0.0f, 0.13f, 0.0f), to_float3(0.6f, 0.05f, 0.6f), 0.05f);
    float topGround = sdRoundBox(pos + to_float3(0.0f, 0.0f, 0.0f), to_float3(0.6f, 0.005f, 0.6f), 0.05f);
    float basePlate = sdRoundBaseBox(pos + to_float3(0.1f, -0.034f, -0.15f), to_float3(0.28f, 0.005f, 0.28f), 0.03f);
    float walls = wallsAndRoof(pos + to_float3(0.1f, -0.20f, -0.15f), to_float3(0.25f, 0.15f, 0.25f), 0.025f);
    float roof = roofTop(pos + to_float3(0.1f, -0.40f, -0.15f), to_float3(0.286f, 0.005f, 0.266f));
    float entrance = sdRoundBox(pos + to_float3(0.02f, -0.15f, 0.125f), to_float3(0.044f, 0.08f, 0.0035f), 0.015f);
    float window = sdRoundBox(pos + to_float3(0.20f, -0.20f, 0.1145f), to_float3(0.033f, 0.033f, 0.0035f), 0.015f);
    float chimney = sdRoundBox(pos + to_float3(0.25f, -0.39f, -0.1f), to_float3(0.03f, 0.035f, 0.03f), 0.015f);
    float chimneyEdge = chimneyEdges(pos);

    float waterCavity = sdEllipsoid(pos - to_float3(-0.425f, 0.01f, -0.49f), to_float3(0.1f, 0.2f, 0.2f));
          waterCavity -= _sinf(20.0f*pos.x)*_sinf(30.0f*pos.y)*_sinf(20.0f*pos.z) * 0.012f;

    bottomGround = fOpDifferenceRound(bottomGround, waterCavity, 0.07f);
    topGround = fOpDifferenceRound(topGround, waterCavity, 0.07f);

    opMin(bottomGround, MAT_GROUNDPLATE);
    opMin(topGround, MAT_GROUNDPLATE_TOP);
    opMin(basePlate, MAT_BASEPLATE);
    opMin(walls, MAT_WALLS);
    opMin(roof, MAT_ROOF);
    opMin(entrance, MAT_ENTRANCE);
    opMin(window, MAT_WINDOW);
    opMin(chimney, MAT_WALLS);
    opMin(chimneyEdge, MAT_ROOF);

    float rock = sdEllipsoid(pos - to_float3(-0.05f, 0.051f, -0.32f), to_float3(0.08f, 0.028f, 0.06f));
    rock = _fminf(rock, sdEllipsoid(pos - to_float3(0.06f, 0.048f, -0.39f), to_float3(0.04f, 0.021f, 0.04f)));
    rock = _fminf(rock, sdEllipsoid(pos - to_float3(-0.04f, 0.049f, -0.45f), to_float3(0.06f, 0.023f, 0.055f)));
    rock = _fminf(rock, sdEllipsoid(pos - to_float3(-0.14f, 0.049f, -0.41f), to_float3(0.04f, 0.023f, 0.065f)));
    rock = _fminf(rock, sdEllipsoid(pos - to_float3( 0.028f, 0.050f, -0.54f), to_float3(0.043f, 0.025f, 0.059f)));
    rock = _fminf(rock, sdEllipsoid(pos - to_float3(-0.074f, 0.049f, -0.585f), to_float3(0.065f, 0.030f, 0.045f)));
    rock += _sinf(15.0f*pos.x)*_sinf(10.0f*pos.y + 15.5f)*_sinf(28.0f*pos.z) * 0.02f;
    opMin(rock, MAT_STONE);

    float3 treePos = pos - to_float3( -0.3f, 0.028f, -0.3f);
    float treeTrunkDist = treeTrunk( treePos );
    opMin(treeTrunkDist, MAT_WOOD);
    float leafsDist = treeLeafs( treePos );
    opMin(leafsDist, MAT_LEAFS);

    float underWater = _fmaxf(res.x , waterCavity - 0.03f );
    res = (underWater < (res.x + 0.0001f)) ? to_float2(underWater, MAT_UNDERWATER) : res;

    float _stellas = stellas(pos, gTime);
    opMin(_stellas, MAT_WINDOW);

    float d, d1;
    d = 10000.0f;
    float3 tempPos = pos + to_float3(0.18f, -0.39f, -0.15f);

    for(int i = 0; i < 20; i++)
  {
        float3 pos1;
        float ltime = gTime*0.09f + (float)(i)*20.134f;

        float r = rand((float)(i)*2.33f);
        float y = 0.08f+mod_f(ltime*(r + 0.5f), 1.0f);

        float r1 = rand((float)(i)*12.33f);
        r1 *= 0.01f;

        pos1 = to_float3(0.010f*mod_f((float)(i), 4.0f) - 0.08f, y, 0.010f*_floor((float)(i)/5.0f) - 0.08f);
        d1 = sdRoundBox(tempPos - pos1, to_float3(0.005f + r1, 0.005f + r1, 0.005f + r1), 0.005f);
        if (d1 < d)
        {
            d = d1;
        }
    }

    opMin(d, MAT_DUST);
    return res;
}


__DEVICE__ float mapWaterVolume(float3 pos, float gTime)
{
    float3 rPosX = rotateX(pos, -1.5707f);

    float baseBox = sdBox( pos - to_float3( -0.42f, -0.09f, -0.155f), to_float3(0.1f,0.10f,0.498f) );
    float wv = baseBox;
    //animate water
#if defined(ANIMATE_WATER) && ANIMATE_WATER
    float3 offset = to_float3(-gTime * 0.04f - 0.02f, 0.0f, gTime * 0.06f + 0.1f);
#else
    float3  offset = to_float3_s(0.1f);
#endif
    wv += (1.0f - clamp((pos.y / -0.15f), 0.0f, 1.0f)) // affect mostly on top of the water surface
        *( 1.0
         * _sinf(-22.0f*(pos.x+offset.x))
         * _sinf(23.0f*(pos.z + offset.z))
         + _sinf(20.0f*(pos.z + offset.z + 12.5f)) * 0.3
         + _cosf(15.0f*(pos.z + 2.1f +offset.x)) * 0.2
         + _cosf(-21.0f*(pos.x+offset.z)) *0.5
         )* 0.011f;
    wv -= 0.004f;
    wv = _fmaxf(wv, sdBox( pos - to_float3( -0.42f, -0.09f, -0.155f), to_float3(0.1f,0.13f,0.498f) ));
    wv -= 0.004f;

    float baseBox2 = sdBox( rPosX - to_float3( -0.415f, 0.63f, -0.45f), to_float3(0.09f,0.02f,0.42f) );
    float wv2 = baseBox2;
    //animate water
#if defined(ANIMATE_WATER) && ANIMATE_WATER
    float3 offset2 = to_float3(-gTime * 0.04f - 0.02f, 0.0f, gTime * 0.06f + 0.1f);
#else
    float3  offset2 = to_float3_s(0.1f);
#endif
    wv2 += (1.0f - clamp((rPosX.y / -0.15f), 0.0f, 1.0f)) // affect mostly on top of the water surface
        *( 1.0
         * _sinf(-22.0f*(rPosX.x+offset2.x))
         * _sinf(23.0f*(rPosX.z + offset2.z))
         + _sinf(20.0f*(rPosX.z + offset2.z + 12.5f)) * 0.3
         + _cosf(15.0f*(rPosX.z + 12.1f +offset2.x)) * 0.2
         + _cosf(-21.0f*(rPosX.x+offset2.z)) *0.5
         )* 0.011f;
    wv2 -= 0.004f;
    wv2 = _fmaxf(wv2, sdBox( rPosX - to_float3( -0.415f, 0.63f, -0.45f), to_float3(0.09f,0.02f,0.42f) ));
    wv2 -= 0.004f;

    return _fminf(wv,wv2);
}



//////////////////////////////////////////////////////////////////////////////////////
// raymarching softshadows (https://iquilezles.org/articles/rmshadows)
//////////////////////////////////////////////////////////////////////////////////////

__DEVICE__ float calcSoftshadow( in float3 ro, in float3 rd, in float tmin, in float tmax, float gTime )
{
    // bounding volume
    //float tp = (maxHei-ro.y)/rd.y; if( tp>0.0f ) tmax = _fminf( tmax, tp );

    float res = 1.0f;
    float t = tmin;
    for( int i=ZERO; i<22; i++ )
    {
    float h = map( ro + rd*t, gTime ).x;
        float s = clamp(8.0f*h/t,0.0f,1.0f);
        res = _fminf( res, s*s*(3.0f-2.0f*s) );
        t += clamp( h, 0.02f, 0.10f );
        if( res<0.005f || t>tmax ) break;
    }
    return clamp( res, 0.0f, 1.0f );
}


//////////////////////////////////////////////////////////////////////////////////////
// https://iquilezles.org/articles/normalsSDF
//////////////////////////////////////////////////////////////////////////////////////

__DEVICE__ float3 calcNormal( in float3 pos, float gTime )
{
#if 0
    float2 e = to_float2(1.0f,-1.0f)*0.5773f*0.0005f;
    return normalize( swi3(e,x,y,y)*map( pos + swi3(e,x,y,y), gTime).x +
                      swi3(e,y,y,x)*map( pos + swi3(e,y,y,x), gTime).x +
                      swi3(e,y,x,y)*map( pos + swi3(e,y,x,y), gTime).x +
                      swi3(e,x,x,x)*map( pos + swi3(e,x,x,x), gTime).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    float3 n = to_float3_s(0.0f);
    for( int i=ZERO; i<4; i++ )
    {
        float3 e = 0.5773f*(2.0f*to_float3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0f);
        n += e*map(pos+0.0005f*e, gTime).x;
    }
    return normalize(n);
#endif
}

__DEVICE__ float3 calcNormalWater( in float3 pos, float gTime )
{
    float3 n = to_float3_s(0.0f);
    for( int i=ZERO; i<4; i++ )
    {
        float3 e = 0.5773f*(2.0f*to_float3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0f);
        n += e*mapWaterVolume(pos+0.0005f*e, gTime);
    }
    return normalize(n);
}

__DEVICE__ float calcAO( in float3 pos, in float3 nor, float gTime )
{
    float occ = 0.0f;
    float sca = 1.00f;
    for( int i=ZERO; i<5; i++ )
    {
        float hr = 0.01f + 0.12f*(float)(i)/4.0f;
        float3 aopos =  nor * hr + pos;
        float dd = map( aopos, gTime ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95f;
    }
    return clamp( 1.0f - 3.0f*occ, 0.0f, 1.0f ) * (0.5f+0.5f*nor.y);
}

__DEVICE__ float3 calcSkyColor(float3 aDirection, float3 SkyColor[2])
{
    float t = smoothstep(0.1f, 0.6f, 0.7f*(aDirection.y + 1.0f));
    return _mix(to_float3(1.0f, 1.0f, 0.2f)+SkyColor[0], to_float3(0.1f, 0.1f, 1.0f)+SkyColor[1], t);
    //return _mix(SkyColor[0], SkyColor[1], t);
}

__DEVICE__ float4 calcColor(int matId, float3 pos, float3 normal, float diffuse, float fresnel, float3 Colors[14])
{
    float4 FinalColor = to_float4(0.1f, 0.1f, 0.1f, 1) * diffuse;
    if(matId == MAT_WOOD)
    {
        float3 WoodBrown = to_float3(0.287f, 0.11882f, 0.04f) * 1.5f;
        float3 WoodBrownShadow = to_float3(0.1847f, 0.0482f, 0.016f) * 1.2f;
        swi3S(FinalColor,x,y,z, _mix(WoodBrownShadow, WoodBrown, diffuse));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + WoodBrown * fresnel * 2.0f);
    }
    else if(matId == MAT_LEAFS)
    {
        float3 Leafs = to_float3(0.0882f, 0.447f, 0.04f) + Colors[0];
        float3 LeafsShadow = to_float3(0.00582f, 0.247f, 0.02f) + Colors[0];
        swi3S(FinalColor,x,y,z, _mix(LeafsShadow, Leafs, diffuse) * 0.7f);
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + Leafs * fresnel * 2.5f);
    }
    else if(matId == MAT_STONE)
    {
        float3 Stone = to_float3(0.4f, 0.4f, 0.4f);
        float3 StoneShadow = to_float3(0.2f, 0.2f, 0.3f);
        swi3S(FinalColor,x,y,z, _mix(StoneShadow, Stone, diffuse));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + Stone * fresnel * 0.5f);
    }
    else if(matId == MAT_GROUNDPLATE)
    {
        float3 g = to_float3(0.929f,0.733f,0.063f) + Colors[1];
        float3 g1 = to_float3(0.90f, 0.733f,0.063f)  + Colors[1];
        swi3S(FinalColor,x,y,z, _mix(g1, g, diffuse));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + (to_float3(0.929f,0.411f,0.033f) + Colors[1]) * fresnel * 0.8f);
    }
    else if(matId == MAT_GROUNDPLATE_TOP)
    {
        swi3S(FinalColor,x,y,z, _mix( to_float3(0.9f, 0.8f, 0.04f) + Colors[2], to_float3(1.0f, 0.9f, 0.04f) + Colors[2], diffuse));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + (to_float3(0.95f,0.85f,0.033f) + Colors[0]) * fresnel * 1.1f);
    }
    else if(matId == MAT_BASEPLATE)
    {
        swi3S(FinalColor,x,y,z, _mix( to_float3(0.418f,0.598f,0.608f) + Colors[3], to_float3(0.758f,0.708f,0.608f) + Colors[3], diffuse));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + (to_float3(0.418f,0.598f,0.608f) + Colors[3]) * fresnel * 0.9f);
    }
    else if(matId == MAT_WALLS)
    {
        swi3S(FinalColor,x,y,z, _mix( to_float3(0.818f,0.098f,0.628f) + Colors[4], to_float3(0.858f,0.908f,0.758f) + Colors[4], diffuse));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + (to_float3(0.818f,0.898f,0.808f) + Colors[4]) * fresnel * 0.9f);
    }
    else if(matId == MAT_ROOF)
    {
        swi3S(FinalColor,x,y,z, _mix( to_float3(2.996f,0.0f,0.296f) + Colors[5], to_float3(3.996f,0.0f,0.286f) + Colors[5], diffuse * 0.5f));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + (to_float3(2.996f,0.0f,0.296f) + Colors[5]) * fresnel * 0.5f);
    }
    else if(matId == MAT_ENTRANCE)
    {
        swi3S(FinalColor,x,y,z, _mix( to_float3(0.459f,0.263f,0.157f) + Colors[6], to_float3(0.459f,0.463f,0.057f) + Colors[6],  diffuse * 0.3f));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + (to_float3(0.459f,0.263f,0.157f) + Colors[6]) * fresnel * 2.5f);
    }
    else if(matId == MAT_WINDOW)
    {
        swi3S(FinalColor,x,y,z, _mix( to_float3(0.818f,0.198f,0.108f) + Colors[7], to_float3(0.758f,0.708f,0.608f) + Colors[7], diffuse));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + (to_float3(0.459f,0.263f,0.157f) + Colors[7]) * fresnel * 2.5f);
    }
    else if(matId == MAT_DUST)
    {
        swi3S(FinalColor,x,y,z, _mix( to_float3(0.980f, 0.980f, 0.980f) + Colors[8], to_float3(1.980f,1.980f,1.980f) + Colors[8], diffuse));
        swi3S(FinalColor,x,y,z, swi3(FinalColor,x,y,z) + (to_float3(1.880f,1.880f,1.880f) + Colors[8]) * fresnel * 0.5f);
    }
    else if(matId == MAT_UNDERWATER)
    {
        float3 Sand = to_float3(0.447f, 0.447f, 0.04f) + Colors[9];
        float3 SandShadow = to_float3(0.347f, 0.247f, 0.02f)  + Colors[9];
        swi3S(FinalColor,x,y,z, _mix(SandShadow, Sand, diffuse));
    }

    return FinalColor;
}

__DEVICE__ float3 castRay(float3 ro, float3 rd, float gTime)
{
    float3 res = to_float3(0.0f, 1e10, 0.0f);
    float tmin = 1.0f;
    float tmax = 20.0f;
    float t = tmin;
    for( int i=0; i<120 && t<tmax; i++ )
    {
        float2 h = map( ro+rd*t, gTime );
        if( _fabs(h.x)<(0.0001f*t) )
        {
            res = to_float3(t, h.x, h.y);
            return res;
        }
        t += h.x;
    }

    return res;
}

__DEVICE__ float4 applyWaterVolume(float3 ro, float3 rd, float depth, float4 color, float gTime, float3 WaterColor)
{
    float tmin = 1.0f;
    float tmax = 20.0f;
    float t = tmin;
    float hit = 0.0f;
    float h = 0.0f;
    float distInsideWater = 0.0f;
    for( int i=0; i<70 && t<tmax; i++ )
    {
        h = mapWaterVolume( ro+rd*t, gTime );
        if( _fabs(h)<(0.0001f*t) )
        {
            distInsideWater += h;
            hit = 1.0f;
            break;
        }
        else if(hit > 0.0f)
        {
            break;
        }
        t += h;
        if(depth > 0.0f && ((t + 0.0011f) > depth))
        {
            break;
        }
    }

    depth = (depth > 0.0f) ? depth : t*2.5f;

    float4 WaterBlue = to_float4(0.1f, 0.4f, 1.0f, color.w) + to_float4_aw(WaterColor,1.0f);

    float3 pos = ro + rd * t;
    float3 lightDir = normalize( to_float3(-0.5f, 1.1f, 0.9f) );
    float shadow = calcSoftshadow( pos, lightDir, 0.02f, 2.5f, gTime );
    float3 normal = calcNormalWater(pos, gTime);
    float NdL = clamp( dot( normal, lightDir ), 0.0f, 1.0f );
    float3  hal = normalize( lightDir-rd );
    float spe = _powf( clamp( dot( normal, hal ), 0.0f, 1.0f),40.0f)
                    //*_mix(0.5f, 1.0f, NdL* shadow)  //shadow
                    //*(0.04f + 2.5f*_powf( clamp(1.0f+dot(hal, rd),0.0f,1.0f), 1.0f ));
                    ;
    spe = smoothstep(0.5f, 0.9f, spe);
    //light affecting water
    WaterBlue = _mix(WaterBlue * 0.5f, WaterBlue, NdL * shadow);

    //all inside water is bluiedish
    color = _mix(color, WaterBlue * 0.8f + color * WaterBlue * 0.5f, hit * 0.3f);

    //distance to closest point
    float nearest = clamp(map(pos, gTime).x, 0.0f, 1.0f);
    color = _mix(color, WaterBlue, clamp(_powf(nearest * hit, 1.3f) * 5.0f, 0.0f, 1.0f));

    //distance to center of the diorama hack
    color = _mix(color, WaterBlue , clamp(_powf(length(pos) * hit, 2.0f) * 1.2f, 0.0f, 1.0f));
    //color = _mix(color, WaterBlue * 0.5f, ((t / depth)) * hit * 0.7f);
    //return to_float4(_mix(swi3(color,x,y,z), normal * 0.5f + 0.5f, hit), 1.0f);

#define WATER_OPACITY_INIT 0.3f
#define WATER_OPACITY_COEFF 2.5f

    float fresnel = _powf( clamp(1.0f+dot(normal,rd),0.0f,1.0f), 2.4f );
    swi3S(color,x,y,z, swi3(color,x,y,z) + hit*2.00f*spe*to_float3_s(1.0f));
    color += _mix(to_float4_s(0.0f), fresnel*color*3.0f, hit * _mix(0.2f, 1.0f, shadow));
    return color;
}

__DEVICE__ float4 render( float2 uv, in float3 ro, in float3 rd, in float3 rdx, in float3 rdy, float gTime, float3 Colors[14], float3 SkyColor[2], float3 WaterColor )
{
    float4 finalColor = to_float4_aw(calcSkyColor(rd, SkyColor), 0.0f);
    float3 res = castRay(ro,rd, gTime);

    if(res.y < 0.002f)
    {
        float3 lightDir = normalize( to_float3(-0.5f, 1.1f, -0.6f) );
        float3 pos = ro + rd * res.x;
        float3 normal = calcNormal(pos, gTime);

        float ao = calcAO(pos, normal, gTime);
        float shadow = calcSoftshadow( pos, lightDir, 0.02f, 2.5f, gTime );
        float NdL = clamp( dot( normal, lightDir ), 0.0f, 1.0f );
        float fresnel = _powf( clamp(1.0f+dot(normal,rd),0.0f,1.0f), 2.4f );

        float diffuse  = shadow * NdL * 12.0f;

        float4 color = calcColor((int)(res.z), pos, normal, diffuse, fresnel, Colors) * _mix(0.22f, 1.0f, ao);
        finalColor = to_float4_aw(swi3(color,x,y,z), res.x);
        swi3S(finalColor,x,y,z, swi3(finalColor,x,y,z) * 0.4f + 0.6f * swi3(finalColor,x,y,z) * calcSkyColor(normal, SkyColor));
    }

    finalColor = applyWaterVolume(ro, rd, res.x, finalColor, gTime, WaterColor);
    return finalColor;
}

// ----------------------------------------------------------------------------------
// - Buffer A                                                                       -
// ----------------------------------------------------------------------------------


//////////////////////////////////////////////////////////////////////////////////////
// main raymarching
//////////////////////////////////////////////////////////////////////////////////////

__DEVICE__ mat3 setCamera( in float3 ro, in float3 ta, float cr )
{
  float3 cw = normalize(ta-ro);
  float3 cp = to_float3(_sinf(cr), _cosf(cr),0.0f);
  float3 cu = normalize( cross(cw,cp) );
  float3 cv =          ( cross(cu,cw) );
  return to_mat3_f3( cu, cv, cw );
}

__KERNEL__ void TinyHideoutFuse__Buffer_A(__CONSTANTREF__ Params*  params, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  float4 ColLeafs = to_float4(params->ColLeafs[0], params->ColLeafs[1], params->ColLeafs[2], params->ColLeafs[3]);
  float4 ColGround = to_float4(params->ColGround[0], params->ColGround[1], params->ColGround[2], params->ColGround[3]);
  float4 ColGroundTOP = to_float4(params->ColGroundTOP[0], params->ColGroundTOP[1], params->ColGroundTOP[2], params->ColGroundTOP[3]);
  float4 ColPlate = to_float4(params->ColPlate[0], params->ColPlate[1], params->ColPlate[2], params->ColPlate[3]);
  float4 ColWalls = to_float4(params->ColWalls[0], params->ColWalls[1], params->ColWalls[2], params->ColWalls[3]);
  float4 ColRoof = to_float4(params->ColRoof[0], params->ColRoof[1], params->ColRoof[2], params->ColRoof[3]);
  float4 ColEntrance = to_float4(params->ColEntrance[0], params->ColEntrance[1], params->ColEntrance[2], params->ColEntrance[3]);
  float4 ColWindow = to_float4(params->ColWindow[0], params->ColWindow[1], params->ColWindow[2], params->ColWindow[3]);
  float4 ColDust = to_float4(params->ColDust[0], params->ColDust[1], params->ColDust[2], params->ColDust[3]);
  float4 ColSand = to_float4(params->ColSand[0], params->ColSand[1], params->ColSand[2], params->ColSand[3]);
  float4 ColSky1 = to_float4(params->ColSky1[0], params->ColSky1[1], params->ColSky1[2], params->ColSky1[3]);
  float4 ColSky2 = to_float4(params->ColSky2[0], params->ColSky2[1], params->ColSky2[2], params->ColSky2[3]);
  float4 ColWater = to_float4(params->ColWater[0], params->ColWater[1], params->ColWater[2], params->ColWater[3]);
  float  BLOOM_SIZE = params->BLOOM_SIZE;
  float  BLOOM_THRESHOLD = params->BLOOM_THRESHOLD;
  float  BLOOM_RANGE = params->BLOOM_RANGE;
  float  BLOOM_FRAME_BLEND = params->BLOOM_FRAME_BLEND;
  // --------

    float3 Colors[14] = {swi3(ColLeafs,x,y,z)-0.5f, swi3(ColGround,x,y,z)-0.5f, swi3(ColGroundTOP,x,y,z)-0.5f, swi3(ColPlate,x,y,z)-0.5f, swi3(ColWalls,x,y,z)-0.5f,
                         swi3(ColRoof,x,y,z)-0.5f, swi3(ColEntrance,x,y,z)-0.5f, swi3(ColWindow,x,y,z)-0.5f, swi3(ColDust,x,y,z)-0.5f, swi3(ColSand,x,y,z)-0.5f};

    float3 SkyColor[2] = {swi3(ColSky1,x,y,z)-0.5f, swi3(ColSky2,x,y,z)-0.5f};

    fragCoord+=0.5f;

    float gTime = (iTime);
    float2 mo = swi2(iMouse,x,y)/iResolution;
    //mo.y += 0.2f;
    float time = 23.5f + iTime*1.5f;
    //float time = 23.5f;

    // camera
    float3 ro = to_float3( 4.6f*_cosf(0.1f*time + 12.0f*mo.x),  1.2f + 3.0f*mo.y, 4.6f*_sinf(0.1f*time + 12.0f*mo.x) );
    float3 ta = to_float3( 0.0f, 0.14f, 0.0f );
    // camera-to-world transformation
    mat3 ca = setCamera( ro, ta, 0.0f );

    float2 p = (-iResolution + 2.0f*fragCoord)/iResolution.y;

    // ray direction
    float3 rd = mul_mat3_f3(ca , normalize( to_float3_aw(p,6.0f) ));

     // ray differentials (NOT USED YET)
    float2 px = (-iResolution+2.0f*(fragCoord+to_float2(1.0f,0.0f)))/iResolution.y;
    float2 py = (-iResolution+2.0f*(fragCoord+to_float2(0.0f,1.0f)))/iResolution.y;
    float3 rdx = mul_mat3_f3(ca , normalize( to_float3_aw(px,2.0f) ));
    float3 rdy = mul_mat3_f3(ca , normalize( to_float3_aw(py,2.0f) ));

    // render
    float4 col = render( p, ro, rd, rdx, rdy, gTime, Colors, SkyColor, swi3(ColWater,x,y,z)-0.5f );

    fragColor = col;

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
// ----------------------------------------------------------------------------------
// - Buffer B                                                                       -
// ----------------------------------------------------------------------------------
// Connect Buffer B 'Previsualization: Buffer B' to iChannel0
// Connect Buffer B 'Previsualization: Buffer A' to iChannel1



//////////////////////////////////////////////////////////////////////////////////////
// pyramid bloom (https://www.shadertoy.com/view/lsBfRc)
//////////////////////////////////////////////////////////////////////////////////////

__DEVICE__ float3 makeBloom(float lod, float2 offset, float2 bCoord, float2 aPixelSize, float BLOOM_THRESHOLD, float BLOOM_SIZE, __TEXTURE2D__ iChannel1)
{
  
    int RowSampler = 15; // Total irre !!! Tausend Shader, die liefen ohne diese Zeile mit OpenCL. Dieser Shader braucht aber genau dies nur für OpenCL -> Total irre !!!
  
    offset += aPixelSize;

    float lodFactor = _exp2f(lod);

    float3 bloom = to_float3_s(0.0f);
    float2 scale = lodFactor * aPixelSize;

    float2 coord = (swi2(bCoord,x,y)-offset)*lodFactor;
    float totalWeight = 0.0f;

    //if (any(greaterThanEqual(_fabs(coord - 0.5f), scale + 0.5f)))
    if ((_fabs(coord.x - 0.5f) >= scale.x + 0.5f) || (_fabs(coord.y - 0.5f) >= scale.y + 0.5f))
        return to_float3_s(0.0f);

    for (int i = -3; i < 3; i++)
    {
        for (int j = -3; j < 3; j++)
        {
            float wg = _powf(1.0f-length(to_float2(i,j)) * 0.125f, 6.0f); //* 0.125f, 6.0
            float3 lTextureColor = swi3(texture(iChannel1, to_float2(i,j) * scale + lodFactor * aPixelSize + coord),x,y,z); //lod
            //lTextureColor = (any(greaterThan(lTextureColor, to_float3_aw(BLOOM_THRESHOLD)))) ? lTextureColor * BLOOM_SIZE : to_float3_s(0.0f);
            lTextureColor = (lTextureColor.x > BLOOM_THRESHOLD)||(lTextureColor.y > BLOOM_THRESHOLD)||(lTextureColor.z > BLOOM_THRESHOLD) ? lTextureColor * BLOOM_SIZE : to_float3_s(0.0f);
            lTextureColor = pow_f3(lTextureColor, to_float3_s(2.2f)) * wg;
            bloom = lTextureColor + bloom;

            totalWeight += wg;
        }
    }
    bloom /= totalWeight;
    return bloom;
}

__KERNEL__ void TinyHideoutFuse__Buffer_B(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0,  __TEXTURE2D__ iChannel1, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  float4 ColLeafs = to_float4(params->ColLeafs[0], params->ColLeafs[1], params->ColLeafs[2], params->ColLeafs[3]);
  float4 ColGround = to_float4(params->ColGround[0], params->ColGround[1], params->ColGround[2], params->ColGround[3]);
  float4 ColGroundTOP = to_float4(params->ColGroundTOP[0], params->ColGroundTOP[1], params->ColGroundTOP[2], params->ColGroundTOP[3]);
  float4 ColPlate = to_float4(params->ColPlate[0], params->ColPlate[1], params->ColPlate[2], params->ColPlate[3]);
  float4 ColWalls = to_float4(params->ColWalls[0], params->ColWalls[1], params->ColWalls[2], params->ColWalls[3]);
  float4 ColRoof = to_float4(params->ColRoof[0], params->ColRoof[1], params->ColRoof[2], params->ColRoof[3]);
  float4 ColEntrance = to_float4(params->ColEntrance[0], params->ColEntrance[1], params->ColEntrance[2], params->ColEntrance[3]);
  float4 ColWindow = to_float4(params->ColWindow[0], params->ColWindow[1], params->ColWindow[2], params->ColWindow[3]);
  float4 ColDust = to_float4(params->ColDust[0], params->ColDust[1], params->ColDust[2], params->ColDust[3]);
  float4 ColSand = to_float4(params->ColSand[0], params->ColSand[1], params->ColSand[2], params->ColSand[3]);
  float4 ColSky1 = to_float4(params->ColSky1[0], params->ColSky1[1], params->ColSky1[2], params->ColSky1[3]);
  float4 ColSky2 = to_float4(params->ColSky2[0], params->ColSky2[1], params->ColSky2[2], params->ColSky2[3]);
  float4 ColWater = to_float4(params->ColWater[0], params->ColWater[1], params->ColWater[2], params->ColWater[3]);
  float  BLOOM_SIZE = params->BLOOM_SIZE;
  float  BLOOM_THRESHOLD = params->BLOOM_THRESHOLD;
  float  BLOOM_RANGE = params->BLOOM_RANGE;
  float  BLOOM_FRAME_BLEND = params->BLOOM_FRAME_BLEND;
  // --------

    fragCoord+=0.5f;

    int RowSampler = 15; // Total irre !!! Tausend Shader, die liefen ohne diese Zeile mit OpenCL. Dieser Shader braucht aber genau dies nur für OpenCL -> Total irre !!!     

    float2 uv = fragCoord / iResolution;
    float2 pixelSize = 1.0f / iResolution;
    float4 lInputColor0 = _tex2DVecN(iChannel0,uv.x,uv.y,15);

    float3 lBlur  = makeBloom(2.0f, to_float2(0.0f, 0.0f), uv, pixelSize, BLOOM_THRESHOLD, BLOOM_SIZE, iChannel1);
           lBlur += makeBloom(3.0f, to_float2(0.3f, 0.0f), uv, pixelSize, BLOOM_THRESHOLD, BLOOM_SIZE, iChannel1);
           lBlur += makeBloom(4.0f, to_float2(0.0f, 0.3f), uv, pixelSize, BLOOM_THRESHOLD, BLOOM_SIZE, iChannel1);
           lBlur += makeBloom(5.0f, to_float2(0.1f, 0.3f), uv, pixelSize, BLOOM_THRESHOLD, BLOOM_SIZE, iChannel1);
           lBlur += makeBloom(6.0f, to_float2(0.2f, 0.3f), uv, pixelSize, BLOOM_THRESHOLD, BLOOM_SIZE, iChannel1);

        float4 lOutputColor = to_float4_aw(clamp(pow_f3(lBlur, to_float3_s(1.0f / 2.2f)), to_float3_s(0), to_float3_s(100)), 1.0f);
        fragColor = _mix(lInputColor0, lOutputColor, BLOOM_FRAME_BLEND);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
// ----------------------------------------------------------------------------------
// - Image                                                                          -
// ----------------------------------------------------------------------------------
// Connect Image 'Previsualization: Buffer A' to iChannel0
// Connect Image 'Previsualization: Buffer B' to iChannel1

//
//
// Tiny Hideout
//
// Short before upcoming xmas I decided to start a little diorama-series as practise and finger exercise.
// The reference I used for the cabin is pretty naive -> (https://dasprinzip.com/tinker/cabin.png), but
// fits well for my purpose, of working it all out in here.
//
// More to come the next weeks...
//
//
//
// This shader shall exist in its/this form on shadertoy.com only
// You shall not use this shader in any commercial or non-commercial product, website or project.
// This shader is not for sale nor can´t be minted (ecofriendly or not) as NFT.
//
//
//
// Related examples
//
// Athibaul´s distress flares:
// https://www.shadertoy.com/view/3dGyRc
//
// gaz´s night circuit
// https://www.shadertoy.com/view/tdyBR1
//
// // Gallo´s green field:
// https://www.shadertoy.com/view/7dSGW1
//
// IQ´s article for sure
// https://iquilezles.org/articles/distfunctions/
//
//
//


__DEVICE__ float noise(float x, __TEXTURE2D__ iChannel0)
{
    int RowSampler = 15; // Total irre !!! Tausend Shader, die liefen ohne diese Zeile mit OpenCL. Dieser Shader braucht aber genau dies nur für OpenCL -> Total irre !!!
  
    return 2.0f*texture(iChannel0, to_float2(x+0.5f,0)/256.0f).x-1.0f;
}

__DEVICE__ float fbm1D(float x, __TEXTURE2D__ iChannel0)
{
    return noise(x,iChannel0)*0.5f + noise(2.0f*x, iChannel0)*0.25f + noise(4.0f*x, iChannel0)*0.125f;
}

__DEVICE__ float intensityAtTime(float t, __TEXTURE2D__ iChannel0)
{
    return fbm1D(t*3.0f, iChannel0)*0.5f + 0.5f;
}

__DEVICE__ float ligIntensity(float t, __TEXTURE2D__ iChannel0)
{
    return _expf(6.0f*(intensityAtTime(t, iChannel0)-0.5f));
}


#define reflect_f2(I,N) (I-2.0f*dot(N,I)*N)

__DEVICE__ float3 flareColor(float2 p, float time, float dmin, float3 flareCol, __TEXTURE2D__ iChannel0)
{
    // Hexagonal shape
    float2 q = abs_f2(p);
    float2 n = to_float2(-_sqrtf(3.0f)/2.0f, 0.5f);
    q = dot(q,n) > 0.0f ? reflect_f2(q,n) : q;
    float d = dot(q,n*to_float2(-1,1));
    float intensity = ligIntensity(time, iChannel0) / (1.0f+_fabs(p.y));
    return flareCol * _powf(d+dmin, -2.0f) * 0.005f * intensity;
}

__DEVICE__ float3 bokeh(float2 p, float t, float smoo, float3 flareCol, __TEXTURE2D__ iChannel0)
{
    float bok = smoothstep(0.5f+smoo,0.5f-smoo,length(p))
        * (0.5f+smoothstep(0.0f,0.5f, length(p)));
    return bok * 0.01f * flareCol * ligIntensity(t, iChannel0);
}

__DEVICE__ float3 bokeh2(float2 p, float t, float smoo, float3 flareCol, __TEXTURE2D__ iChannel0)
{
    float bok = smoothstep(0.5f+smoo,0.5f-smoo,length(p));
    return bok * 0.01f * flareCol * ligIntensity(t, iChannel0);
}

__DEVICE__ float3 aces_tonemap(float3 color){
  mat3 m1 = to_mat3(
        0.59719f, 0.07600f, 0.02840f,
        0.35458f, 0.90834f, 0.13383f,
        0.04823f, 0.01566f, 0.83777
  );
  mat3 m2 = to_mat3(
        1.60475f, -0.10208f, -0.00327f,
        -0.53108f,  1.10813f, -0.07276f,
        -0.07367f, -0.00605f,  1.07602
  );
  float3 v = mul_mat3_f3(m1 , color);
  float3 a = v * (v + 0.0245786f) - 0.000090537f;
  float3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;
  return pow_f3(clamp(mul_mat3_f3(m2 , (a / b)), 0.0f, 1.0f), to_float3_s(1.0f / 2.2f));
}

__DEVICE__ float3 bloomTile(float lod, float2 offset, float2 uv, __TEXTURE2D__ iChannel1)
{
    int RowSampler = 15; // Total irre !!! Tausend Shader, die liefen ohne diese Zeile mit OpenCL. Dieser Shader braucht aber genau dies nur für OpenCL -> Total irre !!!
    return swi3(texture(iChannel1, uv * _exp2f(-lod) + offset),x,y,z);
}

__DEVICE__ float3 getBloom(float2 uv, float BLOOM_RANGE, __TEXTURE2D__ iChannel1)
{
    float3 blur = to_float3_s(0.0f);
    float2 lOffsetFix = to_float2(0.00025f, 0.0005f);
    blur = pow_f3(bloomTile(2.0f, to_float2(0.0f, 0.0f) + lOffsetFix, uv, iChannel1),to_float3_s(2.2f))               + blur;
    blur = pow_f3(bloomTile(3.0f, to_float2(0.3f, 0.0f) + lOffsetFix, uv, iChannel1),to_float3_s(2.2f)) * 1.3f        + blur;
    blur = pow_f3(bloomTile(4.0f, to_float2(0.0f, 0.3f) + lOffsetFix, uv, iChannel1),to_float3_s(2.2f)) * 1.6f        + blur;
    blur = pow_f3(bloomTile(5.0f, to_float2(0.1f, 0.3f) + lOffsetFix, uv, iChannel1),to_float3_s(2.2f)) * 1.9f        + blur;
    blur = pow_f3(bloomTile(6.0f, to_float2(0.2f, 0.3f) + lOffsetFix, uv, iChannel1),to_float3_s(2.2f)) * 2.2f        + blur;

    return blur * BLOOM_RANGE;
}

__KERNEL__ void TinyHideoutFuse(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0,  __TEXTURE2D__ iChannel1, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  float4 ColLeafs = to_float4(params->ColLeafs[0], params->ColLeafs[1], params->ColLeafs[2], params->ColLeafs[3]);
  float4 ColGround = to_float4(params->ColGround[0], params->ColGround[1], params->ColGround[2], params->ColGround[3]);
  float4 ColGroundTOP = to_float4(params->ColGroundTOP[0], params->ColGroundTOP[1], params->ColGroundTOP[2], params->ColGroundTOP[3]);
  float4 ColPlate = to_float4(params->ColPlate[0], params->ColPlate[1], params->ColPlate[2], params->ColPlate[3]);
  float4 ColWalls = to_float4(params->ColWalls[0], params->ColWalls[1], params->ColWalls[2], params->ColWalls[3]);
  float4 ColRoof = to_float4(params->ColRoof[0], params->ColRoof[1], params->ColRoof[2], params->ColRoof[3]);
  float4 ColEntrance = to_float4(params->ColEntrance[0], params->ColEntrance[1], params->ColEntrance[2], params->ColEntrance[3]);
  float4 ColWindow = to_float4(params->ColWindow[0], params->ColWindow[1], params->ColWindow[2], params->ColWindow[3]);
  float4 ColDust = to_float4(params->ColDust[0], params->ColDust[1], params->ColDust[2], params->ColDust[3]);
  float4 ColSand = to_float4(params->ColSand[0], params->ColSand[1], params->ColSand[2], params->ColSand[3]);
  float4 ColSky1 = to_float4(params->ColSky1[0], params->ColSky1[1], params->ColSky1[2], params->ColSky1[3]);
  float4 ColSky2 = to_float4(params->ColSky2[0], params->ColSky2[1], params->ColSky2[2], params->ColSky2[3]);
  float4 ColWater = to_float4(params->ColWater[0], params->ColWater[1], params->ColWater[2], params->ColWater[3]);
  float  BLOOM_SIZE = params->BLOOM_SIZE;
  float  BLOOM_THRESHOLD = params->BLOOM_THRESHOLD;
  float  BLOOM_RANGE = params->BLOOM_RANGE;
  float  BLOOM_FRAME_BLEND = params->BLOOM_FRAME_BLEND;
  // --------

    int RowSampler = 15; // Total irre !!! Tausend Shader, die liefen ohne diese Zeile mit OpenCL. Dieser Shader braucht aber genau dies nur für OpenCL -> Total irre !!!

    float3 flareCol = to_float3(0.15f, 1.0f, 0.4f);

    float2 uv = fragCoord/iResolution;

    float2 p = (fragCoord*1.5f-iResolution)/iResolution.y;
    p.y -= 0.35f;
    p.x -= 0.45f;
    float camTime = iTime;
    float time = iTime;
    float2 q = p + to_float2(fbm1D(camTime+50.0f, iChannel0), fbm1D(camTime+20.0f, iChannel0))*0.1f - to_float2(0.7f,0.1f);

    float4 col = _tex2DVecN(iChannel0,uv.x,uv.y,15);
    //swi3(col,x,y,z) += _powf(getBloom(uv), to_float3_s(2.2f));
    swi3S(col,x,y,z, swi3(col,x,y,z) + getBloom(uv, BLOOM_RANGE, iChannel1));
    swi3S(col,x,y,z, aces_tonemap(swi3(col,x,y,z)));

    swi3S(col,x,y,z, swi3(col,x,y,z) + flareColor(1.2f*p-q, time, 0.1f, flareCol, iChannel0) * 0.15f);
    swi3S(col,x,y,z, swi3(col,x,y,z) + bokeh(2.0f*p-q + 0.34f, time, 0.05f, flareCol, iChannel0) * 0.5f);
    swi3S(col,x,y,z, swi3(col,x,y,z) + bokeh2(3.0f*(4.0f*p-q + 0.44f), time, 0.2f, flareCol, iChannel0) * 0.5f);
    swi3S(col,x,y,z, swi3(col,x,y,z) + bokeh2(3.0f*(p-2.0f*q), time, 0.2f, flareCol, iChannel0) * 0.5f);
    swi3S(col,x,y,z, swi3(col,x,y,z) + bokeh2(5.0f*(3.0f*p-2.0f*q + 0.54f), time, 0.1f, flareCol, iChannel0) * 0.3f);
    swi3S(col,x,y,z, swi3(col,x,y,z) + bokeh2(5.0f*(q+p), time, 0.2f, flareCol, iChannel0) * 0.5f);
    swi3S(col,x,y,z, swi3(col,x,y,z) + flareColor(5.0f*(p+0.53f*q), time, 0.2f, flareCol, iChannel0)*0.5f);

    fragColor = to_float4_aw(swi3(col,x,y,z), 1.0f);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
]]
-- /*



-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ShaderFuse.begin_create()

  ----- Inspector Panel Controls

  
  -- Speed Slider
  
  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",
  })
  
  -- iMouse Controls
  
  InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
  })
  
  InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
    INP_Disabled = true,
  })
  
  InMouseDrag = self:AddInput("Mouse Button Pressed", "iMouseClick", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = false,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0,
  })

  self:BeginControlNest("Colors", "Colors", false, {})
  self:BeginControlNest("ColLeafs", "ColLeafs", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColLeafs",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColLeafsColorR = self:AddInput("Red",   "ColLeafsRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColLeafsColorG = self:AddInput("Green", "ColLeafsGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColLeafsColorB = self:AddInput("Blue",  "ColLeafsBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColLeafsColorA = self:AddInput("Alpha", "ColLeafsAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColGround", "ColGround", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColGround",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColGroundColorR = self:AddInput("Red",   "ColGroundRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColGroundColorG = self:AddInput("Green", "ColGroundGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColGroundColorB = self:AddInput("Blue",  "ColGroundBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColGroundColorA = self:AddInput("Alpha", "ColGroundAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColGroundTOP", "ColGroundTOP", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColGroundTOP",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColGroundTOPColorR = self:AddInput("Red",   "ColGroundTOPRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColGroundTOPColorG = self:AddInput("Green", "ColGroundTOPGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColGroundTOPColorB = self:AddInput("Blue",  "ColGroundTOPBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColGroundTOPColorA = self:AddInput("Alpha", "ColGroundTOPAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColPlate", "ColPlate", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColPlate",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColPlateColorR = self:AddInput("Red",   "ColPlateRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColPlateColorG = self:AddInput("Green", "ColPlateGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColPlateColorB = self:AddInput("Blue",  "ColPlateBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColPlateColorA = self:AddInput("Alpha", "ColPlateAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColWalls", "ColWalls", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColWalls",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColWallsColorR = self:AddInput("Red",   "ColWallsRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColWallsColorG = self:AddInput("Green", "ColWallsGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColWallsColorB = self:AddInput("Blue",  "ColWallsBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColWallsColorA = self:AddInput("Alpha", "ColWallsAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColRoof", "ColRoof", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColRoof",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColRoofColorR = self:AddInput("Red",   "ColRoofRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColRoofColorG = self:AddInput("Green", "ColRoofGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColRoofColorB = self:AddInput("Blue",  "ColRoofBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColRoofColorA = self:AddInput("Alpha", "ColRoofAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColEntrance", "ColEntrance", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColEntrance",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColEntranceColorR = self:AddInput("Red",   "ColEntranceRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColEntranceColorG = self:AddInput("Green", "ColEntranceGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColEntranceColorB = self:AddInput("Blue",  "ColEntranceBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColEntranceColorA = self:AddInput("Alpha", "ColEntranceAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColWindow", "ColWindow", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColWindow",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColWindowColorR = self:AddInput("Red",   "ColWindowRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColWindowColorG = self:AddInput("Green", "ColWindowGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColWindowColorB = self:AddInput("Blue",  "ColWindowBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColWindowColorA = self:AddInput("Alpha", "ColWindowAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColDust", "ColDust", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColDust",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColDustColorR = self:AddInput("Red",   "ColDustRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColDustColorG = self:AddInput("Green", "ColDustGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColDustColorB = self:AddInput("Blue",  "ColDustBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColDustColorA = self:AddInput("Alpha", "ColDustAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColSand", "ColSand", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColSand",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColSandColorR = self:AddInput("Red",   "ColSandRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColSandColorG = self:AddInput("Green", "ColSandGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColSandColorB = self:AddInput("Blue",  "ColSandBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColSandColorA = self:AddInput("Alpha", "ColSandAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColSky1", "ColSky1", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColSky1",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColSky1ColorR = self:AddInput("Red",   "ColSky1Red",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColSky1ColorG = self:AddInput("Green", "ColSky1Green", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColSky1ColorB = self:AddInput("Blue",  "ColSky1Blue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColSky1ColorA = self:AddInput("Alpha", "ColSky1Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColSky2", "ColSky2", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColSky2",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColSky2ColorR = self:AddInput("Red",   "ColSky2Red",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColSky2ColorG = self:AddInput("Green", "ColSky2Green", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColSky2ColorB = self:AddInput("Blue",  "ColSky2Blue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColSky2ColorA = self:AddInput("Alpha", "ColSky2Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColWater", "ColWater", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColWater",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColWaterColorR = self:AddInput("Red",   "ColWaterRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColWaterColorG = self:AddInput("Green", "ColWaterGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColWaterColorB = self:AddInput("Blue",  "ColWaterBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColWaterColorA = self:AddInput("Alpha", "ColWaterAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()
  self:EndControlNest()

  InBLOOM_SIZESlider = self:AddInput("BLOOM_SIZE", "BLOOM_SIZE", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 2.0,
          INP_Default        = 0.5,
      })

  InBLOOM_THRESHOLDSlider = self:AddInput("BLOOM_THRESHOLD", "BLOOM_THRESHOLD", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 5.0,
          INP_Default        = 1.01,
      })

  InBLOOM_RANGESlider = self:AddInput("BLOOM_RANGE", "BLOOM_RANGE", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.3,
      })

  InBLOOM_FRAME_BLENDSlider = self:AddInput("BLOOM_FRAME_BLEND", "BLOOM_FRAME_BLEND", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.2,
      })


  Sep3 = self:AddInput(string.rep("_", 152), "Separator3", {
    LINKID_DataType     = "Text",
    INPID_InputControl  = "LabelControl",
    INP_External        = false,
    INP_Passive         = true,
    IC_Visible          = true,
    INP_DoNotifyChanged = true,
    IC_NoLabel          = true,
  })
  
  
  InEdges = self:AddInput("Edges", "Edges", {
    LINKID_DataType = "Number",
    INPID_InputControl  = "MultiButtonControl",
    INP_Default         = 3.0,
    INP_Integer         = true,
    INP_DoNotifyChanged = true,
    INP_External        = false,
    MBTNC_ForceButtons  = true,
    INP_MinScale        = 0,
    INP_MaxScale        = 3,
    INP_MinAllowed      = 0,
    INP_MaxAllowed      = 3,
    MBTNC_ShowBasicButton = true,
    MBTNC_StretchToFit  = false, --true,
    MBTNC_ShowToolTip   = true,
    { MBTNC_AddButton = "Canvas", MBTNCD_ButtonWidth = 4/16, },
    { MBTNC_AddButton = "Wrap",MBTNCD_ButtonWidth = 3/16, },
    { MBTNC_AddButton = "Duplicate", MBTNCD_ButtonWidth = 5/16, },
    { MBTNC_AddButton = "Mirror", MBTNCD_ButtonWidth = 4/16, }, 
   }) 

  InDebugImage = self:AddInput("DebugImage", "DebugImage", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Final", },
    { CCS_AddString = "BufferA", },
    { CCS_AddString = "BufferB", },
    { CCS_AddString = "BufferC", },
    { CCS_AddString = "BufferD", },
    CC_LabelPosition = "Horizontal",
  })

  ----- Size & Depth
  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default        = 0,
    INP_Integer        = true,
    ICD_Width          = 1,
	  { CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	  { CCS_AddString  = "Image0", },
    { CCS_AddString  = "1920x1080", },
	  { CCS_AddString  = "1200x675", },
	  { CCS_AddString  = "800x450", },
	  { CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer     = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer     = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
  
  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
    { CCS_AddString  = "Default", },
	  { CCS_AddString  = "int8", },
	  { CCS_AddString  = "int16", },
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false }) 

  ----- In/Out

  InChannel0 = self:AddInput( "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, LINK_Visible = false, INP_Required = false  })
  InChannel1 = self:AddInput( "iChannel1",  "iChannel1",  { LINKID_DataType = "Image", LINK_Main = 2, LINK_Visible = false, INP_Required = false  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main       = 1,
  })


  ShaderFuse.end_create()

end



-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------
function DefineEdges(edges, nodeX)

    --This gets the value of our input image for us to modify inside the kernel
    if edges == 0 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 1 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_WRAP, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 2 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_DUPLICATE, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 3 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 4 then
      --print("Sampler 4")
    end
end



MULTIBUFFER = true
if MULTIBUFFER then   -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  ImgAttrs_Global = {
          { IMG_Channel = "Red", },
          { IMG_Channel = "Green", },
          { IMG_Channel = "Blue", },
          { IMG_Channel = "Alpha", },
          IMG_Width = Width,
          IMG_Height = Height,
          IMG_DeferAlloc = false,
          }

  Image_Buff_GlobalA = Image(ImgAttrs_Global)
  Image_Buff_GlobalB = Image(ImgAttrs_Global)
end


function Process(req)

	-- Imagesize and Depth
  if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InChannel0:GetValue(req) ~= nil) then
			   Width = InChannel0:GetValue(req).Width
			   Height = InChannel0:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value 
		end
	end	
  
  -- Alle ( int und float )
  if (InDepth:GetValue(req).Value > 0) then
	  if InDepth:GetValue(req).Value == 1 then 
	    SourceDepth = 5 
    else 
	    if InDepth:GetValue(req).Value == 2 then 
	        SourceDepth = 6 
	    else 
	        if InDepth:GetValue(req).Value == 3 then 
 		        SourceDepth = 7 
		    	else
			      SourceDepth = 8
	        end
		  end
	  end
	end

  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth  = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }

  local dst   = Image(imgattrs)
  local black = Pixel({R=0,G=0,B=0,A=0})
  dst:Fill(black)

if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  dstA = Image {IMG_Like = dst, IMG_DeferAlloc = true}
	dstB = Image {IMG_Like = dst, IMG_DeferAlloc = true}
end

  if req:IsPreCalc() then
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end


if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA = DVIPComputeNode(req,
    "TinyHideoutFuse__Buffer_A", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
else
    node = DVIPComputeNode(req,
    "TinyHideoutFuse", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
end
  -- Extern texture or create a new one

  iChannel0 = InChannel0:GetValue(req)

  if iChannel0==nil then
    iChannel0 = Image(imgattrs)
    iChannel0:Fill(black)
  end

  iChannel1 = InChannel1:GetValue(req)

  if iChannel1==nil then
    iChannel1 = Image(imgattrs)
    iChannel1:Fill(black)
  end

  -- DCTL parameters

  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    params = nodeA:GetParamBlock(ShaderParameters)
  else  
    params = node:GetParamBlock(ShaderParameters)
  end  

  params.iResolution[0] = dst.Width
  params.iResolution[1] = dst.Height
  params.iTime = (req.Time / framerate) * InFrequency:GetValue(req).Value
  
  -- iMouse
  
  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)
  
  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y
  
  if InMouseDrag:GetValue(req).Value ~= 0 then
    if params.iMouse[2]==-1 and params.iMouse[3]==-1 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = -1
    params.iMouse[3] = -1
  end
  
  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end
  
  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  if params.iMouse[2] == -1 and params.iMouse[3] == -1 then
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  else
    params.iMouse[2] = params.iMouse[2] * Width
    params.iMouse[3] = params.iMouse[3] * Height
  end

  params.ColLeafs = {
    InColLeafsColorR:GetValue(req).Value,
    InColLeafsColorG:GetValue(req).Value,
    InColLeafsColorB:GetValue(req).Value,InColLeafsColorA:GetValue(req).Value
  }
  params.ColGround = {
    InColGroundColorR:GetValue(req).Value,
    InColGroundColorG:GetValue(req).Value,
    InColGroundColorB:GetValue(req).Value,InColGroundColorA:GetValue(req).Value
  }
  params.ColGroundTOP = {
    InColGroundTOPColorR:GetValue(req).Value,
    InColGroundTOPColorG:GetValue(req).Value,
    InColGroundTOPColorB:GetValue(req).Value,InColGroundTOPColorA:GetValue(req).Value
  }
  params.ColPlate = {
    InColPlateColorR:GetValue(req).Value,
    InColPlateColorG:GetValue(req).Value,
    InColPlateColorB:GetValue(req).Value,InColPlateColorA:GetValue(req).Value
  }
  params.ColWalls = {
    InColWallsColorR:GetValue(req).Value,
    InColWallsColorG:GetValue(req).Value,
    InColWallsColorB:GetValue(req).Value,InColWallsColorA:GetValue(req).Value
  }
  params.ColRoof = {
    InColRoofColorR:GetValue(req).Value,
    InColRoofColorG:GetValue(req).Value,
    InColRoofColorB:GetValue(req).Value,InColRoofColorA:GetValue(req).Value
  }
  params.ColEntrance = {
    InColEntranceColorR:GetValue(req).Value,
    InColEntranceColorG:GetValue(req).Value,
    InColEntranceColorB:GetValue(req).Value,InColEntranceColorA:GetValue(req).Value
  }
  params.ColWindow = {
    InColWindowColorR:GetValue(req).Value,
    InColWindowColorG:GetValue(req).Value,
    InColWindowColorB:GetValue(req).Value,InColWindowColorA:GetValue(req).Value
  }
  params.ColDust = {
    InColDustColorR:GetValue(req).Value,
    InColDustColorG:GetValue(req).Value,
    InColDustColorB:GetValue(req).Value,InColDustColorA:GetValue(req).Value
  }
  params.ColSand = {
    InColSandColorR:GetValue(req).Value,
    InColSandColorG:GetValue(req).Value,
    InColSandColorB:GetValue(req).Value,InColSandColorA:GetValue(req).Value
  }
  params.ColSky1 = {
    InColSky1ColorR:GetValue(req).Value,
    InColSky1ColorG:GetValue(req).Value,
    InColSky1ColorB:GetValue(req).Value,InColSky1ColorA:GetValue(req).Value
  }
  params.ColSky2 = {
    InColSky2ColorR:GetValue(req).Value,
    InColSky2ColorG:GetValue(req).Value,
    InColSky2ColorB:GetValue(req).Value,InColSky2ColorA:GetValue(req).Value
  }
  params.ColWater = {
    InColWaterColorR:GetValue(req).Value,
    InColWaterColorG:GetValue(req).Value,
    InColWaterColorB:GetValue(req).Value,InColWaterColorA:GetValue(req).Value
  }
  params.BLOOM_SIZE = InBLOOM_SIZESlider:GetValue(req).Value
  params.BLOOM_THRESHOLD = InBLOOM_THRESHOLDSlider:GetValue(req).Value
  params.BLOOM_RANGE = InBLOOM_RANGESlider:GetValue(req).Value
  params.BLOOM_FRAME_BLEND = InBLOOM_FRAME_BLENDSlider:GetValue(req).Value
  -- Resolution

  params.width  = dst.Width
  params.height = dst.Height

  -- Per channel time and resolution


    local edges = InEdges:GetValue(req).Value

  -- Set parameters and add I/O
  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA:SetParamBlock(params)
    --nodeA:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, nodeA)
  else   
    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)
    
    node:AddInput("iChannel0",iChannel0) -- TODO: add a better channel name
    node:AddInput("iChannel1",iChannel1) -- TODO: add a better channel name
    node:AddOutput("dst", dst)
  end
  
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 

    nodeA:AddOutput("dst", dstA)

    local ok = nodeA:RunSession(req)

    if (not ok) then
      dstA = nil
      dump(nodeA:GetErrorLog())
    end
    
    Image_Buff_GlobalA = dstA

  -------------------------- BufferB-Kernel----------------------------------------
    local nodeB = DVIPComputeNode(req,
      "TinyHideoutFuse__Buffer_B", ShaderCompatibilityCode..ShaderKernelCode,
      "Params", ShaderParameters
    )
    
    nodeB:SetParamBlock(params)

    --nodeB:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, nodeB)
    
    nodeB:AddInput("iChannel0", Image_Buff_GlobalB)  -- Anpassen !!
    nodeB:AddInput("iChannel1", Image_Buff_GlobalA)  -- Anpassen !!
    nodeB:AddOutput("dst", dstB)

    local success = nodeB:RunSession(req)
    if not success then
      dstB = nil
      dump(nodeB:GetErrorLog())
    end
    
    Image_Buff_GlobalB = dstB --Recursiv Image	
    
    -------------------------- ImageKernel----------------------------------------
    node = DVIPComputeNode(req,
      "TinyHideoutFuse", ShaderCompatibilityCode..ShaderKernelCode,
      "Params", ShaderParameters
    )

    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)

    node:AddInput("iChannel0", Image_Buff_GlobalA)  -- Anpassen !!
    node:AddInput("iChannel1", Image_Buff_GlobalB)  -- Anpassen !!
    node:AddOutput("dst", dst)
 
  end -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  

  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    dump(node:GetErrorLog())
	end

  OutImage:Set(req,dst)
  
  
    --Debugging
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER
    InDebugImage:SetAttrs({ IC_Visible = true })
    
    if (InDebugImage:GetValue(req).Value == 1) then OutImage:Set(req, Image_Buff_GlobalA) end
    if (InDebugImage:GetValue(req).Value == 2) then OutImage:Set(req, Image_Buff_GlobalB) end
  else
    InDebugImage:SetAttrs({ IC_Visible = false })
  end
    
  
  collectgarbage();
end


-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

function NotifyChanged(inp, param, time)
 	if (param ~= nil) then

		if inp == InSize then
		  if param.Value == 1 then
			  InWidth:SetAttrs({ IC_Visible = true })
			  InHeight:SetAttrs({ IC_Visible = true })
		  else
			  InWidth:SetAttrs({ IC_Visible = false })
			  InHeight:SetAttrs({ IC_Visible = false })
		  end
		  
		  if param.Value == 3 then --1920x1080
			  InWidth:SetSource(Number(1920),0,0)
			  InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			  InWidth:SetSource(Number(1200),0,0)
			  InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			  InWidth:SetSource(Number(800),0,0)
			  InHeight:SetSource(Number(450),0,0)
		  end
 	    if param.Value == 6 then --640x360
		    InWidth:SetSource(Number(640),0,0)
		    InHeight:SetSource(Number(360),0,0)
		  end
		end 

 	end
end


-- */
