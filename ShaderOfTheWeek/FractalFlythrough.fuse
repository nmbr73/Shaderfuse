--[[--
FractalFlythrough

    Based on https://www.shadertoy.com/view/4s3SRN a WebGL
    shader from shadertoy.com converted to DCTL and embeddet
    into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT)
    for use in DaFusion.

    Shader created by Shane on 2016-03-23

	V0.2 Cuda Bugfix

--]] --

local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()


-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------
FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,
  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,

  REG_Source_GlobalCtrls = true,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  --REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  REG_NoPreCalcProcess   = true,  -- call Process for precalc requests (instead of PreCalcProcess)
  })

-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------
FractalFlythroughParams =
[[
  float center[2];
  float angle;
  float pivot[2];
  float debug;
  float scale;
  float freq;
  float objID;
  bool tex;
  float damp;
  float phase;
  float staticdrops[2];
  float look[3];
  float color[3];
  float color2[3];
  int width;
  int height;
  float itime;
  int compOrder;
]]


-- source of kernel
FractalFlythroughKernel =
    [[

//-----------------------
//-------- mat3 ---------
//-----------------------

//**** mat3 ****
typedef struct
  {
	float3 r0, r1, r2;
  } mat3;

__DEVICE__ inline mat3 make_mat3( float3 A, float3 B, float3 C)
  {
	mat3 D;
	D.r0 = A;
	D.r1 = B;
	D.r2 = C;
	return D;
  }


__DEVICE__ inline float3 mat3_multi_f3( mat3 B, float3 A) {
	float3 C;

	C.x = A.x * B.r0.x + A.y * B.r1.x + A.z * B.r2.x;
	C.y = A.x * B.r0.y + A.y * B.r1.y + A.z * B.r2.y;
	C.z = A.x * B.r0.z + A.y * B.r1.z + A.z * B.r2.z;
	return C;
  }

__DEVICE__ inline float3 f3_multi_mat3( float3 A, mat3 B) {
  float3 C;

  C.x = A.x * B.r0.x + A.y * B.r0.y + A.z * B.r0.z;
  C.y = A.x * B.r1.x + A.y * B.r1.y + A.z * B.r1.z;
  C.z = A.x * B.r2.x + A.y * B.r2.y + A.z * B.r2.z;
  return C;
 }


#define swixy(V) to_float2((V).x,(V).y)

#define swixyz(V) to_float3((V).x,(V).y,(V).z)
  #define swixxx(V) to_float3((V).x,(V).x,(V).x)
  #define swixyy(V) to_float3((V).x,(V).y,(V).y)
  #define swiyxy(V) to_float3((V).y,(V).x,(V).y)
  #define swiyyx(V) to_float3((V).y,(V).y,(V).x)


__DEVICE__ float fract_f(float A){return A - _floor(A);}
__DEVICE__ float2 fract_f2(float2 A){return make_float2(A.x - _floor(A.x), A.y - _floor(A.y));}
__DEVICE__ float3 fract_f3(float3 A){return make_float3(A.x - _floor(A.x), A.y - _floor(A.y), A.z - _floor(A.z));}
__DEVICE__ float2 abs_f2(float2 a) {return (to_float2(_fabs(a.x), _fabs(a.y)));}
__DEVICE__ float3 abs_f3(float3 a) {return (to_float3(_fabs(a.x), _fabs(a.y),_fabs(a.z)));}
#define lpowf _powf
__DEVICE__ float2 pow_f2(float2 a, float2 b) {float2 r; r.x = lpowf(a.x,b.x); r.y = lpowf(a.y,b.y); return r;}
__DEVICE__ float3 pow_f3(float3 a, float3 b) {float3 r; r.x = lpowf(a.x,b.x); r.y = lpowf(a.y,b.y); r.z = lpowf(a.z,b.z); return r;}
__DEVICE__ float3 sqrt_f3(float3 a) {float3 r; r.x = _sqrtf(a.x); r.y = _sqrtf(a.y); r.z = _sqrtf(a.z); return r;}
#if defined(DEVICE_IS_OPENCL) || defined(DEVICE_IS_METAL)
__DEVICE__ float3 reflect(float3 I, float3 N) {return I - 2.0f * dot(N, I) * N;}
#endif
__DEVICE__ float3 mix_f3(float3 v, float3 i, float3 m) {return to_float3(_mix(v.x,i.x,m.x),_mix(v.y,i.y,m.y),_mix(v.z,i.z,m.z));}

/*

	Fractal Flythrough
	------------------

	Moving a camera through a fractal object. It's a work progress.

	I was looking at one of Dr2's shaders that involved moving a camera through a set of way points (set
	out on the XZ plane), and thought it'd be cool to do a similar 3D version. The idea was to create a
	repetitive kind of fractal object, give the open space nodes a set random direction, create some
	spline points, then run a smooth camera through them. Simple... right? It always seems simple my
	head, but gets progressively harder when I try it a shader. :)

	I've run into that classic up-vector, camera flipping problem... At least, I think that's the problem?
	swiyw(A)ay, I'm hoping the solution is simple, and that someone reading this will be able to point me
	the right direction.

	For now, I've set up a set of 16 random looping points that the camera seems reasonably comfortable
	with. Just for the record, the general setup works nicely, until the camera loops back on itself
	the YZ plane. I'm guessing that increasing the number of way points may eradicate some of the
         intermittent camera spinning, but I figured I'd leave things alone and treat it as a feature. :)

	By the way, I was thankful to have Otavio Good's spline setup his "Alien Beacon" shader as a
	reference. On a side note, that particular shader is one of my all time favorites on this site.

	The rendering materials are slightly inspired by the Steampunk genre. Timber, granite, brass, etc.
	It needs spinning turbines, gears, rivots, and so forth, but that stuff's expensive. Maybe later.
	Tambako	Jaguar did a really cool shader the Steampunk aesthetic. The link is below.

	Besides camera path, there's a whole bunch of improvements I'd like to make to this. I've relied on
	occlusion to mask the fact that there are no shadows. I'm hoping to free up some cycles, so I can put
	them back in. I'd also like to add extra detail, but that also slows things down. As for the comments,
	they're very rushed, but I'll tidy those up as well.

	References:

	Alien Beacon - Otavio Good
	https://www.shadertoy.com/view/ld2SzK

    Steampunk Turbine - TambakoJaguar
    https://www.shadertoy.com/view/lsd3zf

    // The main inspiration for this shader.
	Mandelmaze Daylight - dr2
    https://www.shadertoy.com/view/MdVGRc

*/

#define FAR  50.0f // Far plane.

// Used to identify individual scene objects. In this case, there are only three: The metal framework, the gold
// and the timber.
//float objID = 0.0f; // Wood = 1.0f, Metal = 2.0f, Gold = 3.0f.

// Simple hash function.
__DEVICE__ float hash( float n ){ return fract_f(_cosf(n)*45758.5453f); }



// Tri-Planar blending function. Based on an old Nvidia writeup:
// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.0fhtml
__DEVICE__ float3 tex3D(__TEXTURE2D__ t, float3 p, float3 n, float ratio ){

    n = _fmaxf(abs_f3(n), to_float3_s(0.001f));
    n /= dot(n, to_float3_s(1));
	float3 tx = swixyz(_tex2DVecN(t, p.y/ratio,p.z,15));
    float3 ty = swixyz(_tex2DVecN(t, p.z,p.x*ratio,15));
    float3 tz = swixyz(_tex2DVecN(t, p.x/ratio,p.y,15));

    // Textures are stored sRGB (I think), so you have to convert them to linear space
    // (squaring is a rough approximation) prior to working with them... or something like that. :)
    // Once the final color value is gamma corrected, you should see correct looking colors.
    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);

}

// Common formula for rounded squares, for all intended purposes.
__DEVICE__ float lengthN(float2 p, float n){ p = pow_f2(abs_f2(p), to_float2_s(n)); return _powf(p.x + p.y, 1.0f/n); }


// The camera path: There are a few spline setups on Shadertoy, but this one is a slight variation of
// Otavio Good's spline setup his "Alien Beacon" shader: https://www.shadertoy.com/view/ld2SzK
//
// Spline point markers ("cp" for camera point). The camera visits each point succession, then loops
// back to the first point, when complete, order to repeat the process. In case it isn't obvious, each
// point represents an open space juncture the object that links to the previous and next point.
// Of course, running a camera a straight line between points wouldn't produce a smooth camera effect,
// so we apply the Catmull-Rom equation to the line segment.

#ifdef DEVICE_IS_METAL
  #define inout thread
#else
  #define inout
#endif


__DEVICE__ void setCamPath(inout float3 *cp)
{

    // The larger fractal object has nodes a 4x4x4 grid.
    // The smaller one a 2x2x2 grid. The following points
    // map a path to various open areas throughout the object.
    const float sl = 2.0f*0.96f;
    const float bl = 4.0f*0.96f;

    cp[0] = make_float3(0, 0, 0);
    cp[1] = make_float3(0, 0, bl);
    cp[2] = make_float3(sl, 0, bl);
    cp[3] = make_float3(sl, 0, sl);
    cp[4] = make_float3(sl, sl, sl);
    cp[5] = make_float3(-sl, sl, sl);
    cp[6] = make_float3(-sl, 0, sl);
    cp[7] = make_float3(-sl, 0, 0);

    cp[8] = make_float3(0, 0, 0);
    cp[9] = make_float3(0, 0, -bl);
    cp[10] = make_float3(0, bl, -bl);
    cp[11] = make_float3(-sl, bl, -bl);
    cp[12] = make_float3(-sl, 0, -bl);
    cp[13] = make_float3(-sl, 0, 0);
    cp[14] = make_float3(-sl, -sl, 0);
    cp[15] = make_float3(0, -sl, 0);

    // Tighening the radius a little, so that the camera doesn't hit the walls.
    // I should probably hardcode this into the above... Done.
    //for(int i=0; i<16; i++) cp[i] *= 0.96f;

}

// Standard Catmull-Rom equation. The equation takes the line segment end points (p1 and p2), the
// points on either side (p0 and p3), the current fractional distance (t) along the segment, then
// returns the the smooth (cubic interpolated) position. The end result is a smooth transition
// between points... Look up a diagram on the internet. That should make it clearer.
__DEVICE__ float3 Catmull(float3 p0, float3 p1, float3 p2, float3 p3, float t){

    return (((-p0 + p1*3.0f - p2*3.0f + p3)*t*t*t + (p0*2.0f - p1*5.0f + p2*4.0f - p3)*t*t + (-p0 + p2)*t + p1*2.0f)*0.5f);

}

// Camera path. Determine the segment number (segNum), and how far - timewise - we are along it (segTime).
// Feed the segment, the appropriate adjoining segments, and the segment time into the Catmull-Rom
// equation to produce a camera position. The process is pretty simple, once you get the hang of it.
__DEVICE__ float3 camPath(float t, inout float3 *cp){

    const int aNum = 16;

    t = fract_f(t/(float)(aNum))*(float)(aNum);	// Repeat every 16 time units.

    // Segment number. Range: [0, 15], this case.
    float segNum = _floor(t);
    // Segment portion. Analogous to how far we are alone the individual line segment. Range: [0, 1].
    float segTime = t - segNum;


    if (segNum == 0.0f) return Catmull(cp[aNum-1], cp[0], cp[1], cp[2], segTime);

    for(int i=1; i<aNum-2; i++){
        if (segNum == (float)(i)) return Catmull(cp[i-1], cp[i], cp[i+1], cp[i+2], segTime);
    }

    if (segNum == (float)(aNum-2)) return Catmull(cp[aNum-3], cp[aNum-2], cp[aNum-1], cp[0], segTime);
    if (segNum == (float)(aNum-1)) return Catmull(cp[aNum-2], cp[aNum-1], cp[0], cp[1], segTime);

    return to_float3_s(0);

}

// Smooth minimum function. There are countless articles, but IQ explains it best here:
// http://iquilezles.swiwww(org)/articles/smin/smin.htm
__DEVICE__ float sminP( float a, float b, float s ){

    float h = clamp( 0.5f+0.5f*(b-a)/s, 0.0f, 1.0f );
    return _mix( b, a, h ) - s*h*(1.0f-h);
}

// Creating the scene geometry.
//
// There are two intertwined fractal objects. One is a gold and timber lattice, spread out a 4x4x4
// grid. The second is some metallic tubing spread out over a 2x2x2 grid. Each are created by combining
// repeat objects with various operations. All of it is pretty standard.
//
// The code is a little fused together, order to save some cycles, but if you're interested the
// process, I have a "Menger Tunnel" example that's a little easier to decipher.
__DEVICE__ float map(float3 q, float *objID){


///////////

    // The grey section. I have another Menger example, if you'd like to look into that more closely.
    // Layer one.
    float3 p = abs_f3(fract_f3(q/4.0f)*4.0f - 2.0f);
    float tube = _fminf(_fmaxf(p.x, p.y), _fminf(_fmaxf(p.y, p.z), _fmaxf(p.x, p.z))) - 4.0f/3.0f - 0.015f;// + 0.05f;


    // Layer two.
    p = abs_f3(fract_f3(q/2.0f)*2.0f - 1.0f);
    //d = _fmaxf(d, _fminf(_fmaxf(p.x, p.y), _fminf(_fmaxf(p.y, p.z), _fmaxf(p.x, p.z))) - s/3.0f);// + 0.025f
    tube = _fmaxf(tube, sminP(_fmaxf(p.x, p.y), sminP(_fmaxf(p.y, p.z), _fmaxf(p.x, p.z), 0.05f), 0.05f) - 2.0f/3.0f);// + 0.025f

///////
    // The gold and timber paneling.
    //
    // A bit of paneling, using a combination of repeat objects. We're doing it here layer two, just
    // to save an extra "fract" call. Very messy, but saves a few cycles... maybe.

    //float panel = sminP(length(swixy(p)),sminP(length(swiyz(p)),length(swixz(p)), 0.25f), 0.125f)-0.45f; // EQN 1
    //float panel = _sqrtf(_fminf(dot(swixy(p), swixy(p)),_fminf(dot(swiyz(p), swiyz(p)),dot(swixz(p), swixz(p)))))-0.5f; // EQN 2
    //float panel = _fminf(_fmaxf(p.x, p.y),_fminf(_fmaxf(p.y, p.z),_fmaxf(p.x, p.z)))-0.5f; // EQN 3
    float panel = sminP(_fmaxf(p.x, p.y),sminP(_fmaxf(p.y, p.z),_fmaxf(p.x, p.z), 0.125f), 0.125f)-0.5f; // EQN 3


    // Gold strip. Probably not the best way to do this, but it gets the job done.
    // Identifying the gold strip region, then edging it out a little... for whatever reason. :)
    float strip = step(p.x, 0.75f)*step(p.y, 0.75f)*step(p.z, 0.75f);
    panel -= (strip)*0.025f;

    // Timber bulge. Just another weird variation.
    //float bulge = (_fmaxf(_fmaxf(p.x, p.y), p.z) - 0.55f);//length(p)-1.0f;//
    //panel -= bulge*(1.0f-step(p.x, 0.75f)*step(p.y, 0.75f)*step(p.z, 0.75f))*bulge*0.25f;

    // Repeat field entity two, which is just an abstract object repeated every half unit.
    p = abs_f3(fract_f3(q*2.0f)*0.5f - 0.25f);
    float pan2 = _fminf(p.x, _fminf(p.y,p.z))-0.05f;

    // Combining the two entities above.
    panel = _fmaxf(_fabs(panel), _fabs(pan2)) - 0.0425f;
/////////

    // Layer three. 3D space is divided by three.
    p = abs_f3(fract_f3(q*1.5f)/1.5f - 1.0f/3.0f);
 	tube = _fmaxf(tube, _fminf(_fmaxf(p.x, p.y), _fminf(_fmaxf(p.y, p.z), _fmaxf(p.x, p.z))) - 2.0f/9.0f + 0.025f); // + 0.025f


    // Layer three. 3D space is divided by two, instead of three, to give some variance.
    p = abs_f3(fract_f3(q*3.0f)/3.0f - 1.0f/6.0f);
 	tube = _fmaxf(tube, _fminf(_fmaxf(p.x, p.y), _fminf(_fmaxf(p.y, p.z), _fmaxf(p.x, p.z))) - 1.0f/9.0f - 0.035f); //- 0.025f




    // Object ID: Equivalent to: if(tube<panel)objID=2; else objID = 1.0f; //etc.
    //
    // By the way, if you need to identify multiple objects, you're better off doing it a seperate pass,
    // after the raymarching function. Having multiple "if" statements a distance field equation can
    // slow things down considerably.

    //objID = 2.0f - step(tube, panel) + step(panel, tube)*(strip);
    *objID = 1.0f+ step(tube, panel) + step(panel, tube)*(strip)*2.0f;
    //objID = 1.0f + step(panel, tube)*(strip) + step(tube, panel)*2.0f;


    return _fminf(panel, tube);


}

__DEVICE__ float trace(float3 ro, float3 rd, float *objID){

    float t = 0.0f, h;
    for(int i = 0; i < 92; i++){

        h = map(ro+rd*t, objID);
        // Note the "t*b + a" addition. Basically, we're putting less emphasis on accuracy, as
        // "t" increases. It's a cheap trick that works most situations... Not all, though.
        if(_fabs(h)<0.001f*(t*0.25f + 1.0f) || t>FAR) break; // Alternative: 0.001f*_fmaxf(t*0.25f, 1.0f)
        t += h*0.8f;

    }

    return t;
}


// The reflections are pretty subtle, so not much effort is being put into them. Only eight iterations.
__DEVICE__ float refTrace(float3 ro, float3 rd, float *objID){

    float t = 0.0f;
    for(int i=0; i<16; i++){
        float d = map(ro + rd*t, objID);
        if (d < 0.0025f*(t*0.25f + 1.0f) || t>FAR) break;
        t += d;
    }
    return t;
}



/*
// Tetrahedral normal, to save a couple of "map" calls. Courtesy of IQ.
float3 calcNormal(float3 p){

    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.
    float2 e = make_float2(0.0025f, -0.0025f);
    return normalize(swixyy(e) * map(p + swixyy(e)) + swiyyx(e) * map(p + swiyyx(e)) + swiyxy(e) * map(p + swiyxy(e)) + swixxx(e) * map(p + swixxx(e)));
}
*/

// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to
// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.
__DEVICE__ float3 calcNormal(float3 p, float *objID) {
	const float2 e = make_float2(0.005f, 0);
	return normalize(make_float3(map(p + swixyy(e),objID) - map(p - swixyy(e),objID), map(p + swiyxy(e),objID) - map(p - swiyxy(e),objID),	map(p + swiyyx(e),objID) - map(p - swiyyx(e),objID)));
}

// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)
// swiyw(A)ay, I like this one. I'm assuming it's based on IQ's original.
__DEVICE__ float calcAO(float3 pos, float3 nor, float *objID)
{
	float sca = 2.0f, occ = 0.0f;
    for( int i=0; i<5; i++ ){

        float hr = 0.01f + (float)(i)*0.5f/4.0f;
        float dd = map(nor * hr + pos,objID);
        occ += (hr - dd)*sca;
        sca *= 0.7f;
    }
    return clamp( 1.0f - occ, 0.0f, 1.0f );
}


// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups total. I tried to
// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.
__DEVICE__ float3 texBump( __TEXTURE2D__ tx, float3 p, float3 n, float bf, float ratio){

    const float2 e = make_float2(0.001f, 0);

    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.
    mat3 m = make_mat3( tex3D(tx, p - swixyy(e), n, ratio), tex3D(tx, p - swiyxy(e), n, ratio), tex3D(tx, p - swiyyx(e), n, ratio));

    float3 g = f3_multi_mat3(make_float3(0.299f, 0.587f, 0.114f),m); // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n, ratio), make_float3(0.299f, 0.587f, 0.114f)) )/e.x; g -= n*dot(n, g);
    //g = (g - dot(tex3D(tx,  p , n), make_float3(0.299f, 0.587f, 0.114f)) )/e.x; g -= n*dot(n, g);
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.

}

__DEVICE__ float2 spin(float2 uv, float2 center, float angle, float aspect)
{
  float C = _cosf(angle);
  float S = _sinf(angle);

  uv -= center;
  float x = uv.x;
  uv.x = (x*aspect * C - uv.y * S);
  uv.y = (x*aspect * S + uv.y * C);
  uv += center;

return uv;
}

//############################################################################################################################
__KERNEL__ void FractalFlythroughKernel(__CONSTANTREF__ FractalFlythroughParams *params, __TEXTURE2D__ iChannel0, __TEXTURE2D_WRITE__ dst)
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);
  //---------------------------------------
  if (x < params->width && y < params->height)
  {

     //-----------------------
     float2 fragCoord = to_float2(x, y);
     float2 iResolution = to_float2(params->width, params->height);
     float ratio = (float)params->width/(float)params->height;
     float itime=params->itime * params->freq;
	 float4 fragColor = to_float4_s(0.0f);
     //-----------------------

    //Functionality.......
    float3 cp[16];
    float objID = 0.0f; // Wood = 1.0f, Metal = 2.0f, Gold = 3.0f.

    // Screen coordinates.
    float2 u = (fragCoord - iResolution*0.5f)/iResolution.y;

	// Standardparameter
    u -=  to_float2( (params->center[0]-0.5f)*1.0f*ratio, (params->center[1]-0.5f)*1.0f); //*ratio*2.0f
    u *= params->scale;
    float2 pivot = to_float2(((params->pivot[0]-0.5f)*1.0f*ratio),(params->pivot[1]-0.5f)*1.0f); //*ratio
    u = spin(u, pivot*params->scale, params->angle, 1.0f);

    float speed = itime*0.35f + 8.0f;

    // Initiate the camera path spline points. Kind of wasteful not making this global, but I wanted
    // it self contained... for better or worse. I'm not really sure what the GPU would prefer.
    setCamPath(cp);


    // Camera Setup.
    float3 ro = camPath(speed,cp); // Camera position, doubling as the ray origin.
    float3 lk = camPath(speed + 0.5f,cp);  // "Look At" position.

	lk += to_float3_v(params->look);

    float3 lp = camPath(speed + 0.5f,cp) + make_float3(0, 0.25f, 0); // Light position, somewhere near the moving camera.


    // Using the above to produce the unit ray-direction vector.
    float FOV = 1.57f; // FOV - Field of view.
    float3 fwd = normalize(lk-ro);
    float3 rgt = normalize(make_float3(fwd.z, 0, -fwd.x));
    float3 up = (cross(fwd, rgt));

    // Unit direction ray.
    float3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));


    // Raymarch the scene.
    float t = trace(ro, rd, &objID);

    // Initialize the scene color.
    float3 col = to_float3_s(0);

    // Scene hit, so color the pixel. Technically, the object should always be hit, so it's tempting to
    // remove this entire branch... but I'll leave it, for now.
    if(t<FAR){

        // This looks a little messy and haphazard, but it's really just some basic lighting, and application
        // of the following material properties: Wood = 1.0f, Metal = 2.0f, Gold = 3.0f.

        float ts = 1.0f;  // Texture scale.

        // Global object ID. It needs to be saved just after the raymarching equation, since other "map" calls,
        // like normal calculations will give incorrect results. Found that out the hard way. :)
        float saveObjID = objID;

		if (params->objID > 0.0f) saveObjID = params->objID;

        float3 pos = ro + rd*t; // Scene postion.
        float3 nor = calcNormal(pos, &objID); // Normal.
        float3 sNor = nor;


        // Apply some subtle texture bump mapping to the panels and the metal tubing.
        nor = texBump(iChannel0, pos*ts, nor, 0.002f,ratio); // + step(saveObjID, 1.5f)*0.002f

        // Reflected ray. Note that the normal is only half bumped. It's fake, but it helps
        // taking some of the warping effect off of the reflections.
        float3 ref = reflect(rd, normalize(sNor*0.5f + nor*0.5f));

        if (params->tex)
           col = tex3D(iChannel0, pos*ts, nor, ratio); // Texture pixel at the scene postion.
        else
		   col = to_float3_v(params->color);

        float3  li = lp - pos; // Point light.
        float lDist = _fmaxf(length(li), 0.001f); // Surface to light distance.
        float atten = 1.0f/(1.0f + lDist*0.125f + lDist*lDist*0.05f); // Light attenuation.
        li /= lDist; // Normalizing the point light vector.

        float occ = calcAO( pos, nor, &objID ); // Occlusion.

        float dif = clamp(dot(nor, li), 0.0f, 1.0f); // Diffuse.
        dif = _powf(dif, 4.0f)*2.0f;
        float spe = _powf(_fmaxf(dot(reflect(-li, nor), -rd), 0.0f), 8.0f); // Object specular.
        float spe2 = spe*spe; // Global specular.

        float refl = 0.35f; // Reflection coefficient. Different for different materials.



        // Reflection color. Mostly fake.
        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much
        // effort is being put in.
        float rt = refTrace(pos + ref*0.1f, ref, &objID); // Raymarch from "sp" the reflected direction.
        float rSaveObjID = objID; // IDs change with reflection. Learned that the hard way. :)
        float3 rsp = pos + ref*rt; // Reflected surface hit point.
        float3 rsn = calcNormal(rsp, &objID); // Normal at the reflected surface. Too costly to bump reflections.
        float3 rCol = tex3D(iChannel0, rsp*ts, rsn, ratio); // Texel at "rsp."
        float3 rLi = lp-rsp;
        float rlDist = _fmaxf(length(rLi), 0.001f);
        rLi /= rlDist;
        float rDiff = _fmaxf(dot(rsn, rLi), 0.0f); // Diffuse light at "rsp."
        rDiff = _powf(rDiff, 4.0f)*2.0f;
        float rAtten = 1.0f/(1.0f + rlDist*0.125f + rlDist*rlDist*0.05f);

        if(rSaveObjID>1.5f && rSaveObjID<2.5f){
            rCol = to_float3_s(1)*dot(rCol, make_float3(0.299f, 0.587f, 0.114f))*0.7f + rCol*0.15f;//*0.7f+0.2f
            //rDiff *= 1.35f;
        }
        if(rSaveObjID>2.5f){
             //float rc = dot(rCol, make_float3(0.299f, 0.587f, 0.114f));
             float3 rFire = pow_f3(make_float3(1.5f, 1, 1)*rCol, make_float3(8, 2, 1.5f));//*0.5f+rc*0.5f;
             rCol = _fminf(mix_f3(make_float3(1.5f, 0.9f, 0.375f), make_float3(0.75f, 0.375f, 0.3f), rFire), to_float3_s(2.0f))*0.5f + rCol;
        }
// float zzzzzzzzzzzzzzz; // unused variable!?! ;-)
        rCol *= (rDiff + 0.35f)*rAtten; // Reflected color. Not accurate, but close enough.



        // Grey metal inner tubing.
        if(saveObjID>1.5f && saveObjID<2.5f){

            // Grey out the limestone wall color.
			if (params->tex)
               col = to_float3_s(1)*dot(col, make_float3(0.299f, 0.587f, 0.114f))*0.7f + col*0.15f;
            else
		       col = to_float3_v(params->color2);


            refl = 0.5f;
            //dif *= 1.35f;
            //spe2 *= 1.35f;

        }

        // Gold trimming properties. More effort should probably be put here.
        // I could just write "saveObjID == 3.0f," but I get a little paranoid where floats are concerned. :)
        if(saveObjID>2.5f){

            // For the screen image, we're interested the offset height and depth positions. Ie: swizy(pOffs).

            // Pixelized dot pattern shade.
            //float c = dot(col, make_float3(0.299f, 0.587f, 0.114f));

            float3 fire = pow_f3(make_float3(1.5f, 1, 1)*col, make_float3(8, 2, 1.5f));//*0.5f+c*0.5f;
            col = _fminf(mix_f3(make_float3(1, 0.9f, 0.375f), make_float3(0.75f, 0.375f, 0.3f), fire), to_float3_s(2.0f))*0.5f + col;//

            refl = 0.65f;
            //dif *= 1.5f;
            //spe2 *= 1.5f;

        }


        // Combining everything together to produce the scene color.
        col = col*(dif + 0.35f  + make_float3(0.35f, 0.45f, 0.5f)*spe) + make_float3(0.7f, 0.9f, 1)*spe2 + rCol*refl;
        col *= occ*atten; // Applying occlusion.


    }


    // Applying some very slight fog the distance. This is technically an inside scene...
    // Or is it underground... Who cares, it's just a shader. :)
    col = _mix(_fminf(col, to_float3_s(1.0f)), to_float3_s(0), 1.0f-_expf(-t*t/FAR/FAR*20.0f));//smoothstep(0.0f, FAR-20.0f, t)
    //col = _mix(_fminf(col, 1.0f), make_float3(0), smoothstep(0.0f, FAR-35.0f, t));//smoothstep(0.0f, FAR-20.0f, t)



    // Done.
    fragColor = to_float4_aw(sqrt_f3(_fmaxf(col, to_float3_s(0.0f))), 1.0f);

    _tex2DVec4Write(dst, x, y, fragColor);
  }
}
]]

-------------------------------------------------------------------
--       Create
-------------------------------------------------------------------
function Create()
--------------------------------------------
ShaderFuse.begin_create()
--------------------------------------------
  Sep1 = self:AddInput(string.rep("_", 52), "Separator1", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })

  --------------- FractalFlythrough ---------------
  InCenter = self:AddInput("Center", "Center", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INPID_PreviewControl = "CrosshairControl",
    INP_DoNotifyChanged = true,
    })

  InScale = self:AddInput("Scale", "Scale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    --INPID_PreviewControl = "RectangleControl",
    RCD_LockAspect     = 1,
    RC_DoLockAspect    = true,
    RCID_Center        = "Center",
    INP_Default = 1.0,
    INP_MinAllowed = 0.1,
    INP_MaxAllowed = 5.0,
    })

  InDebug = self:AddInput("Debug", "Debug", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 1.0,
    --INP_MinScale = 0.0,
    --INP_MaxScale = 5.0,
    --INPID_PreviewControl = "RectangleControl",
    RCD_LockAspect     = 1,
    RC_DoLockAspect    = true,
    RCID_Center = "Center",
    PC_Visible          = false,
  })

  InAngle = self:AddInput("Angle", "Angle", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INPID_PreviewControl = "AngleControl",
    --INP_MinAllowed =   0.0,
    INP_MinScale = 0.0,
	  INP_MaxScale = 360.0,
    INP_Default = 0.0,
    ACID_Center = "Center",
    --PC_GrabPriority = 1 -- give this a higher priority than the rectangle
    })
  InPivot = self:AddInput("Pivot", "Pivot", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INPID_PreviewControl = "CrosshairControl",
    CHC_Style = "DiagonalCross",
    PC_GrabPriority = -1,
    })
  InWidgets = self:AddInput("On-Screen Widgets", "OnScreen Widgets", {
    LINKID_DataType = "Number",
    INPID_InputControl = "MultiButtonControl",
    INP_Default = 0,
    INP_Integer = true,
    INP_External        = false,
	INP_Passive         = true,
    INP_DoNotifyChanged = true,
    MBTNC_ForceButtons = true,
    MBTNC_StretchToFit = true,
    { MBTNC_AddButton = "Show", },
    { MBTNC_AddButton = "Hide", },
  })


  Sep2 = self:AddInput(string.rep("_", 52), "Separator2", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })

  InFrequency = self:AddInput("Frequency", "Frequency", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 1.0,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    })

  InStop = self:AddInput("Stop", "Stop", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
	INP_Integer = true,
    INP_DoNotifyChanged = true,
    INP_Default         = 0,
    IC_Visible          = true,
    --INP_External        = false,
  })
  InStartStop = self:AddInput("", "StartStop", {
    { MBTNC_AddButton = "Stop", MBTNCID_AddID = "StopAnimation", },
    { MBTNC_AddButton = "Start", MBTNCID_AddID = "StartAnimation", },
    INPID_DefaultID = "StartAnimation",
    LINKID_DataType = "FuID",
    INPID_InputControl = "MultiButtonIDControl",
    ICD_Width = 1.0,
    MBTNC_StretchToFit = true,
    MBTNC_ForceButtons = true,
    INP_DoNotifyChanged  = true,
    IC_Visible = false,
    --INP_External = false,
  })


  InActtime = self:AddInput("Acttime", "Acttime", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.0,
	  IC_Visible          = false,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    })

  InTimeoffset = self:AddInput("Timeoffset", "Timeoffset", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.0,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    })

self:BeginControlNest("Parameter", "Par", true, {})
  InObjID = self:AddInput("Material", "Material", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
	{ CCS_AddString  = "Default", },
    { CCS_AddString  = "Wood", },
	{ CCS_AddString  = "Metal", },
    { CCS_AddString  = "Gold", },
    CC_LabelPosition = "Horizontal",
	})

  InStaticDrops = self:AddInput("Static Drops","StaticDrops", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged = false,
    INP_DefaultX = -0.5,
    INP_DefaultY = 1,
    XF_XAxis = -1,
    XF_YAxis = -1,
    XF_XSize = 1,
    XF_YSize = 1,
    XF_Angle = 0,
    XF_EdgeMode = "Black"
    })

 InLook = self:AddInput("Look","Look", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged = false,
    INP_DefaultX = 0.0,
    INP_DefaultY = 0.0,
    XF_XAxis = -1,
    XF_YAxis = -1,
    XF_XSize = 1,
    XF_YSize = 1,
    XF_Angle = 0,
    XF_EdgeMode = "Black"
    })
  InLookZ = self:AddInput("LookZ", "LookZ", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.0,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    })

 InRedCH = self:AddInput("Red", "RedCH", {
    ICS_Name            = "Line Color",
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.42,
    INP_MaxScale        = 0.5,
    CLRC_ShowWheel      = false,
    IC_ControlGroup     = 1,
    IC_ControlID        = 0,
  })
  InGreenCH = self:AddInput("Green", "GreenCH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.32,
    IC_ControlGroup     = 1,
    IC_ControlID        = 1,
  })
  InBlueCH = self:AddInput("Blue", "BlueCH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.12,
    IC_ControlGroup     = 1,
    IC_ControlID        = 2,
  })

  InRed2CH = self:AddInput("Red", "Red2CH", {
    ICS_Name            = "Color1",
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.7,
    INP_MaxScale        = 0.5,
    CLRC_ShowWheel      = false,
    IC_ControlGroup     = 2,
    IC_ControlID        = 0,
  })
  InGreen2CH = self:AddInput("Green", "Green2CH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.3,
    IC_ControlGroup     = 2,
    IC_ControlID        = 1,
  })
  InBlue2CH = self:AddInput("Blue", "Blue2CH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.1,
    IC_ControlGroup     = 2,
    IC_ControlID        = 2,
  })


self:EndControlNest()

InLogoSw = self:AddInput("Logo", "LogoSw", {
  LINKID_DataType = "Number",
  INPID_InputControl = "CheckboxControl",
  INP_Integer = true,
  INP_DoNotifyChanged = true,
  INP_Default         = 1,
  IC_Visible          = true,
  INP_External        = false,
  INP_Passive         = true,
})

  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
	{ CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	{ CCS_AddString  = "Image1", },
    { CCS_AddString  = "1920x1080", },
	{ CCS_AddString  = "1200x675", },
	{ CCS_AddString  = "800x450", },
	{ CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	ICS_ControlPage  = "Image",
  })

  	InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})


  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
	{ CCS_AddString  = "Default", },
	{ CCS_AddString  = "int8", },
	{ CCS_AddString  = "int16", },
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
	ICS_ControlPage  = "Image",
  })

    InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false })

self:AddControlPage("Image")
InGlobalIn = self:AddInput("Global In", "GlobalIn", {
  LINKID_DataType     = "Number",
})
InGlobalOut = self:AddInput("Global Out", "GlobalOut", {
  LINKID_DataType     = "Number",
})

--------------------------------------------
 ShaderFuse.end_create()
--------------------------------------------
------------------- In/Out -----------------
  InImage1 = self:AddInput("Image", "Image", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
	--LINK_Visible = false,
    INP_Required = false
  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
  })
end


-------------------------------------------------------------------
--       NotifyChanged
-------------------------------------------------------------------
function NotifyChanged(inp, param, time)


  if inp ~= nil and param ~= nil then

    if inp == InCenter then
        -- the center moved, reposition the axis according to the current offset
        nCenterX = param.X
        nCenterY = param.Y

        InPivot:SetAttrs({
            PCD_OffsetX = nCenterX - 0.5,
            PCD_OffsetY = nCenterY - 0.5,
            })

        InAngle:SetAttrs({
            PCD_OffsetX = (nCenterX - 0.5)/100,
            PCD_OffsetY = (nCenterY - 0.5)/100,
            })
    end
    if inp == InWidgets then
      if param.Value == 1.0 then
         InCenter:SetAttrs({ PC_Visible = false })
         InAngle:SetAttrs({ PC_Visible = false })
         InPivot:SetAttrs({ PC_Visible = false })
         InScale:SetAttrs({ PC_Visible = false })
      else
         InCenter:SetAttrs({ PC_Visible = true })
         InAngle:SetAttrs({ PC_Visible = true })
         InPivot:SetAttrs({ PC_Visible = true })
         InScale:SetAttrs({ PC_Visible = true })
      end
    end

		if inp == InSize then
		  if param.Value == 1 then
			 InWidth:SetAttrs({ IC_Visible = true })
			 InHeight:SetAttrs({ IC_Visible = true })
		  else
			 InWidth:SetAttrs({ IC_Visible = false })
			 InHeight:SetAttrs({ IC_Visible = false })
		  end

		  if param.Value == 3 then --1920x1080
			 InWidth:SetSource(Number(1920),0,0)
			 InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			 InWidth:SetSource(Number(1200),0,0)
			 InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			 InWidth:SetSource(Number(800),0,0)
			 InHeight:SetSource(Number(450),0,0)
		  end
 	      if param.Value == 6 then --640x360
		     InWidth:SetSource(Number(640),0,0)
			 InHeight:SetSource(Number(360),0,0)
		  end
		end

    if inp == InStop then
      if param.Value == 1 then
	     InActtime:SetAttrs({IC_Visible = true})
	  else
	     InActtime:SetAttrs({IC_Visible = false})
	  end
	end

	if inp == InLogoSw then
	  if param.Value == 1 then
		 --authorlogo:SetAttrs({IC_Visible = true})
	  else
		 --authorlogo:SetAttrs({IC_Visible = false})
	  end
	end
  end
end

-------------------------------------------------------------------
--       Process
-------------------------------------------------------------------
function Process(req)
    local center = InCenter:GetValue(req)
    local angle = -InAngle:GetValue(req).Value/360*3.1415*2
    local debug = InDebug:GetValue(req).Value
    local scale = InScale:GetValue(req).Value
    local freq = InFrequency:GetValue(req).Value
    local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate") -- get the frame rate of the comp set in the preferences

	-- Imagesize and Depth
    if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InImage1:GetValue(req) ~= nil) then
			   Width = InImage1:GetValue(req).Width
			   Height = InImage1:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value
		end
	end

	if (InDepth:GetValue(req).Value > 0) then
	if InDepth:GetValue(req).Value == 1 then
	    SourceDepth = 5
    else
	    if InDepth:GetValue(req).Value == 2 then
	        SourceDepth = 6
	    else
	        if InDepth:GetValue(req).Value == 3 then
		       SourceDepth = 7
			else
			   SourceDepth = 8
	        end
		end
	end
	end


    --This creates an image for us to work on.
    local imgattrs = {
        IMG_Document = self.Comp,
        { IMG_Channel = "Red", },
        { IMG_Channel = "Green", },
        { IMG_Channel = "Blue", },
        { IMG_Channel = "Alpha", },
        IMG_Width = Width,
        IMG_Height = Height,
        IMG_XScale = XAspect,
        IMG_YScale = YAspect,
        IMAT_OriginalWidth = realwidth,
        IMAT_OriginalHeight = realheight,
        IMG_Quality = not req:IsQuick(),
        IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
        }

    if not req:IsStampOnly() then
        imgattrs.IMG_ProxyScale = 1
    end

    if SourceDepth ~= 0 then
        imgattrs.IMG_Depth = SourceDepth
    end

	src = Image(imgattrs)

    local p = Pixel({R=0,G=0,B=0,A=0})

	tex = false
    if (InImage1:GetValue(req) ~= nil) then
        src1 = InImage1:GetValue(req)
		tex = true
    else
        src1 = Image(imgattrs)
        src1:Fill(p)
      end

    local dst = Image {IMG_Like = src1, IMG_DeferAlloc = true}

    if (tex) then
		InRedCH:SetAttrs({ PC_Visible = false })
		InRed2CH:SetAttrs({ PC_Visible = false })
    else
		InRedCH:SetAttrs({ PC_Visible = true })
		InRed2CH:SetAttrs({ PC_Visible = true })
    end

    if req:IsPreCalc() then
	   --print("\n######################### Precalc ##############################\n")
	   local out = Image({IMG_Like = dst, IMG_NoData = true})
       OutImage:Set(req, out)
	   return
	end



    --StartStop
    if InStop:GetValue(req).Value == 0 then
	   _acttime = req.Time + InTimeoffset:GetValue(req).Value
	   startstopsema = 1
	else
	   if startstopsema == 1 then
	      InActtime:SetSource(Number(req.Time),0)
	      startstopsema = 0
	      _acttime = req.Time + InTimeoffset:GetValue(req).Value
	   else
	      _acttime = InActtime:GetValue(req).Value + InTimeoffset:GetValue(req).Value
	   end
	end

    acttime = _acttime / framerate


    --Sep1:SetAttrs({LINKS_Name = "____________FractalFlythrough______________________",LBLC_LabelColor = 3,})

    node = DVIPComputeNode(req, "FractalFlythroughKernel", FractalFlythroughKernel, "FractalFlythroughParams", FractalFlythroughParams)

    if not pcall(function ()
        params.center[0] = center.X
        params.center[1] = center.Y
	    params.scale = 1/scale
        params.angle = angle
        params.pivot[0] = InPivot:GetValue(req).X
        params.pivot[1] = InPivot:GetValue(req).Y
        params.debug = debug
        params.freq = freq
		params.tex  = tex

        params.objID       = InObjID:GetValue(req).Value
        params.look        = {InLook:GetValue(req).X,InLook:GetValue(req).Y,InLookZ:GetValue(req).Value}
        params.color       = {InRedCH:GetValue(req).Value, InGreenCH:GetValue(req).Value, InBlueCH:GetValue(req).Value}
		params.color2      = {InRed2CH:GetValue(req).Value, InGreen2CH:GetValue(req).Value, InBlue2CH:GetValue(req).Value}

        params.compOrder = src1:IsMask() and 1 or 15
        params.width  = src1.DataWindow:Width()
        params.height = src1.DataWindow:Height()

        params.itime = acttime --req.Time / framerate

        node:SetParamBlock(params)
    end) then
        params = node:GetParamBlock(FractalFlythroughParams)

        params.center[0] = center.X
        params.center[1] = center.Y
	    params.scale = 1/scale
        params.angle = angle
        params.pivot[0] = InPivot:GetValue(req).X
        params.pivot[1] = InPivot:GetValue(req).Y
        params.debug = debug
        params.freq = freq
		params.tex  = tex

        params.objID       = InObjID:GetValue(req).Value
        params.look        = {InLook:GetValue(req).X,InLook:GetValue(req).Y,InLookZ:GetValue(req).Value}
        params.color       = {InRedCH:GetValue(req).Value, InGreenCH:GetValue(req).Value, InBlueCH:GetValue(req).Value}
		params.color2      = {InRed2CH:GetValue(req).Value, InGreen2CH:GetValue(req).Value, InBlue2CH:GetValue(req).Value}

        params.compOrder = src1:IsMask() and 1 or 15
        params.width  = src1.DataWindow:Width()
        params.height = src1.DataWindow:Height()

        params.itime = acttime  --req.Time / framerate

        node:SetParamBlock(params)

    end

    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_WRAP, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_DUPLICATE, TEX_NORMALIZED_COORDS_TRUE)
     node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)

    node:AddInput("iChannel0", src1)
    node:AddOutput("dst", dst)

    local success = node:RunSession(req)
    if not success then
        dst = nil
        dump(node:GetErrorLog()) -- Fehlerausgabe des DCTL
    end

    OutImage:Set(req, dst)
	collectgarbage();
end

-- **/ "End of LUA CODE"

