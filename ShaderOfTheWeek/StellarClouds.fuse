--[[--/*

  StellarClouds.fuse

  Based on https://www.shadertoy.com/view/DtdSz7 a WebGL shader created by alro.
  Converted to DCTL and embeddet into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT).
  Place this file in your Fusion's and/or DaVinci Resolve's 'Fuses/' folder to use it.

*/--]]--




-- /*
local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()



-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,
  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  })



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------

-- */
ShaderParameters =
[[

  float  iResolution[2];
  float  iTime;
  float  iMouse[4];
  int    iFrame;
  bool   Reset;
  float  ColorBKG[4];
  float  SigmaS;
  float  SigmaA1;
  float  SigmaA2;
  float  SigmaE1;
  float  SigmaE2;
  float  ViewXY[2];
  float  ViewZ;
  float  SunLocation;
  float  SunHeight;
  float  fbmScale;

  int    width,height;
  int    compOrder;

]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel compatibility code
-- // ------------------------------------------------------------------------

-- */
ShaderCompatibilityCode =
[[


#if defined(DEVICE_IS_METAL)
  #define in
  #define out thread
  #define inout thread
#else
  #define in
  #define out
  #define inout
#endif

#undef USE_NATIVE_METAL_IMPL
#undef USE_NATIVE_CUDA_IMPL
#undef USE_NATIVE_OPENCL_IMPL

  // 0 to use the generic implementations; 1 for Metal, OpenCL, Cuda specific code if existing

  #if 1
    #if defined(DEVICE_IS_METAL)
      #define USE_NATIVE_METAL_IMPL   1
    #elif defined(DEVICE_IS_CUDA)
      #define USE_NATIVE_CUDA_IMPL    1
    #elif defined(DEVICE_IS_OPENCL)
      #define USE_NATIVE_OPENCL_IMPL  1
    #endif
  #endif

  #if defined(USE_NATIVE_METAL_IMPL)

    #define swi2(A,a,b)     (A).a##b
    #define swi3(A,a,b,c)   (A).a##b##c

  #else

    #define swi2(A,a,b)     to_float2((A).a,(A).b)
    #define swi3(A,a,b,c)   to_float3((A).a,(A).b,(A).c)

  #endif

// ----------------------------------------------------------------------------------------------------------
// mat3 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float3x3 mat3;

  __DEVICE__ inline mat3 to_mat3( float a, float b, float c, float d, float e, float f, float g, float h, float i)
  {
    return mat3(a,b,c,d,e,f,g,h,i);
  }

  __DEVICE__ inline mat3 to_mat3_f3( float3 a, float3 b, float3 c ) { return mat3(a,b,c); }
  __DEVICE__ inline float3 mul_mat3_f3( mat3 B, float3 A) { return (B*A); }
  __DEVICE__ inline float3 mul_f3_mat3( float3 A, mat3 B) { return (A*B); }

#else

  typedef struct { float3 r0; float3 r1; float3 r2; } mat3;

  __DEVICE__ inline mat3 to_mat3( float  a, float  b, float c,   float d, float e, float f,   float g, float h, float i)
  {
    mat3 t;
    t.r0.x = a; t.r0.y = b; t.r0.z = c;
    t.r1.x = d; t.r1.y = e; t.r1.z = f;
    t.r2.x = g; t.r2.y = h; t.r2.z = i;
    return t;
  }

  __DEVICE__ inline mat3 to_mat3_f3( float3 A, float3 B, float3 C)
  {
    mat3 D;
    D.r0 = A;
    D.r1 = B;
    D.r2 = C;
    return D;
  }

__DEVICE__ inline float3 mul_mat3_f3( mat3 B, float3 A) {
    float3 C;

    C.x = A.x * B.r0.x + A.y * B.r1.x + A.z * B.r2.x;
    C.y = A.x * B.r0.y + A.y * B.r1.y + A.z * B.r2.y;
    C.z = A.x * B.r0.z + A.y * B.r1.z + A.z * B.r2.z;
    return C;
  }

__DEVICE__ inline float3 mul_f3_mat3( float3 A, mat3 B) {
    float3 C;

    C.x = A.x * B.r0.x + A.y * B.r0.y + A.z * B.r0.z;
    C.y = A.x * B.r1.x + A.y * B.r1.y + A.z * B.r1.z;
    C.z = A.x * B.r2.x + A.y * B.r2.y + A.z * B.r2.z;
    return C;
  }

#endif // end of mat3 implementation

#if defined(USE_NATIVE_METAL_IMPL)

 #define fract_f3(A) fract(A)

 #define mod_f(a,b)  fmod((a),(b))

 #define sin_f3(i) sin(i)
 #define cos_f3(i) cos(i)
 #define exp_f3(a) _expf((a))
 #define pow_f3(a,b) pow(a,b)

#else

  #if defined(USE_NATIVE_OPENCL_IMPL)

    #define reflect(I,N) (I-2.0f*dot(N,I)*N)

    #define fract(a) ((a)-_floor(a))  // oder Pointer bauen: gentype fract(gentype x, gentype *itpr)

 #define fract_f3(A) to_float3(fract((A).x),fract((A).y),fract((A).z))
 #define mod_f(a,b) _fmod(a,b)
 #define sin_f3(i) sin(i)
 #define cos_f3(i) cos(i)
 #define exp_f3(a) _expf((a))
 #define pow_f3(a,b) pow(a,b)

 #else // Generic

 #if defined(DEVICE_IS_CUDA)
   #define radians(a) a * M_PI/180.0f
 #endif

    #define fract(a) ((a)-_floor(a))

 #define fract_f3(A) to_float3(fract((A).x),fract((A).y),fract((A).z))
 #define mod_f(a,b) ((a)-(b)*_floor((a)/(b)))
 #define sin_f3(i) to_float3( _sinf((i).x), _sinf((i).y), _sinf((i).z))
 #define cos_f3(i) to_float3( _cosf((i).x), _cosf((i).y), _cosf((i).z))
 #define exp_f3(a) to_float3(_expf((a).x), _expf((a).y),_expf((a).z))
 #define pow_f3(a,b) to_float3(_powf((a).x,(b).x),_powf((a).y,(b).y),_powf((a).z,(b).z))

  #endif

#endif

#define to_float4_f2f2(A,B) to_float4((A).x,(A).y,(B).x,(B).y ) // or is there some to_float_..() for that?!? - No - that is missing in DCTL :-) but now we have "one"


]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel implementation
-- // ------------------------------------------------------------------------

-- */
ShaderKernelCode =
[[

// ----------------------------------------------------------------------------------
// - Common                                                                         -
// ----------------------------------------------------------------------------------

#define texture(ch,uv) _tex2DVecN(ch, (uv).x, (uv).y, 15)
/*
    Copyright (c) 2023 al-ro

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#define PI 3.14159f
#define TWO_PI (2.0f * PI)

// Variable iterator initializer to stop loop unrolling
#define ZERO 0 //(_fminf(iFrame,0))

__DEVICE__ float __saturatef(float x){
  return clamp(x, 0.0f, 1.0f);
}

// ----------------------------------------------------------------------------------
// - Buffer A                                                                       -
// ----------------------------------------------------------------------------------
// Connect Buffer A 'Previsualization: Buffer A' to iChannel0


//Track mouse movement and resolution change between frames and set camera position.

#define CAMERA_DIST 0.01f

__KERNEL__ void StellarCloudsFuse__Buffer_A(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  int    iFrame      = params->iFrame;
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  bool   Reset = params->Reset;
  float4 ColorBKG = to_float4(params->ColorBKG[0], params->ColorBKG[1], params->ColorBKG[2], params->ColorBKG[3]);
  float  SigmaS = params->SigmaS;
  float  SigmaA1 = params->SigmaA1;
  float  SigmaA2 = params->SigmaA2;
  float  SigmaE1 = params->SigmaE1;
  float  SigmaE2 = params->SigmaE2;
  float2 ViewXY = to_float2(params->ViewXY[0], params->ViewXY[1]);
  float  ViewZ = params->ViewZ;
  float  SunLocation = params->SunLocation;
  float  SunHeight = params->SunHeight;
  float  fbmScale = params->fbmScale;

  // --------

    fragCoord+=0.5f;

    //Work with just the first four pixels.
    if((fragCoord.x == 0.5f) && (fragCoord.y < 4.0f)){

        float4 oldData = texture(iChannel0, (make_float2((int)0.5f,(int)0.5f)+0.5f)/iResolution);

        float2 oldPolarAngles = swi2(oldData,x,y);
        float2 oldMouse = swi2(oldData,z,w);

        float2 polarAngles = to_float2_s(0);
        float2 mouse = swi2(iMouse,x,y) / iResolution;

        // Stop camera going directly above and below
        float angleEps = 0.01f;

        float mouseDownLastFrame = texture(iChannel0, (make_float2((int)0.5f,(int)3.5f)+0.5f)/iResolution).x;

        // If mouse button is down and was down last frame.
        if(iMouse.z > 0.0f && mouseDownLastFrame > 0.0f){

            // Difference between mouse position last frame and now.
            float2 mouseMove = mouse - oldMouse;
            polarAngles = oldPolarAngles + to_float2(5.0f, 3.0f) * mouseMove;

        }else{
            polarAngles = oldPolarAngles;
        }

        polarAngles.x = mod_f(polarAngles.x, 2.0f * PI - angleEps);
        polarAngles.y = _fminf(PI - angleEps, _fmaxf(angleEps, polarAngles.y));

        // Store mouse data in the first pixel of Buffer A.
        //if(fragCoord == to_float2(0.5f, 0.5f)){
        if(fragCoord.x == 0.5f && fragCoord.y == 0.5f){
            // Set value at first frames.
            if(iFrame < 1 || Reset){
                polarAngles = to_float2(-1.96f, 2.0f);
                mouse = to_float2_s(0);
            }
            fragColor = to_float4_f2f2(polarAngles, mouse);
        }

        // Store camera position in the second pixel of Buffer A.
        //if(fragCoord == to_float2(0.5f, 1.5f)){
        if(fragCoord.x == 0.5f && fragCoord.y == 1.5f){
            // Cartesian direction from polar coordinates.
            float3 cameraPos = normalize(to_float3(-_cosf(polarAngles.x) * _sinf(polarAngles.y), _cosf(polarAngles.y), -_sinf(polarAngles.x) * _sinf(polarAngles.y)));

            fragColor = to_float4_aw(CAMERA_DIST * cameraPos, 1.0f);
        }

        //Store resolution change data in the third pixel of Buffer A.
        //if(fragCoord == to_float2(0.5f, 2.5f)){
        if(fragCoord.x == 0.5f && fragCoord.y == 2.5f){
            float resolutionChangeFlag = 0.0f;
            //The resolution last frame.
            float2 oldResolution = swi2(texture(iChannel0, (make_float2((int)0.5f,(int) 2.5f)+0.5f)/iResolution),y,z);

            //if(iResolution != oldResolution){
            if(iResolution.x != oldResolution.x || iResolution.y != oldResolution.y){
              resolutionChangeFlag = 1.0f;
            }

          fragColor = to_float4(resolutionChangeFlag, iResolution.x, iResolution.y, 1.0f);
        }

        //Store whether the mouse button is down in the fourth pixel of Buffer A
        //if(fragCoord == to_float2(0.5f, 3.5f)){
        if(fragCoord.x == 0.5f && fragCoord.y == 3.5f){
            if(iMouse.z > 0.0f){
              fragColor = to_float4_aw(to_float3_s(1.0f), 1.0f);
            }else{
              fragColor = to_float4_aw(to_float3_s(0.0f), 1.0f);
            }
        }
    }

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
// ----------------------------------------------------------------------------------
// - Buffer B                                                                       -
// ----------------------------------------------------------------------------------
// Connect Buffer B 'Previsualization: Buffer A' to iChannel0
// Connect Buffer B 'Previsualization: Buffer B' to iChannel1
// Connect Buffer B 'Texture: Blue Noise' to iChannel2


/*
    Volumetric clouds with gyroid noise
    See https://www.shadertoy.com/view/3sffzj for more detailed comments on clouds.
*/

// Different step counts for full and interactive states
#define STEPS_PRIMARY 75
#define STEPS_PRIMARY_LOW 7

#define STEPS_LIGHT 32
#define STEPS_LIGHT_LOW 7

// Offset the sample point by blue noise to get rid of banding
#define DITHERING
#define goldenRatio 1.61803398875f

// Scattering coefficient based on Earth's atmosphere but tweaked for this look
        const float3 BETA_RAYLEIGH = {100.0f*0.05802f, 100.0f*0.14558f, 100.0f*0.331f};
const float3 BETA_OZONE = {0.650f, 1.881f, 0.085f};



// Main light power
const float power = 200.0f;

// For size of AABB
#define CLOUD_EXTENT 10.0f
const float3 minCorner = {-CLOUD_EXTENT, -CLOUD_EXTENT, -CLOUD_EXTENT};
const float3 maxCorner = {CLOUD_EXTENT, CLOUD_EXTENT, CLOUD_EXTENT};

//-------------------------------- Camera --------------------------------

__DEVICE__ float3 rayDirection(float fieldOfView, float2 fragCoord, float2 iResolution) {
    float2 xy = fragCoord - iResolution / 2.0f;
    float z = (0.5f * iResolution.y) / _tanf(radians(fieldOfView) / 2.0f);
    return normalize(to_float3_aw(xy, -z));
}

// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/
__DEVICE__ mat3 lookAt(float3 targetDir, float3 up){
  float3 zaxis = normalize(targetDir);
  float3 xaxis = normalize(cross(zaxis, up));
  float3 yaxis = cross(xaxis, zaxis);

  return to_mat3_f3(xaxis, yaxis, -zaxis);
}

//-------------------------------- Intersection --------------------------------

// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d
// Compute the near and far intersections using the slab method.
// No intersection if tNear > tFar.
__DEVICE__ float2 intersectAABB(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax) {

    float3 tMin = (boxMin - rayOrigin) / rayDir;
    float3 tMax = (boxMax - rayOrigin) / rayDir;
    float3 t1 = _fminf(tMin, tMax);
    float3 t2 = _fmaxf(tMin, tMax);
    float tNear = _fmaxf(max(t1.x, t1.y), t1.z);
    float tFar = _fminf(min(t2.x, t2.y), t2.z);
    return to_float2(tNear, tFar);
}

__DEVICE__ bool insideAABB(float3 p){
  float eps = 1e-4f;
  return  (p.x > minCorner.x-eps) && (p.y > minCorner.y-eps) && (p.z > minCorner.z-eps) &&
          (p.x < maxCorner.x+eps) && (p.y < maxCorner.y+eps) && (p.z < maxCorner.z+eps);
}

__DEVICE__ bool getCloudIntersection(float3 org, float3 dir, out float *distToStart, out float *totalDistance){
  float2 intersections = intersectAABB(org, dir, minCorner, maxCorner);

    if(insideAABB(org)){
        intersections.x = 1e-4;
    }

    *distToStart = intersections.x;
    *totalDistance = intersections.y - intersections.x;
    return intersections.x > 0.0f && (intersections.x < intersections.y);
}

// https://www.shadertoy.com/view/3s3GDn
__DEVICE__ float getGlow(float dist, float radius, float intensity){
  return _fmaxf(0.0f, _powf(radius/_fmaxf(dist, 1e-5f), intensity));
}

//-------------------------------- Random --------------------------------

// https://www.shadertoy.com/view/4djSRW
__DEVICE__ float3 hash(float3 p3){
    p3 = fract_f3(p3 * to_float3(0.1031f, 0.1030f, 0.0973f));
    p3 += dot(p3, swi3(p3,y,x,z) + 33.33f);
    return 2.0f * fract_f3((swi3(p3,x,x,y) + swi3(p3,y,x,x)) * swi3(p3,z,y,x)) - 1.0f;
}

//-------------------------------- Shape --------------------------------

// https://en.wikipedia.org/wiki/Gyroid
// https://www.shadertoy.com/view/wddfDM
__DEVICE__ float gyroid(float3 p, float thickness, float bias, float frequency){
    return clamp(_fabs(dot(sin_f3(p*0.5f), cos_f3(swi3(p,z,x,y)*1.23f) * frequency) - bias) - thickness, 0.0f, 3.0f)/3.0f;
}

__DEVICE__ inline mat3 mul_mat3_f( mat3 A, float B)
  {
  return to_mat3_f3(A.r0 * B, A.r1 * B, A.r2 * B);
  }

// Gyroid noise based on https://www.shadertoy.com/view/3l23Rh
__DEVICE__ float fbm(float3 p, float fbmScale){

    const int octaves = 12;
    //const float fbmScale = 1.95f;

    // Rotation of the gyroid every iteration to produce a noise look
    const float a = PI / (float)(octaves);
    //const mat3 m3 = fbmScale * to_mat3(_cosf(a), _sinf(a), 0, -_sinf(a), _cosf(a), 0, 0, 0, 1);
    const mat3 m3 = mul_mat3_f(to_mat3(_cosf(a), _sinf(a), 0, -_sinf(a), _cosf(a), 0, 0, 0, 1),fbmScale);


    float weight = 0.0f;
    float amplitude = 1.0f;
    float frequency = 1.0f;
    float res = 0.0f;


    //for(int i = _fminf(0, iFrame); i < octaves; i++){
      for(int i = 0; i < octaves; i++){
        res += amplitude * gyroid(p, 0.1f, 0.0f, frequency);
        p = mul_f3_mat3(p,m3);
        weight += amplitude;
        amplitude *= (i < 4 ? 0.9f : 0.7f);
        frequency *= (i < 3 ? 0.65f : 0.78f);
    }

    return __saturatef(res / weight);
}

__DEVICE__ float clouds(float3 p, float fbmScale){
    if(!insideAABB(p)){
        return 0.0f;
    }
    float noise = fbm(0.25f*p, fbmScale);
    float structure = smoothstep(3.0f, 5.0f, length(p)) * smoothstep(0.05f, 0.1f, noise);
    float haze = smoothstep(2.0f, 10.0f, length(p)) * smoothstep(0.02f, 0.5f, noise);
    return 3e-4f+(0.5f*haze + 0.75f * structure);

}


//-------------------------------- Stars --------------------------------

// https://iquilezles.org/articles/palettes/
__DEVICE__ float3 getColour(float t){
    float3 a = to_float3_s(0.65f);
    float3 b = 1.0f - a;
    float3 c = to_float3(1.0f,1.0f,1.0f);
    float3 d = to_float3(0.15f,0.5f,0.75f);

    return pow_f3(a + b * cos_f3(TWO_PI * (c * t + d)), to_float3_s(2.2f));
}


// Stars with random placement and strength
__DEVICE__ float3 getStars(float3 p){
    p *= 0.3f;
    float3 rand;
    float d = 1e10;

    for(int x = -1; x <= 1; x++){
        for(int y = -1; y <= 1; y++){
            for(int z = -1; z <= 1; z++){
                float3 cell = _floor(p) + to_float3(x, y, z);
                float3 h = hash(cell);
                float3 f = cell + 0.5f * h;
                float dd = length(p - f);
                if(dd < d){
                    d = dd;
                    rand = h;
                }
            }
        }
    }
    rand = clamp(0.5f + 0.5f * rand, 0.0f, 1.0f);
    return to_float3_s(0.05f) * rand.z * step(0.7f, rand.y) * _mix(to_float3_s(1), getColour(rand.x), 0.5f) * smoothstep(0.5f, 0.0f, d) * getGlow(d, 0.25f, 2.0f);
}

//-------------------------------- Lighting --------------------------------

__DEVICE__ float HenyeyGreenstein(float g, float costh){
  return (1.0f / (4.0f * 3.1415f))  * ((1.0f - g * g) / _powf(1.0f + g*g - 2.0f*g*costh, 1.5f));
}

// https://twitter.com/FewesW/status/1364629939568451587/photo/1
__DEVICE__ float3 multipleOctaves(float extinction, float mu, float stepL, float3 sigmaE){

    float3 luminance = to_float3_s(0);
    const float octaves = 6.0f;

    // Attenuation
    float a = 1.0f;
    // Contribution
    float b = 1.0f;
    // Phase attenuation
    float c = 1.0f;

    float phase;

    for(float i = 0.0f; i < octaves; i++){
        // Two-lobed HG
        phase = _mix(HenyeyGreenstein(-0.1f * c, mu), HenyeyGreenstein(0.3f * c, mu), 0.7f);
        luminance += b * phase * exp_f3(-stepL * extinction * sigmaE * a);
        // Lower is brighter
        a *= 0.3f;
        // Higher is brighter
        b *= 0.5f;
        c *= 0.5f;
    }
    return luminance;
}

// Get the amount of light that reaches a sample point.
__DEVICE__ float3 lightRay(float3 org, float3 p, float phaseFunction, float mu, float3 sunDirection, bool low, float3 sigmaE, float fbmScale){

  float lightRayDistance = CLOUD_EXTENT*0.25f;
  float distToStart = 0.0f;

  getCloudIntersection(p, sunDirection, &distToStart, &lightRayDistance);

  float stepL = lightRayDistance/(float)(low ? STEPS_LIGHT_LOW : STEPS_LIGHT);

  float lightRayDensity = 0.0f;

  // Collect total density along light ray.
  for(int j = 0; j < (low ? STEPS_LIGHT_LOW : STEPS_LIGHT); j++){
    lightRayDensity += clouds(p + sunDirection * (float)(j) * stepL, fbmScale);
  }

  float3 beersLaw = multipleOctaves(lightRayDensity, mu, stepL, sigmaE);

    // Return product of Beer's law and powder effect depending on the
    // view direction angle with the light direction.
  return _mix(beersLaw * 2.0f * (1.0f - (exp_f3( -stepL * lightRayDensity * 2.0f * sigmaE))),
              beersLaw,
              0.5f + 0.5f * mu);
}


//-------------------------------- Raymarching --------------------------------

// Get the colour along the main view ray.
__DEVICE__ float3 mainRay(float3 org, float3 dir, float3 sunDirection, out float3 *totalTransmittance, float offset, bool low, float3 sigmaE, float3 sigmaS, float fbmScale){

  // Variable to track transmittance along view ray.
    // Assume clear sky and attenuate light when encountering clouds.
  *totalTransmittance = to_float3_s(1.0f);

  // Default to black.
  float3 colour = to_float3_s(0.0f);

  // The distance at which to start ray marching.
  float distToStart = 0.0f;

  // The length of the intersection.
  float totalDistance = 0.0f;

  // Determine if ray intersects bounding volume.
  // Set ray parameters in the cloud layer.
  bool renderClouds = getCloudIntersection(org, dir, &distToStart, &totalDistance);

  if(!renderClouds){
    return colour;
  }

  // Sampling step size.
  float stepS = totalDistance / (float)(low ? STEPS_PRIMARY_LOW : STEPS_PRIMARY);

  // Offset the starting point by blue noise.
  distToStart += stepS * offset;

  // Track distance to sample point.
  float dist = distToStart;

  // Initialise sampling point.
  float3 p = org + dist * dir;

  float mu = dot(dir, sunDirection);
  // Combine backward and forward scattering to have details in all directions.
  float phaseFunction = _mix(HenyeyGreenstein(-0.3f, mu), HenyeyGreenstein(0.3f, mu), 0.7f);

  float3 sunLight = to_float3_s(1) * power;

  for(int i = 0; i < (low ? STEPS_PRIMARY_LOW : STEPS_PRIMARY); i++){

      float density = clouds(p, fbmScale);

      float3 sampleSigmaS = sigmaS * density;
      float3 sampleSigmaE = sigmaE * density;

      // If there is a cloud at the sample point.
      if(density > 0.0f ){

          // Stars in the clouds
          float3 ambient = 4.0f*getStars(p) +
                         2.0f*getStars(2.5f*p) +
                         1.0f*getStars(3.4f*p) +
                         getStars(3.7f*p);

          // Scale starlight by the density at the sample point
          ambient *= smoothstep(1e-3f, 2e-3f, density);

          // Amount of sunlight that reaches the sample point through the cloud
          // is the combination of ambient light and attenuated direct light.
          float3 luminance = ambient + sunLight * phaseFunction * lightRay(org, p, phaseFunction, mu, sunDirection, low, sigmaE, fbmScale);

          // Scale light contribution by density of the cloud.
          luminance *= sampleSigmaS;

          // Beer-Lambert.
          float3 transmittance = exp_f3(-sampleSigmaE * stepS);

          // Better energy conserving integration
          // "From Physically based sky, atmosphere and cloud rendering in Frostbite" 5.6
          // by Sebastian Hillaire.
          colour += *totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE;

          // Attenuate the amount of light that reaches the camera.
          *totalTransmittance *= transmittance;

          // If ray combined transmittance is close to 0, nothing beyond this sample
          // point is visible, so break early.
          if(length(*totalTransmittance) <= 0.001f){
              *totalTransmittance = to_float3_s(0.0f);
              break;
          }
      }

      dist += stepS;

      // Step along ray.
      p = org + dir * dist;
    }

  return colour;
}

// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
__DEVICE__ float3 ACESFilm(float3 x){
    return clamp((x * (2.51f * x + 0.03f)) / (x * (2.43f * x + 0.59f) + 0.14f), 0.0f, 1.0f);
}

__KERNEL__ void StellarCloudsFuse__Buffer_B(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0,  __TEXTURE2D__ iChannel1,  __TEXTURE2D__ iChannel2, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  //float2 iChannelResolution[3];
  //iChannelResolution[0] = to_float2(params->iChannelResolution[0][0], params->iChannelResolution[0][1]);
  //iChannelResolution[1] = to_float2(params->iChannelResolution[1][0], params->iChannelResolution[1][1]);
  //iChannelResolution[2] = to_float2(params->iChannelResolution[2][0], params->iChannelResolution[2][1]);
  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  int    iFrame      = params->iFrame;
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  bool   Reset = params->Reset;
  float4 ColorBKG = to_float4(params->ColorBKG[0], params->ColorBKG[1], params->ColorBKG[2], params->ColorBKG[3]);
  float  SigmaS = params->SigmaS;
  float  SigmaA1 = params->SigmaA1;
  float  SigmaA2 = params->SigmaA2;
  float  SigmaE1 = params->SigmaE1;
  float  SigmaE2 = params->SigmaE2;
  float2 ViewXY = to_float2(params->ViewXY[0], params->ViewXY[1]);
  float  ViewZ = params->ViewZ;
  float  SunLocation = params->SunLocation;
  float  SunHeight = params->SunHeight;
  float  fbmScale = params->fbmScale;

  // --------

    fragCoord+=0.5f;

    // Scattering
    const float3 sigmaS = SigmaS*(BETA_RAYLEIGH);
    // Absorption
    const float3 sigmaA = SigmaA1*(BETA_RAYLEIGH + SigmaA2*BETA_OZONE);
    // Extinction
    const float3 sigmaE = SigmaE1*sigmaA + SigmaE2*sigmaS;

    float tileSize = iResolution.x < 2000.0f ? 256.0f : 128.0f;
    float framesToDraw = _ceil(iResolution.x / tileSize);

    float framesDrawn = texture(iChannel1, (make_float2((int)0.5f, (int)0.5f)+0.5f)/iResolution).x;
    bool blueNoiseNotLoaded = iResolution.x != 1024 || iResolution.y != 1024;
    bool resolutionChanged = texture(iChannel0, (make_float2((int)0.5f, (int)2.5f)+0.5f)/iResolution).x > 0.0f;

    bool renderPreview = resolutionChanged || blueNoiseNotLoaded || iFrame == 0 || iMouse.z > 0.0f;
    bool renderFull = framesDrawn < framesToDraw && !renderPreview;

    float tileStart = framesDrawn * tileSize;
    bool renderThisFrame = fragCoord.x > tileStart && fragCoord.x < tileStart + tileSize;

    float3 cameraPos = to_float3_s(0.0f);

    if(renderPreview || (renderFull && renderThisFrame)){

        //----------------- Define a camera -----------------

        // Get the default direction of the ray (along the negative Z direction)
        float3 rayDir = rayDirection(55.0f, fragCoord, iResolution);

        cameraPos = swi3(texture(iChannel0, (make_float2((int)0.5f,(int)1.5f)+0.5f)/iResolution),x,y,z);

        float3 targetDir = -cameraPos + to_float3_aw(ViewXY,ViewZ);

        float3 up = to_float3(0.0f, 1.0f, 0.0f);

        // Get the view matrix from the camera orientation
        mat3 viewMatrix = lookAt(targetDir, up);

        // Transform the ray to point in the correct direction
        rayDir = normalize(mul_mat3_f3(viewMatrix , rayDir));

        //---------------------------------------------------

        float sunLocation = -1.0f*SunLocation;
        float sunHeight = 0.5f*SunHeight;

        float3 sunDirection = normalize(to_float3(_cosf(sunLocation), sunHeight, _sinf(sunLocation)));

        float3 background = 0.05f * swi3(ColorBKG,x,y,z);//to_float3(0.09f, 0.33f, 0.81f);

        float mu = 0.5f+0.5f*dot(rayDir, sunDirection);
        background += getGlow(1.0f-mu, 0.00015f, 0.9f);

        float3 totalTransmittance = to_float3_s(1.0f);

        float offset = 0.0f;

        #ifdef DITHERING
        // Sometimes the blue noise texture is not immediately loaded into iChannel2
        // leading to jitters.
        //if(iChannelResolution[2].xy == to_float2(1024)){
          if(iResolution.x == 1024 && iResolution.y == 1024){
            // From https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/
            float blueNoise = texture(iChannel2, fragCoord / 1024.0f).x;
            offset = fract(blueNoise + (float)(iFrame%32) * goldenRatio);
        }
        #endif

        float3 col = mainRay(cameraPos, rayDir, sunDirection, &totalTransmittance, offset, renderPreview, sigmaE, sigmaS, fbmScale);

        col += background * totalTransmittance;

        // Tonemapping
        col = ACESFilm(col);
        // Gamma
        col = pow_f3(col, to_float3_s(0.4545f));

        fragColor = to_float4_aw(col, 1.0f);

    }else{
        float4 oldData = texture(iChannel1, (make_float2((int)fragCoord.x,(int)fragCoord.y)+0.5f)/iResolution);
        fragColor = oldData;
    }

    // Store the number of full resolution frames which have been drawn for the current view
    //if(fragCoord == to_float2(0.5f, 0.5f)){
    if(fragCoord.x == 0.5f && fragCoord.y == 0.5f){
        if(renderPreview){
            fragColor = to_float4_aw(to_float3_s(0.0f), 1.0f);
            fragColor = to_float4_aw(cameraPos, 1.5f);
        }else{
            fragColor = to_float4(framesDrawn + 1.0f, 0.0f, 0.0f, 10.0f);
        }
        
        fragColor = to_float4_aw(cameraPos, 1.5f);
    }

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
// ----------------------------------------------------------------------------------
// - Image                                                                          -
// ----------------------------------------------------------------------------------
// Connect Image 'Previsualization: Buffer A' to iChannel0
// Connect Image 'Previsualization: Buffer B' to iChannel1

/*
    Volumetric nebula rendered in tiles. Use mouse to move camera.
*/

__KERNEL__ void StellarCloudsFuse(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0,  __TEXTURE2D__ iChannel1, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  //float2 iChannelResolution[2];
  //iChannelResolution[0] = to_float2(params->iChannelResolution[0][0], params->iChannelResolution[0][1]);
  //iChannelResolution[1] = to_float2(params->iChannelResolution[1][0], params->iChannelResolution[1][1]);
  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  int    iFrame      = params->iFrame;
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  bool   Reset = params->Reset;
  float4 ColorBKG = to_float4(params->ColorBKG[0], params->ColorBKG[1], params->ColorBKG[2], params->ColorBKG[3]);
  float  SigmaS = params->SigmaS;
  float  SigmaA1 = params->SigmaA1;
  float  SigmaA2 = params->SigmaA2;
  float  SigmaE1 = params->SigmaE1;
  float  SigmaE2 = params->SigmaE2;
  float2 ViewXY = to_float2(params->ViewXY[0], params->ViewXY[1]);
  float  ViewZ = params->ViewZ;
  float  SunLocation = params->SunLocation;
  float  SunHeight = params->SunHeight;
  float  fbmScale = params->fbmScale;

  // --------

    mat3 dummy;

    float2 uv = fragCoord/iResolution;
    float3 col = swi3(_tex2DVecN(iChannel1,uv.x,uv.y,15),x,y,z);
    fragColor = to_float4_aw(col, 1.0f);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
]]
-- /*



-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ShaderFuse.begin_create()

  ----- Inspector Panel Controls

  
  -- Speed Slider
  
  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",
  })
  
  -- iMouse Controls
  
  InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    --INP_Passive = true,
    INPID_PreviewControl = "CrosshairControl",
  })
  
  InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    --INP_Passive = true,
    INPID_PreviewControl = "CrosshairControl",
    INP_Disabled = true,
  })
  
  InMouseDrag = self:AddInput("Mouse Button Pressed", "iMouseClick", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = false,
    --INP_Passive = true,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0,
  })
  
  InResetCheckbox = self:AddInput("Reset", "Reset", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  self:BeginControlNest("ColorBKG", "ColorBKG", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColorBKG",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColorBKGColorR = self:AddInput("Red",   "ColorBKGRed",   { INP_Default  = 0.09, IC_ControlID = 0, attrs})
    InColorBKGColorG = self:AddInput("Green", "ColorBKGGreen", { INP_Default  = 0.33, IC_ControlID = 1, attrs})
    InColorBKGColorB = self:AddInput("Blue",  "ColorBKGBlue",  { INP_Default  = 0.81, IC_ControlID = 2, attrs})
    InColorBKGColorA = self:AddInput("Alpha", "ColorBKGAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  InSigmaSSlider = self:AddInput("SigmaS", "SigmaS", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 2.0,
      })

  InSigmaA1Slider = self:AddInput("SigmaA1", "SigmaA1", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 20.0,
          INP_Default        = 4.0,
      })

  InSigmaA2Slider = self:AddInput("SigmaA2", "SigmaA2", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 20.0,
          INP_Default        = 3.0,
      })

  InSigmaE1Slider = self:AddInput("SigmaE1", "SigmaE1", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InSigmaE2Slider = self:AddInput("SigmaE2", "SigmaE2", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InViewXYPoint = self:AddInput("ViewXY", "ViewXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InViewZSlider = self:AddInput("ViewZ", "ViewZ", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InSunLocationSlider = self:AddInput("SunLocation", "SunLocation", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InSunHeightSlider = self:AddInput("SunHeight", "SunHeight", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InfbmScaleSlider = self:AddInput("fbmScale", "fbmScale", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.95,
      })



  Sep3 = self:AddInput(string.rep("_", 152), "Separator3", {
    LINKID_DataType     = "Text",
    INPID_InputControl  = "LabelControl",
    INP_External        = false,
    INP_Passive         = true,
    IC_Visible          = true,
    INP_DoNotifyChanged = true,
    IC_NoLabel          = true,
  })
  
  
  InEdges = self:AddInput("Edges", "Edges", {
    LINKID_DataType = "Number",
    INPID_InputControl  = "MultiButtonControl",
    IC_Visible          = false,
    INP_Default         = 3.0,
    INP_Integer         = true,
    INP_DoNotifyChanged = true,
    INP_External        = false,
    MBTNC_ForceButtons  = true,
    INP_MinScale        = 0,
    INP_MaxScale        = 3,
    INP_MinAllowed      = 0,
    INP_MaxAllowed      = 3,
    MBTNC_ShowBasicButton = true,
    MBTNC_StretchToFit  = false, --true,
    MBTNC_ShowToolTip   = true,
    { MBTNC_AddButton = "Canvas", MBTNCD_ButtonWidth = 4/16, },
    { MBTNC_AddButton = "Wrap",MBTNCD_ButtonWidth = 3/16, },
    { MBTNC_AddButton = "Duplicate", MBTNCD_ButtonWidth = 5/16, },
    { MBTNC_AddButton = "Mirror", MBTNCD_ButtonWidth = 4/16, }, 
   }) 

  InDebugImage = self:AddInput("DebugImage", "DebugImage", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Final", },
    { CCS_AddString = "BufferA", },
    { CCS_AddString = "BufferB", },
    CC_LabelPosition = "Horizontal",
  })

  ----- Size & Depth
  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
    INP_DoNotifyChanged = true,
    INP_Default        = 0,
    INP_Integer        = true,
    ICD_Width          = 1,
	  { CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	  { CCS_AddString  = "Image0", },
    { CCS_AddString  = "1920x1080", },
	  { CCS_AddString  = "1200x675", },
	  { CCS_AddString  = "800x450", },
	  { CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
  
  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
    INP_DoNotifyChanged = true,
    INP_Default      = 3,
    INP_Integer      = true,
    ICD_Width        = 1,
    { CCS_AddString  = "Default", },
    { CCS_AddString  = "int8", },
    { CCS_AddString  = "int16", },
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
    ICS_ControlPage  = "Image",
  })
  
  InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false }) 

  ----- In/Out

  InChannel0 = self:AddInput( "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
  InChannel1 = self:AddInput( "iChannel1",  "iChannel1",  { LINKID_DataType = "Image", LINK_Main = 2, LINK_Visible = false, INP_Required = false  })
  InChannel2 = self:AddInput( "iChannel2",  "iChannel2",  { LINKID_DataType = "Image", LINK_Main = 3, LINK_Visible = false, INP_Required = false  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main       = 1,
  })

  ShaderFuse.end_create()

end



-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------
function DefineEdges(edges, nodeX)

    --This gets the value of our input image for us to modify inside the kernel
    if edges == 0 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 1 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_WRAP, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 2 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_DUPLICATE, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 3 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 4 then
      --print("Sampler 4")
    end
end



MULTIBUFFER = true
if MULTIBUFFER then   -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  ImgAttrs_Global = {
          { IMG_Channel = "Red", },
          { IMG_Channel = "Green", },
          { IMG_Channel = "Blue", },
          { IMG_Channel = "Alpha", },
          IMG_Width = Width,
          IMG_Height = Height,
          IMG_DeferAlloc = false,
          }

  Image_Buff_GlobalA = Image(ImgAttrs_Global)
  Image_Buff_GlobalB = Image(ImgAttrs_Global)
end


function Process(req)

	-- Imagesize and Depth
  if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InChannel0:GetValue(req) ~= nil) then
			   Width = InChannel0:GetValue(req).Width
			   Height = InChannel0:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value 
		end
	end	
  
  -- Alle ( int und float )
  if (InDepth:GetValue(req).Value > 0) then
	  if InDepth:GetValue(req).Value == 1 then 
	    SourceDepth = 5 
    else 
	    if InDepth:GetValue(req).Value == 2 then 
	        SourceDepth = 6 
	    else 
	        if InDepth:GetValue(req).Value == 3 then 
 		        SourceDepth = 7 
		    	else
			      SourceDepth = 8
	        end
		  end
	  end
	end

  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth  = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }

  local dst   = Image(imgattrs)
  local black = Pixel({R=0,G=0,B=0,A=0})
  dst:Fill(black)

if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  dstA = Image {IMG_Like = dst, IMG_DeferAlloc = true}
	dstB = Image {IMG_Like = dst, IMG_DeferAlloc = true}
end

  if req:IsPreCalc() then
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end


if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA = DVIPComputeNode(req,
    "StellarCloudsFuse__Buffer_A", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
else
    node = DVIPComputeNode(req,
    "StellarCloudsFuse", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
end
  -- Extern texture or create a new one

  iChannel0 = InChannel0:GetValue(req)

  if iChannel0==nil then
    iChannel0 = Image(imgattrs)
    iChannel0:Fill(black)
  end

  iChannel1 = InChannel1:GetValue(req)

  if iChannel1==nil then
    iChannel1 = Image(imgattrs)
    iChannel1:Fill(black)
  end

  iChannel2 = InChannel2:GetValue(req)

  if iChannel2==nil then
    iChannel2 = Image(imgattrs)
    iChannel2:Fill(black)
  end

  -- DCTL parameters

  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    params = nodeA:GetParamBlock(ShaderParameters)
  else  
    params = node:GetParamBlock(ShaderParameters)
  end  

  params.iResolution[0] = dst.Width
  params.iResolution[1] = dst.Height
  params.iTime = (req.Time / framerate) * InFrequency:GetValue(req).Value
  
  -- iMouse
  
  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)
  
  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y
  
  if InMouseDrag:GetValue(req).Value ~= 0 then
    if params.iMouse[2]==-1 and params.iMouse[3]==-1 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = -1
    params.iMouse[3] = -1
  end
  
  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end
  
  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  if params.iMouse[2] == -1 and params.iMouse[3] == -1 then
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  else
    params.iMouse[2] = params.iMouse[2] * Width
    params.iMouse[3] = params.iMouse[3] * Height
  end
  params.iFrame = req.Time

  params.Reset = InResetCheckbox:GetValue(req).Value
  params.ColorBKG = {
    InColorBKGColorR:GetValue(req).Value,
    InColorBKGColorG:GetValue(req).Value,
    InColorBKGColorB:GetValue(req).Value,InColorBKGColorA:GetValue(req).Value
  }
  params.SigmaS = InSigmaSSlider:GetValue(req).Value
  params.SigmaA1 = InSigmaA1Slider:GetValue(req).Value
  params.SigmaA2 = InSigmaA2Slider:GetValue(req).Value
  params.SigmaE1 = InSigmaE1Slider:GetValue(req).Value
  params.SigmaE2 = InSigmaE2Slider:GetValue(req).Value
  params.ViewXY = {InViewXYPoint:GetValue(req).X,InViewXYPoint:GetValue(req).Y}
  params.ViewZ = InViewZSlider:GetValue(req).Value
  params.SunLocation = InSunLocationSlider:GetValue(req).Value
  params.SunHeight = InSunHeightSlider:GetValue(req).Value
  params.fbmScale = InfbmScaleSlider:GetValue(req).Value
  -- Resolution

  params.width  = dst.Width
  params.height = dst.Height

  -- Per channel time and resolution


    local edges = InEdges:GetValue(req).Value

  -- Set parameters and add I/O
  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA:SetParamBlock(params)
    --nodeA:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, nodeA)
    
    
  else   
    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)
    
    node:AddInput("iChannel0",iChannel0) -- TODO: add a better channel name
    node:AddInput("iChannel1",iChannel1) -- TODO: add a better channel name
    node:AddInput("iChannel2",iChannel2) -- TODO: add a better channel name
    node:AddOutput("dst", dst)
  end
  
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA:AddInput("iChannel0",Image_Buff_GlobalA)  -- Anpassen !!
    nodeA:AddOutput("dst", dstA)

    local ok = nodeA:RunSession(req)

    if (not ok) then
      dstA = nil
      dump(nodeA:GetErrorLog())
    end
    
    Image_Buff_GlobalA = dstA

  -------------------------- BufferB-Kernel----------------------------------------
    local nodeB = DVIPComputeNode(req,
      "StellarCloudsFuse__Buffer_B", ShaderCompatibilityCode..ShaderKernelCode,
      "Params", ShaderParameters
    )
    
    nodeB:SetParamBlock(params)

    --nodeB:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, nodeB)
    
    nodeB:AddInput("iChannel0", Image_Buff_GlobalA)  -- Anpassen !!
    nodeB:AddInput("iChannel1", Image_Buff_GlobalB)  -- Anpassen !!
    nodeB:AddInput("iChannel2", iChannel0)  -- Anpassen !!
    nodeB:AddOutput("dst", dstB)

    local success = nodeB:RunSession(req)
    if not success then
      dstB = nil
      dump(nodeB:GetErrorLog())
    end
    
    Image_Buff_GlobalB = dstB --Recursiv Image	
    
    -------------------------- ImageKernel----------------------------------------
    node = DVIPComputeNode(req,
      "StellarCloudsFuse", ShaderCompatibilityCode..ShaderKernelCode,
      "Params", ShaderParameters
    )

    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)

    node:AddInput("iChannel0", Image_Buff_GlobalA)  -- Anpassen !!
    node:AddInput("iChannel1", Image_Buff_GlobalB)  -- Anpassen !!
    node:AddOutput("dst", dst)
 
  end -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  

  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    dump(node:GetErrorLog())
	end

  OutImage:Set(req,dst)

  
    --Debugging
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER
    InDebugImage:SetAttrs({ IC_Visible = true })
    
    if (InDebugImage:GetValue(req).Value == 1) then OutImage:Set(req, Image_Buff_GlobalA) end
    if (InDebugImage:GetValue(req).Value == 2) then OutImage:Set(req, Image_Buff_GlobalB) end
  else
    InDebugImage:SetAttrs({ IC_Visible = false })
  end
  
  collectgarbage();
end



-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

function NotifyChanged(inp, param, time)
 	if (param ~= nil) then

		if inp == InSize then
		  if param.Value == 1 then
			  InWidth:SetAttrs({ IC_Visible = true })
			  InHeight:SetAttrs({ IC_Visible = true })
		  else
			  InWidth:SetAttrs({ IC_Visible = false })
			  InHeight:SetAttrs({ IC_Visible = false })
		  end
		  
		  if param.Value == 3 then --1920x1080
			  InWidth:SetSource(Number(1920),0,0)
			  InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			  InWidth:SetSource(Number(1200),0,0)
			  InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			  InWidth:SetSource(Number(800),0,0)
			  InHeight:SetSource(Number(450),0,0)
		  end
 	    if param.Value == 6 then --640x360
		    InWidth:SetSource(Number(640),0,0)
		    InHeight:SetSource(Number(360),0,0)
		  end
		end 

 	end
end


-- */
