--[[--/*

  CartoonRide.fuse

  Based on https://www.shadertoy.com/view/wtXBR4 a WebGL shader created by iapafoto.
  Converted to DCTL and embeddet into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT).
  Place this file in your Fusion's and/or DaVinci Resolve's 'Fuses/' folder to use it.

*/--]]--




-- /*
local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()



-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,
  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  })



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------

-- */
ShaderParameters =
[[

  float  iResolution[2];
  float  iTime;
  float  iMouse[4];
  bool   WITH_AO;
  bool   PRECISE;
  bool   WITH_AA;
  bool   CamSwivel;
  float  Color1[4];
  float  ColorOut[4];
  float  Color2[4];
  float  Color3[4];
  float  ColorSky[4];
  float  ColorGround[4];
  float  ColorShip1[4];
  float  ColorShip2[4];
  float  ColorPath[4];
  float  ViewDXY[2];
  float  ViewDZ;
  float  ViewXY[2];
  float  ViewZ;
  float  EDGE_WIDTH;
  float  freqA;
  float  freqB;
  float  ampA;
  float  ampB;
  float  FOV;
  float  FwdXY[2];
  float  FwdZ;
  float  UpXY[2];
  float  UpZ;
  float  RightXY[2];
  float  RightZ;
  float  SwivelAngel;
  float  SwivelTempo;
  float  Swivel[2];
  float  TNL;
  float  TNLOffset[2];
  float  UVOffset[2];
  float  SDBox[2];
  
  int    width,height;
  int    compOrder;

]]
-- /*

-- // ------------------------------------------------------------------------
-- DCTL kernel compatibility code
-- // ------------------------------------------------------------------------

-- */
ShaderCompatibilityCode =
[[


#if defined(DEVICE_IS_METAL)
  #define in
  #define out thread
  #define inout thread
#else
  #define in
  #define out
  #define inout
#endif

#undef USE_NATIVE_METAL_IMPL
#undef USE_NATIVE_CUDA_IMPL
#undef USE_NATIVE_OPENCL_IMPL

  // 0 to use the generic implementations; 1 for Metal, OpenCL, Cuda specific code if existing

  #if 1
    #if defined(DEVICE_IS_METAL)
      #define USE_NATIVE_METAL_IMPL   1
    #elif defined(DEVICE_IS_CUDA)
      #define USE_NATIVE_CUDA_IMPL    1
    #elif defined(DEVICE_IS_OPENCL)
      #define USE_NATIVE_OPENCL_IMPL  1
    #endif
  #endif

  #if defined(USE_NATIVE_METAL_IMPL)

    #define swi2(A,a,b)     (A).a##b
    #define swi3(A,a,b,c)   (A).a##b##c

    #define swi2S(a,b,c,d)   a.b##c = d

  #else

    #define swi2(A,a,b)     to_float2((A).a,(A).b)
    #define swi3(A,a,b,c)   to_float3((A).a,(A).b,(A).c)

    #define swi2S(a,b,c,d)   {float2 tmp = d; (a).b = tmp.x; (a).c = tmp.y;}

  #endif

// ----------------------------------------------------------------------------------------------------------
// mat2 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float2x2 mat2;

  #define to_mat2(A,B,C,D)   mat2((A),(B),(C),(D))

  #define mul_f2_mat2(A,B)   ((A)*(B))

#else

  typedef struct { float2 r0; float2 r1; } mat2;

  __DEVICE__ inline mat2 to_mat2      ( float  a, float  b, float c, float d)  { mat2 t; t.r0.x = a; t.r0.y = b; t.r1.x = c; t.r1.y = d;         return t; }

  __DEVICE__ inline float2 mul_f2_mat2( float2 v, mat2 m )
  {
    float2 t; t.x = v.x*m.r0.x + v.y*m.r0.y; t.y = v.x*m.r1.x + v.y*m.r1.y; return t;
  }

#endif // end of mat2 implementation

// ----------------------------------------------------------------------------------------------------------
// mat3 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float3x3 mat3;

  __DEVICE__ inline mat3 to_mat3( float a, float b, float c, float d, float e, float f, float g, float h, float i)
  {
    return mat3(a,b,c,d,e,f,g,h,i);
  }

  __DEVICE__ inline mat3 to_mat3_f3( float3 a, float3 b, float3 c ) { return mat3(a,b,c); }
  __DEVICE__ inline float3 mul_mat3_f3( mat3 B, float3 A) { return (B*A); }
  __DEVICE__ inline float3 mul_f3_mat3( float3 A, mat3 B) { return (A*B); }
  __DEVICE__ inline mat3 mul_mat3_mat3( mat3 A, mat3 B) { return (A*B); }

#else

  typedef struct { float3 r0; float3 r1; float3 r2; } mat3;

  __DEVICE__ inline mat3 to_mat3( float  a, float  b, float c,   float d, float e, float f,   float g, float h, float i)
  {
    mat3 t;
    t.r0.x = a; t.r0.y = b; t.r0.z = c;
    t.r1.x = d; t.r1.y = e; t.r1.z = f;
    t.r2.x = g; t.r2.y = h; t.r2.z = i;
    return t;
  }

  __DEVICE__ inline mat3 to_mat3_f3( float3 A, float3 B, float3 C)
  {
    mat3 D;
    D.r0 = A;
    D.r1 = B;
    D.r2 = C;
    return D;
  }

__DEVICE__ inline float3 mul_mat3_f3( mat3 B, float3 A) {
    float3 C;

    C.x = A.x * B.r0.x + A.y * B.r1.x + A.z * B.r2.x;
    C.y = A.x * B.r0.y + A.y * B.r1.y + A.z * B.r2.y;
    C.z = A.x * B.r0.z + A.y * B.r1.z + A.z * B.r2.z;
    return C;
  }

__DEVICE__ inline float3 mul_f3_mat3( float3 A, mat3 B) {
    float3 C;

    C.x = A.x * B.r0.x + A.y * B.r0.y + A.z * B.r0.z;
    C.y = A.x * B.r1.x + A.y * B.r1.y + A.z * B.r1.z;
    C.z = A.x * B.r2.x + A.y * B.r2.y + A.z * B.r2.z;
    return C;
  }

__DEVICE__ mat3 mul_mat3_mat3( mat3 B, mat3 A)
{
   float r[3][3];
   float a[3][3] = {{A.r0.x, A.r0.y, A.r0.z},
                    {A.r1.x, A.r1.y, A.r1.z},
                    {A.r2.x, A.r2.y, A.r2.z}};
   float b[3][3] = {{B.r0.x, B.r0.y, B.r0.z},
                    {B.r1.x, B.r1.y, B.r1.z},
                    {B.r2.x, B.r2.y, B.r2.z}};

  for( int i = 0; i < 3; ++i)
  {
   for( int j = 0; j < 3; ++j)
   {
     r[i][j] = 0.0f;
     for( int k = 0; k < 3; ++k)
     {
       r[i][j] = r[i][j] + a[i][k] * b[k][j];
     }
   }
  }
  mat3 R = to_mat3(r[0][0], r[0][1], r[0][2],
                   r[1][0], r[1][1], r[1][2],
                  r[2][0], r[2][1], r[2][2]);
  return R;
}
#endif // end of mat3 implementation

#if defined(USE_NATIVE_METAL_IMPL)

 #define mod_f(a,b)  fmod((a),(b))
 #define mod_f2(value,divisor) fmod(value,divisor)

 #define sin_f2(i) sin(i)
 #define sin_f3(i) sin(i)
 #define cos_f3(i) cos(i)
 #define abs_f2(a) _fabs(a)
 #define abs_f3(a) _fabs(a)
 #define sign_f(a) sign(a)
 #define pow_f3(a,b) pow(a,b)

#else

  #if defined(USE_NATIVE_OPENCL_IMPL)

    #define reflect(I,N) (I-2.0f*dot(N,I)*N)

    #define fract(a) ((a)-_floor(a))  // oder Pointer bauen: gentype fract(gentype x, gentype *itpr)

 #define mod_f(a,b) _fmod(a,b)
 #define mod_f2(value,divisor) _fmod(value,divisor)
 #define sin_f2(i) sin(i)
 #define sin_f3(i) sin(i)
 #define cos_f3(i) cos(i)
 #define abs_f2(a) fabs(a)
 #define abs_f3(a) fabs(a)
 #define sign_f(a) sign(a)
 #define pow_f3(a,b) pow(a,b)

 #else // Generic

 #if defined(DEVICE_IS_OPENCL)
   __DEVICE__ float3 reflect(float3 I, float3 N) {return I - 2.0f * dot(N, I) * N;}
 #endif

    #define fract(a) ((a)-_floor(a))

 #define mod_f(a,b) ((a)-(b)*_floor((a)/(b)))
 #define mod_f2(value,divisor) to_float2(mod_f((value).x, (divisor)),mod_f((value).y, (divisor)))
 #define sin_f2(i) to_float2( _sinf((i).x), _sinf((i).y))
 #define sin_f3(i) to_float3( _sinf((i).x), _sinf((i).y), _sinf((i).z))
 #define cos_f3(i) to_float3( _cosf((i).x), _cosf((i).y), _cosf((i).z))
 #define abs_f2(a) to_float2(_fabs((a).x), _fabs((a).y))
 #define abs_f3(a) to_float3(_fabs((a).x), _fabs((a).y),_fabs((a).z))
 #define sign_f(a) (a==0.0f?0.0f:a>0.0f?1.0f:-1.0f)
 #define pow_f3(a,b) to_float3(_powf((a).x,(b).x),_powf((a).y,(b).y),_powf((a).z,(b).z))

  #endif

#endif


]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel implementation
-- // ------------------------------------------------------------------------

-- */
ShaderKernelCode =
[[

// ----------------------------------------------------------------------------------
// - Common                                                                         -
// ----------------------------------------------------------------------------------
#define texture(ch,uv) _tex2DVecN(ch, (uv).x, (uv).y, 15)
#define texelFetch(ch, uv, a) texture(ch, (to_float2((uv).x,(uv).y)+0.5f)/iResolution)


#define pi 3.1415926535897f

#define FAR 400.0f
//#define PRECISE
//#define WITH_AO

#define ID_SKY    0.0f
#define ID_SHIP   1.0f
#define ID_GROUND 2.0f
#define ID_PATH   3.0f


// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.
__DEVICE__ mat2 rot2( float th ){ float2 a = sin_f2(to_float2(1.5707963f, 0) + th); return to_mat2(a.x, a.y, -a.y, a.x); }

// 1x1 and 3x1 hash functions.
__DEVICE__ float hash(float n) { return fract(_cosf(n)*45758.5453f); }
__DEVICE__ float hash_f3(float3 p){ return fract(_sinf(dot(p, to_float3(7, 157, 113)))*45758.5453f); }


// Smooth maximum, based on the function above.
__DEVICE__ float smaxP(float a, float b, float s){
    float h = clamp(0.5f + 0.5f*(a - b)/s, 0.0f, 1.0f);
    return _mix(b, a, h) + h*(1.0f - h)*s;
}

__DEVICE__ float sdVerticalCapsule( float3 p, float h, float r ) {
  p.y -= clamp( p.y, 0.0f, h );
  return length( p ) - r;
}

__DEVICE__ float sdTorus( float3 p, float2 t ) {
  float2 q = to_float2(length(swi2(p,x,z))-t.x,p.y);
  return length(q)-t.y;
}

__DEVICE__ float sdBox_f3( float3 p, float3 b ) {
  float3 q = abs_f3(p) - b;
  return length(_fmaxf(q,to_float3_s(0.0f))) + _fminf(_fmaxf(q.x,_fmaxf(q.y,q.z)),0.0f);
}

__DEVICE__ float sdBox( in float2 p, in float2 b ) {
    float2 d = abs_f2(p)-b;
    return length(_fmaxf(d,to_float2_s(0.0f))) + _fminf(_fmaxf(d.x,d.y),0.0f);
}

__DEVICE__ float sdCappedCylinder( float3 p, float h, float r ) {
  float2 d = abs_f2(to_float2(length(swi2(p,x,z)),p.y)) - to_float2(h,r);
  return _fminf(_fmaxf(d.x,d.y),0.0f) + length(_fmaxf(d,to_float2_s(0.0f)));
}

__DEVICE__ float2 pModPolar(float2 p, float repetitions) {
  float angle = 2.0f*3.141592f/repetitions;
  float a = _atan2f(p.y, p.x) + angle*0.5f;
  a = mod_f(a,angle) - angle*0.5f;
  p = to_float2(_cosf(a), _sinf(a))*length(p);
  return p;
}

__DEVICE__ float2 pR45(float2 p) {
  p = (p + to_float2(p.y, -p.x))*_sqrtf(0.5f);
  return p;
}

// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.
__DEVICE__ float2 path(in float z, float ampA, float freqA, float ampB, float freqB, float2 UfoPath){
    return to_float2(ampA*_sinf(z * freqA) + 2.0f*_cosf(z*0.0252f) - 1.0f, 10.0f+ ampB*_cosf(z * freqB) * (0.5f+ 0.5f*_sinf(z*0.0015f))) + UfoPath;
}

__DEVICE__ float sdGround(in float3 p, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel){
    p += to_float3(0,2,0);
    float tx1 = 2.5f*texture(channel, swi2(p,x,z)/28.0f + swi2(p,x,y)/100.0f).x;
    float tx2 = 2.0f*texture(channel, swi2(p,x,y)/to_float2(31.0f,15.0f)).x;
    float tx = tx1 - tx2;

    float3 q = p*0.125f;
    float h = dot(sin_f3(q)*cos_f3(swi3(q,y,z,x)), to_float3_s(0.222f)) + dot(sin_f3(q*1.5f)*cos_f3(swi3(q,y,z,x)*1.5f), to_float3_s(0.111f));

    float d = p.y + h*6.0f;
    q = p*0.07125f;
    float h3 = dot(sin_f3(q)*cos_f3(swi3(q,y,z,x)), to_float3_s(0.222f)) + dot(sin_f3(q*1.5f)*cos_f3(swi3(q,y,z,x)*1.5f), to_float3_s(0.111f));
    float d3 = p.y + h3*22.0f-22.0f;

    q = sin_f3(p*0.5f + h);
    float h2 = q.x*q.y*q.z;

    float3 p0 = p;
    swi2S(p,x,y, swi2(p,x,y) - path(p.z, ampA, freqA, ampB, freqB, UfoPath));

    float dPath = length(swi2(p,x,y))-38.0f;

    float3 p1 = p;
    float tnl = TNL + 1.5f - length(swi2(p,x,y)*(to_float2(1.2f, 1.96f)+TNLOffset)) + h2;// - (1.0f - tx)*0.25f;

    swi2S(p,x,z, mod_f2(swi2(p0,x,z)+150.0f,300.0f)-150.0f);

    float dCaps = _mix(999.0f, sdVerticalCapsule(p+to_float3(45,60,50), 130.0f, 15.0f) + tx1, step(2500.0f, p0.z));

    p = p1;
    p.z = mod_f(p.z+250.0f,500.0f)-250.0f;

    float dGate = sdTorus(swi3(p,y,z,x)-to_float3(25,25,5), to_float2(50.0f,15.0f))+tx1;
    dCaps = _mix(dCaps, dGate, step(4600.0f, p0.z));

    swi2S(p,x,z, mod_f2(swi2(p0,x,z)+450.0f,900.0f)-450.0f);
    float dCaps2 = sdVerticalCapsule(p+to_float3(20,55,0), 100.0f, 30.0f) + 0.5f*tx;

    float d4 = smaxP(d - tx*0.5f+ tnl*0.4f, 0.2f*tnl, 8.0f);
    d3 = _mix(d3, d4, smoothstep(0.5f,1.0f, 0.5f+0.5f*(_sinf(p0.z*0.001f-0.8f))));

    d = _fminf(dCaps, smaxP(d3, d4, 10.0f));
    float dend = _fmaxf(p0.y-60.0f, -dPath-0.5f*tx+0.25f*tx2);
    d = _mix(d, dend, smoothstep(7000.0f,9000.0f, p0.z)*smoothstep(12000.0f,9000.0f, p0.z));
    d = smaxP(-dCaps2, d,2.0f);

    return d;
}

__DEVICE__ float sdShip(in float3 p0) {
    p0 -= to_float3(4,0,0);
    float d = length(p0) -4.0f;

    float3 pRot = p0;
    swi2S(pRot,z,y, pModPolar(swi2(pRot,z,y), 16.0f));
    pRot.x = _fabs(pRot.x);
    d = _fminf(d, length(pRot-to_float3(2.6f,0,3.0f))-0.2f);
    d = _fminf(d, sdBox_f3(pRot-to_float3(4.5f,0,0.8f), to_float3(0.5f,0.1f,0.2f)));

    float3 p = p0;
    swi2S(p,z,y, abs_f2(swi2(p,z,y)));
    p -= to_float3(-5.6f,2.5f,2);
    swi2S(p,y,z, pR45(swi2(p,y,z)));
    swi2S(p,x,y, pR45(swi2(p,x,y)));
    return _fminf(d, sdBox_f3(p, to_float3(1.0f,2,0.2f)));
}

__DEVICE__ float sdPath(in float3 p0, float3 gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath) {
    float d2 = length(path(p0.z, ampA, freqA, ampB, freqB, UfoPath)-swi2(p0,x,y))-0.5f;
    return _fmaxf(d2, -gRO.z + p0.z);
}

__DEVICE__ float map(in float3 p0, float3 gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel) {
    float d = sdGround(p0, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
    float dPath = sdPath(p0-to_float3(0,0,0), gRO, ampA, freqA, ampB, freqB, UfoPath);
    return _fminf(dPath,d);
}

__DEVICE__ float mapFull(in float3 p0, mat3 gbaseShip, float3 gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel) {
    float d = sdGround(p0, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
    float dPath = sdPath(p0, gRO, ampA, freqA, ampB, freqB, UfoPath);
    return _fminf(sdShip(mul_f3_mat3((p0-gRO) , gbaseShip)),_fminf(dPath,d));
}

__DEVICE__ float2 min2(float2 c0, float2 c1) {
  return c0.x < c1.x ? c0 : c1;
}

__DEVICE__ float2 mapColor(in float3 p0, mat3 gbaseShip, float3 gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel) {
    float d = sdGround(p0, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
    float dPath = sdPath(p0, gRO, ampA, freqA, ampB, freqB, UfoPath);
    return min2(to_float2(sdShip(mul_f3_mat3((p0-gRO) , gbaseShip)), ID_SHIP),
           min2(to_float2(dPath, ID_PATH), to_float2(d, ID_GROUND)));
}


__DEVICE__ float logBisectTrace(in float3 ro, in float3 rd, inout float *gedge, inout float *gedge2, inout float *glastt, float EDGE_WIDTH, bool PRECISE, mat3 gbaseShip, float3 gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel){
    float t = 0.0f, told = 0.0f, mid=0.0f, dn=0.0f;
    float d = map(rd*t + ro, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
    float sgn = sign_f(d);

    float lastDistEval = 1e10f, lastt = 0.0f;
    float3 rdShip = mul_f3_mat3(rd,gbaseShip);
    float3 roShip = mul_f3_mat3((ro-gRO),gbaseShip);

    for (int i=0; i<164; i++){
        if (sign_f(d) != sgn || d < 0.01f || t > FAR) break;

        told = t;
        t += step(d, 1.0f)*(_logf(_fabs(d) + 1.1f) - d) + d;

        d = map(rd*t + ro, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
        d = _fminf(d, sdShip(rdShip*t + roShip));

        if (d < lastDistEval) {
            lastt = t;
            lastDistEval = d;
        } else {
            if (d > lastDistEval + 0.0001f &&  lastDistEval/_mix(30.0f, lastt, smoothstep(FAR*0.75f, FAR*0.9f, t)) < EDGE_WIDTH) {
              *gedge = 1.f;
                if (*glastt == 0.0f) *glastt = lastt;
            }
            if (d > lastDistEval + 0.0001f && (lastDistEval < EDGE_WIDTH*40.0f || lastDistEval/lastt < EDGE_WIDTH*2.0f)) {
              *gedge2 = 1.f;
            }
      //edge = smoothstep(-EDGE_WIDTH,-EDGE_WIDTH*0.5f,-(lastDistEval/100.0f));///lastt));
    }
    }
    if (*glastt == 0.0f)  *glastt = lastt;

    if (PRECISE)
    {
      // If a threshold was crossed without a solution, use the bisection method.
      if (sign_f(d) != sgn){

          // Based on suggestions from CeeJayDK, with some minor changes.
          dn = sign_f(map(rd*told + ro, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel));

          float2 iv = to_float2(told, t); // Near, Far

          // 6 iterations seems to be more than enough, for most cases...
          // but there's an early exit, so I've added a couple more.
          for (int ii=0; ii<8; ii++) {
              //Evaluate midpoint
              mid = dot(iv, to_float2_s(0.5f));
              float d = map(rd*mid + ro, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
              if (_fabs(d) < 0.001f)break;
              iv = _mix(to_float2(iv.x, mid), to_float2(mid, iv.y), step(0.0f, d*dn));
          }
          t = mid;
      }
    }
    return _fminf(t, FAR);
}


__DEVICE__ float3 normal(in float3 p, mat3 gbaseShip, float3 gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel) {
  float2 e = to_float2(-1, 1)*0.001f;
  return normalize(swi3(e,y,x,x)*mapFull(p + swi3(e,y,x,x), gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel) + swi3(e,x,x,y)*mapFull(p + swi3(e,x,x,y), gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel) +
                   swi3(e,x,y,x)*mapFull(p + swi3(e,x,y,x), gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel) + swi3(e,y,y,y)*mapFull(p + swi3(e,y,y,y), gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel) );
}


__DEVICE__ float softShadow(in float3 ro, in float3 rd, in float start, in float end, in float k, mat3 gbaseShip, float3 gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel){

    ro += rd*hash_f3(ro);
    float3 rdShip = mul_f3_mat3(rd,gbaseShip);
    float3 roShip = mul_f3_mat3((ro-gRO),gbaseShip);
    float shade = 1.0f;
    const int maxIterationsShad = 24;
    float dist = start;
    float stepDist = end/(float)(maxIterationsShad);
    for (int i=0; i<maxIterationsShad; i++){
        float h = _fminf(map(ro + rd*dist, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel), sdShip(roShip + dist*rdShip));
        shade = _fminf(shade, smoothstep(0.0f, 1.0f, k*h/dist));
        dist += clamp(h, 0.2f, stepDist*2.0f);
        if (_fabs(h)<0.001f || dist > end) break;
    }
    return _fminf(_fmaxf(shade, 0.0f) + 0.1f, 1.0f);
}

__DEVICE__ float calculateAO( in float3 p, in float3 n, float maxDist, mat3 gbaseShip, float3 gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel )
{
  float ao = 0.0f, l;
  const float nbIte = 6.0f;
  for(float i=1.0f; i< nbIte+0.5f; i++){
        l = (i + hash(i))*0.5f/nbIte*maxDist;
        ao += (l - mapFull( p + n*l, gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel))/(1.0f + l);
  }
  return clamp(1.0f - ao/nbIte, 0.0f, 1.0f);
}

// Pretty standard way to make a sky.
__DEVICE__ float3 getSky(in float3 ro, in float3 rd, float3 sunDir){
  return to_float3_s(smoothstep(0.97f, 1.0f, _fmaxf(dot(rd, sunDir), 0.0f)));
}

// Curve function, by Shadertoy user, Nimitz.
// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM
__DEVICE__ float curve(in float3 p, mat3 gbaseShip, float3 gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel){
    const float eps = 0.05f, amp = 4.0f, ampInit = 0.5f;
    float2 e = to_float2(-1, 1)*eps; // 0.05f->3.5f - 0.04f->5.5f - 0.03f->10.0f->0.1f->1.
    float t1 = mapFull(p + swi3(e,y,x,x), gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel), t2 = mapFull(p + swi3(e,x,x,y), gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
    float t3 = mapFull(p + swi3(e,x,y,x), gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel), t4 = mapFull(p + swi3(e,y,y,y), gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
    return clamp((t1 + t2 + t3 + t4 - 4.0f*mapFull(p, gbaseShip, gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel))*amp + ampInit, 0.0f, 1.0f);
}


__DEVICE__ float4 render(in float2 fragCoord, float Time, float2 Resolution, float4 iMouse, float2 SDBox, bool CamSwivel, float2 Swivel, float SwivelAngel, float SwivelTempo, float3 View[5], float3 Colors[8], bool WITH_AO, float FOV, inout float *gedge, inout float *gedge2, inout float *glastt, float EDGE_WIDTH, bool PRECISE, inout mat3 *gbaseShip, inout float3 *gRO, float ampA, float freqA, float ampB, float freqB, float2 UfoPath, float TNL, float2 TNLOffset, __TEXTURE2D__ channel){

    *gedge = 0.0f;
    *gedge2= 0.0f;
    *glastt = 0.0f;

    // Screen coordinates.
    float2 u = (fragCoord - Resolution*0.5f)/Resolution.y;
    float dBox = sdBox(u, to_float2(0.5f*Resolution.x/Resolution.y-0.1f,0.4f)+SDBox);

    float3 col = to_float3_s(0.2f);
    float needAA = 0.0f;
    float ed = 0.0f, ed2 = 0.0f, lastt1 = 0.0f;

    if (dBox <0.0f){

        // Camera Setup.
        float3 lookAt = to_float3(0, 0, Time*100.0f/SwivelTempo);  // "Look At" position.
        float3 ro = lookAt + to_float3(0, 0, -0.25f) + View[4]; // Camera position, doubling as the ray origin.

        swi2S(lookAt,x,y, swi2(lookAt,x,y) + path(lookAt.z, ampA, freqA, ampB, freqB, UfoPath));
        swi2S(ro,x,y, swi2(ro,x,y)         + path(ro.z, ampA, freqA, ampB, freqB, UfoPath));
        lookAt.y -= 0.071f;

        // Using the above to produce the unit ray-direction vector.
        //float FOV = 3.14159f/2.0f; // FOV - Field of view.

        float3 forward = normalize(lookAt - ro);
        float3 right = normalize(to_float3(forward.z, 0, -forward.x ));

        swi2S(right,x,y, mul_f2_mat2(swi2(right,x,y) , rot2( path(lookAt.z, ampA, freqA, ampB, freqB, UfoPath).x/64.0f)));
        swi2S(right,x,y, mul_f2_mat2(swi2(right,x,y) , rot2( -0.7f*_cosf(Time*0.12f/SwivelAngel))));

        float3 up = cross(forward, right);

        float3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up + View[1]);
        float3 lp = to_float3(0.5f*FAR, FAR, 1.5f*FAR) + to_float3(0, 0, ro.z);

        *gRO = ro+to_float3(0,0,1);

        swi2S((*gRO),x,y, path((*gRO).z, ampA, freqA, ampB, freqB, UfoPath) + swi2(View[0],x,y));
        float3 p2 = to_float3_aw(path((*gRO).z+1.0f, ampA, freqA, ampB, freqB, UfoPath), (*gRO).z+1.0f);

        forward = normalize(p2 - *gRO + View[2]);
        right = normalize(to_float3(forward.z, 0, -forward.x ));
        swi2S(right,x,y, mul_f2_mat2(swi2(right,x,y) , rot2( path(lookAt.z, ampA, freqA, ampB, freqB, UfoPath).x/32.0f)));
        up = cross(forward, right);
        *gbaseShip = to_mat3_f3(forward, up, right);//mul_mat3_mat3(to_mat3_f3(forward, up, right) , m);//to_mat3_f3(forward, up, right);//

        float dist = _mix(35.0f, 15.0f, smoothstep(7000.0f,8500.0f, (*gRO).z));
        dist = _mix(dist, 45.0f, smoothstep(10000.0f,12000.0f, (*gRO).z));
        ro += (dist*(0.5f+0.5f*_cosf(CamSwivel?0.0f:0.31f*Time))+2.0f)*to_float3(0.3f,1,-2.0f);
        ro.x += 0.3f*dist*_cosf(CamSwivel?0.0f:0.31f*Time);

        ro += View[3];

        float t = logBisectTrace(ro, rd, gedge, gedge2, glastt, EDGE_WIDTH, PRECISE, *gbaseShip, *gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
        ed = *gedge; ed2 = *gedge2;  lastt1 = *glastt;

        float3 sky = getSky(ro, rd, normalize(lp - ro));

        col = sky;

        float2 mapCol = mapColor(ro+t*rd, *gbaseShip, *gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);

        float3 sp=to_float3_s(0.0f);
        float cur=0.0f;
        if (t < FAR){

            sp = ro+t*rd; // Surface point.
            float3 sn = normal(sp, *gbaseShip, *gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel); // Surface normal.
            float3 ld = lp-sp;
            ld /= _fmaxf(length(ld), 0.001f); // Normalize the light direct vector.

            float shd = softShadow(sp, ld, 0.1f, FAR, 8.0f, *gbaseShip, *gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel); // Shadows.
            cur = curve(sp, *gbaseShip, *gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel);
            float curv = cur*0.9f +0.1f; // Surface curvature.

            float ao = 1.0f;//calculateAO(sp, sn, 4.0f, channel); // Ambient occlusion.
            if (WITH_AO)
              ao = calculateAO(sp, sn, 4.0f, *gbaseShip, *gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, channel); // Ambient occlusion.

            float dif = _fmaxf( dot( ld, sn ), 0.0f); // Diffuse term.
            float spe = _powf(_fmaxf( dot( reflect(-ld, sn), -rd ), 0.0f ), 5.0f); // Specular term.
            float fre = clamp(1.0f + dot(rd, sn), 0.0f, 1.0f); // Fresnel reflection term.
            float Schlick = _powf( 1.0f - _fmaxf(dot(rd, normalize(rd + ld)), 0.0f), 5.0f);
            float fre2 = _mix(0.2f, 1.0f, Schlick);  //F0 = 0.2f - Hard clay... or close enough.
            float amb = fre*fre2 + 0.06f*ao;

            //col = clamp(_mix(to_float3(0.8f, 0.5f, 0.3f), to_float3(0.5f, 0.25f, 0.125f),(sp.y+1.0f)*0.15f), to_float3(0.5f, 0.25f, 0.125f), to_float3_s(1));
            col = clamp(_mix(Colors[0], Colors[1],(sp.y+1.0f)*0.15f), Colors[2], to_float3_s(1));
            col = pow_f3(col, to_float3_s(1.5f));
            col = (col*(dif + 0.1f) + fre2*spe)*shd*ao + amb*col;
        }

        col = pow_f3(_fmaxf(col, to_float3_s(0.0f)), to_float3_s(0.75f));

        u = fragCoord/Resolution;

        float3 cGround = Colors[4];// to_float3(248,210,155)/256.0f;
        float3 cSky    = Colors[3];// to_float3(177,186,213)/256.0f;

        if (t < FAR){

            float3 cFill;
            if (mapCol.y == ID_PATH) {
                cFill = Colors[7];//to_float3(1,0.01f,0.01f);//_mix(to_float3(248,210,155)/256.0f, to_float3(248,185,155)/256.0f, smoothstep(12.0f,12.1f,(sp.y)));
            }
            else if (mapCol.y == ID_SHIP) {
                float3 pShip = mul_f3_mat3((sp - *gRO), *gbaseShip);
                //cFill = _mix(to_float3(0,1,1),to_float3_s(0.7f),smoothstep(0.0f,0.1f, pShip.x-1.3f));
                cFill = _mix(Colors[5], Colors[6],smoothstep(0.0f,0.1f, pShip.x-1.3f));
            } else {
                cFill = _mix(to_float3(248,210,155)/256.0f, to_float3(248,185,155)/256.0f, smoothstep(0.0f,0.1f,sp.y-8.0f));
                cFill = _mix(cFill, to_float3(1,0,0), 0.4f*smoothstep(1000.0f,3000.0f, (*gRO).z));
                float3 col3 = _cosf(sp.y*0.08f+1.1f)*clamp(_mix(to_float3(0.8f, 0.5f, 0.3f), to_float3(0.5f, 0.25f, 0.125f),(sp.y+1.0f)*0.15f), to_float3(0.5f, 0.25f, 0.125f), to_float3_s(1));

                cFill = _mix(cFill, col3, 0.5f*smoothstep(6000.0f,8500.0f, (*gRO).z));
            }

            col = _mix(cFill,cSky,t/FAR)*(0.5f+0.5f*smoothstep(0.4f,0.5f,length(col)));
            col = _mix(col, to_float3_s(0.0f), ed);
            col = _mix(to_float3_s(0), col, 0.5f+0.5f*smoothstep(0.4f,0.41f,cur)); // Surface curvature.;
            ed2 += cur<0.35f?1.0f:0.0f;

        } else {
            col = _mix(cSky*_fabs(1.0f-rd.y),to_float3_s(1),smoothstep(1.3f,1.4f,length(col)));
            col = _mix(col, to_float3_s(0.1f), ed);
            float sun = _fmaxf(dot(rd, normalize(lp - ro)), 0.0f); // Sun strength.
            col = _mix(to_float3_s(0), col, smoothstep(0.09f/Resolution.y,0.2f/Resolution.y, _fabs(sun-0.9892f)));//.zyx;
        }
        col = _mix(col, cSky*_fabs(1.0f-rd.y), _sqrtf(smoothstep(FAR - (ed <0.0f ? 200.0f : 100.0f), FAR, lastt1)));
    }
    // BD frame
    col = _mix(col, to_float3_s(0.2f),smoothstep(0.0f,1.0f/Resolution.y,dBox));
    col = _mix(col, to_float3_s(0.0f),smoothstep(1.0f/Resolution.y,0.0f,_fabs(dBox)-0.005f));

    return to_float4_aw(clamp(col, 0.0f, 1.0f), ed2);
}

// ----------------------------------------------------------------------------------
// - Buffer A                                                                       -
// ----------------------------------------------------------------------------------
// Connect Buffer A 'Texture: Pebbles' to iChannel0



__KERNEL__ void CartoonRideFuse__Buffer_A(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);

  bool   WITH_AO = params->WITH_AO;
  bool   PRECISE = params->PRECISE;
  bool   WITH_AA = params->WITH_AA;
  bool   CamSwivel = params->CamSwivel;
  float4 Color1 = to_float4(params->Color1[0], params->Color1[1], params->Color1[2], params->Color1[3]);
  float4 ColorOut = to_float4(params->ColorOut[0], params->ColorOut[1], params->ColorOut[2], params->ColorOut[3]);
  float4 Color2 = to_float4(params->Color2[0], params->Color2[1], params->Color2[2], params->Color2[3]);
  float4 Color3 = to_float4(params->Color3[0], params->Color3[1], params->Color3[2], params->Color3[3]);
  float4 ColorSky = to_float4(params->ColorSky[0], params->ColorSky[1], params->ColorSky[2], params->ColorSky[3]);
  float4 ColorGround = to_float4(params->ColorGround[0], params->ColorGround[1], params->ColorGround[2], params->ColorGround[3]);
  float4 ColorShip1 = to_float4(params->ColorShip1[0], params->ColorShip1[1], params->ColorShip1[2], params->ColorShip1[3]);
  float4 ColorShip2 = to_float4(params->ColorShip2[0], params->ColorShip2[1], params->ColorShip2[2], params->ColorShip2[3]);
  float4 ColorPath = to_float4(params->ColorPath[0], params->ColorPath[1], params->ColorPath[2], params->ColorPath[3]);
  float2 ViewDXY = to_float2(params->ViewDXY[0], params->ViewDXY[1]);
  float  ViewDZ = params->ViewDZ;
  float2 ViewXY = to_float2(params->ViewXY[0], params->ViewXY[1]);
  float  ViewZ = params->ViewZ;
  float  EDGE_WIDTH = params->EDGE_WIDTH;
  float  freqA = params->freqA;
  float  freqB = params->freqB;
  float  ampA = params->ampA;
  float  ampB = params->ampB;
  float  FOV = params->FOV;
  float2 FwdXY = to_float2(params->FwdXY[0], params->FwdXY[1]);
  float  FwdZ = params->FwdZ;
  float2 UpXY = to_float2(params->UpXY[0], params->UpXY[1]);
  float  UpZ = params->UpZ;
  float2 RightXY = to_float2(params->RightXY[0], params->RightXY[1]);
  float  RightZ = params->RightZ;
  float  SwivelAngel = params->SwivelAngel;
  float  SwivelTempo = params->SwivelTempo;
  float2 Swivel = to_float2(params->Swivel[0], params->Swivel[1]);
  float  TNL = params->TNL;
  float2 TNLOffset = to_float2(params->TNLOffset[0], params->TNLOffset[1]);
  float2 UVOffset = to_float2(params->UVOffset[0], params->UVOffset[1]);
  float2 SDBox = to_float2(params->SDBox[0], params->SDBox[1]);

  // --------

    //#define EDGE_WIDTH 5e-3f

    fragCoord+=0.5f;

    float3 View[5] = {to_float3_aw(ViewXY, ViewZ), to_float3_aw(ViewDXY, ViewDZ), to_float3_aw(FwdXY, FwdZ), to_float3_aw(UpXY, UpZ), to_float3_aw(RightXY, RightZ) };
    float3 Colors[8] = {swi3(Color1,x,y,z), swi3(Color2,x,y,z), swi3(Color3,x,y,z), swi3(ColorSky,x,y,z), swi3(ColorGround,x,y,z), swi3(ColorShip1,x,y,z), swi3(ColorShip2,x,y,z), swi3(ColorPath,x,y,z)};

    float2 UfoPath = swi2(iMouse,x,y)/iResolution;

    // Frequencies and amplitudes of the "path" function, used to shape the tunnel and guide the camera.
    //const float freqA = 0.34f*0.15f/3.75f;
    //const float freqB = 0.25f*0.25f/2.75f;
    //const float ampA = 20.0f;
    //const float ampB = 4.0f;

    float3 gRO;
    mat3 gbaseShip;

    float gedge;
    float gedge2;
    float glastt;

    //float FOV = 3.14159f/2.0f; // FOV - Field of view.

    fragColor = render(fragCoord+UVOffset*iResolution, iTime, iResolution, iMouse, SDBox, CamSwivel, Swivel, SwivelAngel, SwivelTempo, View, Colors, WITH_AO, FOV, &gedge, &gedge2, &glastt, EDGE_WIDTH, PRECISE, &gbaseShip, &gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, iChannel0);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
// ----------------------------------------------------------------------------------
// - Image                                                                          -
// ----------------------------------------------------------------------------------
// Connect Image 'Previsualization: Buffer A' to iChannel0

// based on one desert canyon of the fantastic Shane shader

// best for small size
//#define WITH_AA

__KERNEL__ void CartoonRideFuse(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);

  bool   WITH_AO = params->WITH_AO;
  bool   PRECISE = params->PRECISE;
  bool   WITH_AA = params->WITH_AA;
  bool   CamSwivel = params->CamSwivel;
  float4 Color1 = to_float4(params->Color1[0], params->Color1[1], params->Color1[2], params->Color1[3]);
  float4 ColorOut = to_float4(params->ColorOut[0], params->ColorOut[1], params->ColorOut[2], params->ColorOut[3]);
  float4 Color2 = to_float4(params->Color2[0], params->Color2[1], params->Color2[2], params->Color2[3]);
  float4 Color3 = to_float4(params->Color3[0], params->Color3[1], params->Color3[2], params->Color3[3]);
  float4 ColorSky = to_float4(params->ColorSky[0], params->ColorSky[1], params->ColorSky[2], params->ColorSky[3]);
  float4 ColorGround = to_float4(params->ColorGround[0], params->ColorGround[1], params->ColorGround[2], params->ColorGround[3]);
  float4 ColorShip1 = to_float4(params->ColorShip1[0], params->ColorShip1[1], params->ColorShip1[2], params->ColorShip1[3]);
  float4 ColorShip2 = to_float4(params->ColorShip2[0], params->ColorShip2[1], params->ColorShip2[2], params->ColorShip2[3]);
  float4 ColorPath = to_float4(params->ColorPath[0], params->ColorPath[1], params->ColorPath[2], params->ColorPath[3]);
  float2 ViewDXY = to_float2(params->ViewDXY[0], params->ViewDXY[1]);
  float  ViewDZ = params->ViewDZ;
  float2 ViewXY = to_float2(params->ViewXY[0], params->ViewXY[1]);
  float  ViewZ = params->ViewZ;
  float  EDGE_WIDTH = params->EDGE_WIDTH;
  float  freqA = params->freqA;
  float  freqB = params->freqB;
  float  ampA = params->ampA;
  float  ampB = params->ampB;
  float  FOV = params->FOV;
  float2 FwdXY = to_float2(params->FwdXY[0], params->FwdXY[1]);
  float  FwdZ = params->FwdZ;
  float2 UpXY = to_float2(params->UpXY[0], params->UpXY[1]);
  float  UpZ = params->UpZ;
  float2 RightXY = to_float2(params->RightXY[0], params->RightXY[1]);
  float  RightZ = params->RightZ;
  float  SwivelAngel = params->SwivelAngel;
  float  SwivelTempo = params->SwivelTempo;
  float2 Swivel = to_float2(params->Swivel[0], params->Swivel[1]);
  float  TNL = params->TNL;
  float2 TNLOffset = to_float2(params->TNLOffset[0], params->TNLOffset[1]);
  float2 UVOffset = to_float2(params->UVOffset[0], params->UVOffset[1]);
  float2 SDBox = to_float2(params->SDBox[0], params->SDBox[1]);

  // --------

    //#define EDGE_WIDTH 5e-3f

    fragCoord+=0.5f;

    // Frequencies and amplitudes of the "path" function, used to shape the tunnel and guide the camera.
    //const float freqA = 0.34f*0.15f/3.75f;
    //const float freqB = 0.25f*0.25f/2.75f;
    //const float ampA = 20.0f;
    //const float ampB = 4.0f;

    float3 View[5] = {to_float3_aw(ViewDXY, ViewDZ), to_float3_aw(ViewDXY, ViewDZ), to_float3_aw(FwdXY, FwdZ), to_float3_aw(UpXY, UpZ), to_float3_aw(RightXY, RightZ) };
    float3 Colors[8] = {swi3(Color1,x,y,z), swi3(Color2,x,y,z), swi3(Color3,x,y,z), swi3(ColorSky,x,y,z), swi3(ColorGround,x,y,z), swi3(ColorShip1,x,y,z), swi3(ColorShip2,x,y,z), swi3(ColorPath,x,y,z)};

    float2 UfoPath = swi2(iMouse,x,y)/iResolution;

    float3 gRO;
    mat3 gbaseShip;

    float gedge;
    float gedge2;
    float glastt;

    //float FOV = 3.14159f/2.0f; // FOV - Field of view.

    float2 uv = fragCoord/iResolution;
    float4 res = _tex2DVecN(iChannel0,uv.x,uv.y,15);

    if (WITH_AA)
    {
      float3 dp = to_float3_aw(1.0f/iResolution, 0);
      float needAA = 0.0f;
      for (int j=-1; j<3; j++) {
          for (int i=-1; i<3; i++) {
              needAA += _tex2DVecN(iChannel0,uv.x,uv.y,15).w;
          }
      }

      // Antialising only on edges and big curvature
      if (needAA > 0.5f) {
        for (int k=0; k<4; k++)
            res += render(fragCoord+0.66f*to_float2(k%2-1,k/2-1)-0.33f+UVOffset*iResolution, iTime, iResolution, iMouse, SDBox, CamSwivel, Swivel, SwivelAngel, SwivelTempo, View, Colors, WITH_AO, FOV, &gedge, &gedge2, &glastt, EDGE_WIDTH, PRECISE, &gbaseShip, &gRO, ampA, freqA, ampB, freqB, UfoPath, TNL, TNLOffset, iChannel0);
          res /= 5.0f;
      }
    }
    fragColor = res;

    fragColor = to_float4_aw(swi3(fragColor,x,y,z) * (swi3(ColorOut,x,y,z) + 0.5f), ColorOut.w == 0.0 ? fragColor.w : ColorOut.w);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
]]
-- /*


-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ShaderFuse.begin_create()

  ----- Inspector Panel Controls

  
  -- Speed Slider
  
  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",
  })
  
  -- iMouse Controls
  
  InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
  })
  
  InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
    INP_Disabled = true,
  })
  
  InMouseDrag = self:AddInput("Mouse Button Pressed", "iMouseClick", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = false,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0,
  })
  InWITH_AOCheckbox = self:AddInput("WITH_AO", "WITH_AO", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  InPRECISECheckbox = self:AddInput("PRECISE", "PRECISE", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  InWITH_AACheckbox = self:AddInput("WITH_AA", "WITH_AA", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 1,
  })

  InCamSwivelCheckbox = self:AddInput("CamSwivel", "CamSwivel", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  self:BeginControlNest("Colors", "Colors", false, {})
  self:BeginControlNest("Color1", "Color1", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Color1",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColor1ColorR = self:AddInput("Red",   "Color1Red",   { INP_Default  = 0.8, IC_ControlID = 0, attrs})
    InColor1ColorG = self:AddInput("Green", "Color1Green", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColor1ColorB = self:AddInput("Blue",  "Color1Blue",  { INP_Default  = 0.3, IC_ControlID = 2, attrs})
    InColor1ColorA = self:AddInput("Alpha", "Color1Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColorOut", "ColorOut", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColorOut",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColorOutColorR = self:AddInput("Red",   "ColorOutRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColorOutColorG = self:AddInput("Green", "ColorOutGreen", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InColorOutColorB = self:AddInput("Blue",  "ColorOutBlue",  { INP_Default  = 0.5, IC_ControlID = 2, attrs})
    InColorOutColorA = self:AddInput("Alpha", "ColorOutAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Color2", "Color2", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Color2",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColor2ColorR = self:AddInput("Red",   "Color2Red",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColor2ColorG = self:AddInput("Green", "Color2Green", { INP_Default  = 0.25, IC_ControlID = 1, attrs})
    InColor2ColorB = self:AddInput("Blue",  "Color2Blue",  { INP_Default  = 0.125, IC_ControlID = 2, attrs})
    InColor2ColorA = self:AddInput("Alpha", "Color2Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Color3", "Color3", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Color3",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColor3ColorR = self:AddInput("Red",   "Color3Red",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InColor3ColorG = self:AddInput("Green", "Color3Green", { INP_Default  = 0.25, IC_ControlID = 1, attrs})
    InColor3ColorB = self:AddInput("Blue",  "Color3Blue",  { INP_Default  = 0.125, IC_ControlID = 2, attrs})
    InColor3ColorA = self:AddInput("Alpha", "Color3Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColorSky", "ColorSky", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColorSky",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColorSkyColorR = self:AddInput("Red",   "ColorSkyRed",   { INP_Default  = 0.69, IC_ControlID = 0, attrs})
    InColorSkyColorG = self:AddInput("Green", "ColorSkyGreen", { INP_Default  = 0.73, IC_ControlID = 1, attrs})
    InColorSkyColorB = self:AddInput("Blue",  "ColorSkyBlue",  { INP_Default  = 0.83, IC_ControlID = 2, attrs})
    InColorSkyColorA = self:AddInput("Alpha", "ColorSkyAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColorGround", "ColorGround", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColorGround",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColorGroundColorR = self:AddInput("Red",   "ColorGroundRed",   { INP_Default  = 0.969, IC_ControlID = 0, attrs})
    InColorGroundColorG = self:AddInput("Green", "ColorGroundGreen", { INP_Default  = 0.82, IC_ControlID = 1, attrs})
    InColorGroundColorB = self:AddInput("Blue",  "ColorGroundBlue",  { INP_Default  = 0.608, IC_ControlID = 2, attrs})
    InColorGroundColorA = self:AddInput("Alpha", "ColorGroundAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColorShip1", "ColorShip1", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColorShip1",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColorShip1ColorR = self:AddInput("Red",   "ColorShip1Red",   { INP_Default  = 0.0, IC_ControlID = 0, attrs})
    InColorShip1ColorG = self:AddInput("Green", "ColorShip1Green", { INP_Default  = 1.0, IC_ControlID = 1, attrs})
    InColorShip1ColorB = self:AddInput("Blue",  "ColorShip1Blue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InColorShip1ColorA = self:AddInput("Alpha", "ColorShip1Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColorShip2", "ColorShip2", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColorShip2",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColorShip2ColorR = self:AddInput("Red",   "ColorShip2Red",   { INP_Default  = 0.7, IC_ControlID = 0, attrs})
    InColorShip2ColorG = self:AddInput("Green", "ColorShip2Green", { INP_Default  = 0.7, IC_ControlID = 1, attrs})
    InColorShip2ColorB = self:AddInput("Blue",  "ColorShip2Blue",  { INP_Default  = 0.7, IC_ControlID = 2, attrs})
    InColorShip2ColorA = self:AddInput("Alpha", "ColorShip2Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("ColorPath", "ColorPath", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColorPath",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColorPathColorR = self:AddInput("Red",   "ColorPathRed",   { INP_Default  = 1.0, IC_ControlID = 0, attrs})
    InColorPathColorG = self:AddInput("Green", "ColorPathGreen", { INP_Default  = 0.01, IC_ControlID = 1, attrs})
    InColorPathColorB = self:AddInput("Blue",  "ColorPathBlue",  { INP_Default  = 0.01, IC_ControlID = 2, attrs})
    InColorPathColorA = self:AddInput("Alpha", "ColorPathAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()
  self:EndControlNest()

  InViewDXYPoint = self:AddInput("ViewDXY", "ViewDXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InViewDZSlider = self:AddInput("ViewDZ", "ViewDZ", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InViewXYPoint = self:AddInput("ViewXY", "ViewXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InViewZSlider = self:AddInput("ViewZ", "ViewZ", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InEDGE_WIDTHSlider = self:AddInput("EDGE_WIDTH", "EDGE_WIDTH", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.0005,
      })

  InfreqASlider = self:AddInput("freqA", "freqA", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.0136,
      })

  InfreqBSlider = self:AddInput("freqB", "freqB", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.0227,
      })

  InampASlider = self:AddInput("ampA", "ampA", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 100.0,
          INP_Default        = 20.0,
      })

  InampBSlider = self:AddInput("ampB", "ampB", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 4.0,
      })

  InFOVSlider = self:AddInput("FOV", "FOV", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 5.0,
          INP_Default        = 1.570845,
      })

  InFwdXYPoint = self:AddInput("FwdXY", "FwdXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InFwdZSlider = self:AddInput("FwdZ", "FwdZ", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InUpXYPoint = self:AddInput("UpXY", "UpXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InUpZSlider = self:AddInput("UpZ", "UpZ", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InRightXYPoint = self:AddInput("RightXY", "RightXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InRightZSlider = self:AddInput("RightZ", "RightZ", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InSwivelAngelSlider = self:AddInput("SwivelAngel", "SwivelAngel", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 100.0,
          INP_Default        = 1.0,
      })

  InSwivelTempoSlider = self:AddInput("SwivelTempo", "SwivelTempo", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 100.0,
          INP_Default        = 1.0,
      })

  InSwivelPoint = self:AddInput("Swivel", "Swivel", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InTNLSlider = self:AddInput("TNL", "TNL", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 100.0,
          INP_Default        = 0.0,
      })

  InTNLOffsetPoint = self:AddInput("TNLOffset", "TNLOffset", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InUVOffsetPoint = self:AddInput("UVOffset", "UVOffset", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InSDBoxPoint = self:AddInput("SDBox", "SDBox", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })


  Sep3 = self:AddInput(string.rep("_", 152), "Separator3", {
    LINKID_DataType     = "Text",
    INPID_InputControl  = "LabelControl",
    INP_External        = false,
    INP_Passive         = true,
    IC_Visible          = true,
    INP_DoNotifyChanged = true,
    IC_NoLabel          = true,
  })
    
  InEdges = self:AddInput("Edges", "Edges", {
    LINKID_DataType = "Number",
    INPID_InputControl  = "MultiButtonControl",
    INP_Default         = 3.0,
    INP_Integer         = true,
    INP_DoNotifyChanged = true,
    INP_External        = false,
    MBTNC_ForceButtons  = true,
    INP_MinScale        = 0,
    INP_MaxScale        = 3,
    INP_MinAllowed      = 0,
    INP_MaxAllowed      = 3,
    MBTNC_ShowBasicButton = true,
    MBTNC_StretchToFit  = false, --true,
    MBTNC_ShowToolTip   = true,
    { MBTNC_AddButton = "Canvas", MBTNCD_ButtonWidth = 4/16, },
    { MBTNC_AddButton = "Wrap",MBTNCD_ButtonWidth = 3/16, },
    { MBTNC_AddButton = "Duplicate", MBTNCD_ButtonWidth = 5/16, },
    { MBTNC_AddButton = "Mirror", MBTNCD_ButtonWidth = 4/16, }, 
   }) 

  InDebugImage = self:AddInput("DebugImage", "DebugImage", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Final", },
    { CCS_AddString = "BufferA", },
    CC_LabelPosition = "Horizontal",
  })

  ----- Size & Depth
  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default        = 0,
    INP_Integer        = true,
    ICD_Width          = 1,
	  { CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	  { CCS_AddString  = "Image0", },
    { CCS_AddString  = "1920x1080", },
	  { CCS_AddString  = "1200x675", },
	  { CCS_AddString  = "800x450", },
	  { CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer     = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer     = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
  
  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
    { CCS_AddString  = "Default", },
	  { CCS_AddString  = "int8", },
	  { CCS_AddString  = "int16", },
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false }) 

  ----- In/Out

  InChannel0 = self:AddInput( "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main       = 1,
  })


  ShaderFuse.end_create()

end


-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------
function DefineEdges(edges, nodeX)

    --This gets the value of our input image for us to modify inside the kernel
    if edges == 0 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 1 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_WRAP, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 2 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_DUPLICATE, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 3 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 4 then
      --print("Sampler 4")
    end
end



MULTIBUFFER = true
if MULTIBUFFER then   -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  ImgAttrs_Global = {
          { IMG_Channel = "Red", },
          { IMG_Channel = "Green", },
          { IMG_Channel = "Blue", },
          { IMG_Channel = "Alpha", },
          IMG_Width = Width,
          IMG_Height = Height,
          IMG_DeferAlloc = false,
          }

  Image_Buff_GlobalA = Image(ImgAttrs_Global)
end


function Process(req)

	-- Imagesize and Depth
  if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InChannel0:GetValue(req) ~= nil) then
			   Width = InChannel0:GetValue(req).Width
			   Height = InChannel0:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value 
		end
	end	
  
  -- Alle ( int und float )
  if (InDepth:GetValue(req).Value > 0) then
	  if InDepth:GetValue(req).Value == 1 then 
	    SourceDepth = 5 
    else 
	    if InDepth:GetValue(req).Value == 2 then 
	        SourceDepth = 6 
	    else 
	        if InDepth:GetValue(req).Value == 3 then 
 		        SourceDepth = 7 
		    	else
			      SourceDepth = 8
	        end
		  end
	  end
	end

  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth  = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }

  local dst   = Image(imgattrs)
  local black = Pixel({R=0,G=0,B=0,A=0})
  dst:Fill(black)

if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  dstA = Image {IMG_Like = dst, IMG_DeferAlloc = true}
end

  if req:IsPreCalc() then
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end


if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA = DVIPComputeNode(req,
    "CartoonRideFuse__Buffer_A", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
else
    node = DVIPComputeNode(req,
    "CartoonRideFuse", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
end
  -- Extern texture or create a new one

  iChannel0 = InChannel0:GetValue(req)

  if iChannel0==nil then
    iChannel0 = Image(imgattrs)
    iChannel0:Fill(black)
  end

  -- DCTL parameters

  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    params = nodeA:GetParamBlock(ShaderParameters)
  else  
    params = node:GetParamBlock(ShaderParameters)
  end  

  params.iResolution[0] = dst.Width
  params.iResolution[1] = dst.Height
  params.iTime = (req.Time / framerate) * InFrequency:GetValue(req).Value
  
  -- iMouse
  
  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)
  
  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y
  
  if InMouseDrag:GetValue(req).Value ~= 0 then
    if params.iMouse[2]==-1 and params.iMouse[3]==-1 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = -1
    params.iMouse[3] = -1
  end
  
  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end
  
  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  if params.iMouse[2] == -1 and params.iMouse[3] == -1 then
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  else
    params.iMouse[2] = params.iMouse[2] * Width
    params.iMouse[3] = params.iMouse[3] * Height
  end

  params.WITH_AO = InWITH_AOCheckbox:GetValue(req).Value
  params.PRECISE = InPRECISECheckbox:GetValue(req).Value
  params.WITH_AA = InWITH_AACheckbox:GetValue(req).Value
  params.CamSwivel = InCamSwivelCheckbox:GetValue(req).Value
  params.Color1 = {
    InColor1ColorR:GetValue(req).Value,
    InColor1ColorG:GetValue(req).Value,
    InColor1ColorB:GetValue(req).Value,InColor1ColorA:GetValue(req).Value
  }
  params.ColorOut = {
    InColorOutColorR:GetValue(req).Value,
    InColorOutColorG:GetValue(req).Value,
    InColorOutColorB:GetValue(req).Value,InColorOutColorA:GetValue(req).Value
  }
  params.Color2 = {
    InColor2ColorR:GetValue(req).Value,
    InColor2ColorG:GetValue(req).Value,
    InColor2ColorB:GetValue(req).Value,InColor2ColorA:GetValue(req).Value
  }
  params.Color3 = {
    InColor3ColorR:GetValue(req).Value,
    InColor3ColorG:GetValue(req).Value,
    InColor3ColorB:GetValue(req).Value,InColor3ColorA:GetValue(req).Value
  }
  params.ColorSky = {
    InColorSkyColorR:GetValue(req).Value,
    InColorSkyColorG:GetValue(req).Value,
    InColorSkyColorB:GetValue(req).Value,InColorSkyColorA:GetValue(req).Value
  }
  params.ColorGround = {
    InColorGroundColorR:GetValue(req).Value,
    InColorGroundColorG:GetValue(req).Value,
    InColorGroundColorB:GetValue(req).Value,InColorGroundColorA:GetValue(req).Value
  }
  params.ColorShip1 = {
    InColorShip1ColorR:GetValue(req).Value,
    InColorShip1ColorG:GetValue(req).Value,
    InColorShip1ColorB:GetValue(req).Value,InColorShip1ColorA:GetValue(req).Value
  }
  params.ColorShip2 = {
    InColorShip2ColorR:GetValue(req).Value,
    InColorShip2ColorG:GetValue(req).Value,
    InColorShip2ColorB:GetValue(req).Value,InColorShip2ColorA:GetValue(req).Value
  }
  params.ColorPath = {
    InColorPathColorR:GetValue(req).Value,
    InColorPathColorG:GetValue(req).Value,
    InColorPathColorB:GetValue(req).Value,InColorPathColorA:GetValue(req).Value
  }
  params.ViewDXY = {InViewDXYPoint:GetValue(req).X,InViewDXYPoint:GetValue(req).Y}
  params.ViewDZ = InViewDZSlider:GetValue(req).Value
  params.ViewXY = {InViewXYPoint:GetValue(req).X,InViewXYPoint:GetValue(req).Y}
  params.ViewZ = InViewZSlider:GetValue(req).Value
  params.EDGE_WIDTH = InEDGE_WIDTHSlider:GetValue(req).Value
  params.freqA = InfreqASlider:GetValue(req).Value
  params.freqB = InfreqBSlider:GetValue(req).Value
  params.ampA = InampASlider:GetValue(req).Value
  params.ampB = InampBSlider:GetValue(req).Value
  params.FOV = InFOVSlider:GetValue(req).Value
  params.FwdXY = {InFwdXYPoint:GetValue(req).X,InFwdXYPoint:GetValue(req).Y}
  params.FwdZ = InFwdZSlider:GetValue(req).Value
  params.UpXY = {InUpXYPoint:GetValue(req).X,InUpXYPoint:GetValue(req).Y}
  params.UpZ = InUpZSlider:GetValue(req).Value
  params.RightXY = {InRightXYPoint:GetValue(req).X,InRightXYPoint:GetValue(req).Y}
  params.RightZ = InRightZSlider:GetValue(req).Value
  params.SwivelAngel = InSwivelAngelSlider:GetValue(req).Value
  params.SwivelTempo = InSwivelTempoSlider:GetValue(req).Value
  params.Swivel = {InSwivelPoint:GetValue(req).X,InSwivelPoint:GetValue(req).Y}
  params.TNL = InTNLSlider:GetValue(req).Value
  params.TNLOffset = {InTNLOffsetPoint:GetValue(req).X,InTNLOffsetPoint:GetValue(req).Y}
  params.UVOffset = {InUVOffsetPoint:GetValue(req).X,InUVOffsetPoint:GetValue(req).Y}
  params.SDBox = {InSDBoxPoint:GetValue(req).X,InSDBoxPoint:GetValue(req).Y}

  -- Resolution

  params.width  = dst.Width
  params.height = dst.Height

  -- Per channel time and resolution
  local edges = InEdges:GetValue(req).Value

  -- Set parameters and add I/O
  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA:SetParamBlock(params)
    --nodeA:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, nodeA)
  else   
    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)
    node:AddInput("iChannel0",iChannel0) -- TODO: add a better channel name
    node:AddOutput("dst", dst)
  end
  
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA:AddInput("iChannel0", iChannel0)  -- Anpassen !!
    nodeA:AddOutput("dst", dstA)

    local ok = nodeA:RunSession(req)

    if (not ok) then
      dstA = nil
      dump(nodeA:GetErrorLog())
    end
    
    Image_Buff_GlobalA = dstA

    -------------------------- ImageKernel----------------------------------------
    node = DVIPComputeNode(req,
      "CartoonRideFuse", ShaderCompatibilityCode..ShaderKernelCode,
      "Params", ShaderParameters
    )

    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)

    node:AddInput("iChannel0", Image_Buff_GlobalA)  -- Anpassen !!
    node:AddOutput("dst", dst)
 
  end -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 

  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    dump(node:GetErrorLog())
	end

  OutImage:Set(req,dst)
  
  
  --Debugging
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER
    InDebugImage:SetAttrs({ IC_Visible = true })
    
    if (InDebugImage:GetValue(req).Value == 1) then OutImage:Set(req, Image_Buff_GlobalA) end
  else
    InDebugImage:SetAttrs({ IC_Visible = false })
  end
  
  collectgarbage();
end

-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

function NotifyChanged(inp, param, time)
 	if (param ~= nil) then

		if inp == InSize then
		  if param.Value == 1 then
			  InWidth:SetAttrs({ IC_Visible = true })
			  InHeight:SetAttrs({ IC_Visible = true })
		  else
			  InWidth:SetAttrs({ IC_Visible = false })
			  InHeight:SetAttrs({ IC_Visible = false })
		  end
		  
		  if param.Value == 3 then --1920x1080
			  InWidth:SetSource(Number(1920),0,0)
			  InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			  InWidth:SetSource(Number(1200),0,0)
			  InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			  InWidth:SetSource(Number(800),0,0)
			  InHeight:SetSource(Number(450),0,0)
		  end
 	    if param.Value == 6 then --640x360
		    InWidth:SetSource(Number(640),0,0)
		    InHeight:SetSource(Number(360),0,0)
		  end
		end 

 	end
end


-- */
