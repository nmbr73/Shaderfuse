--[[--/*

  TwizzlyCircleMess.fuse

  Based on https://www.shadertoy.com/view/sltGRj a WebGL shader created by SnoopethDuckDuck.
  Converted to DCTL and embeddet into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT).
  Place this file in your Fusion's and/or DaVinci Resolve's 'Fuses/' folder to use it.

*/--]]--




-- /*
local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()



-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,
  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,
  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  })



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------

-- */
ShaderParameters =
[[

  float  iResolution[2];
  float  iTime;
  float  iMouse[4];
  float  Color[4];
  float  Brightness;

  int    width,height;
  int    compOrder;

]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel compatibility code
-- // ------------------------------------------------------------------------

-- */
ShaderCompatibilityCode =
[[


#if defined(DEVICE_IS_METAL)
  #define in
  #define out thread
  #define inout thread
#else
  #define in
  #define out
  #define inout
#endif

#undef USE_NATIVE_METAL_IMPL
#undef USE_NATIVE_CUDA_IMPL
#undef USE_NATIVE_OPENCL_IMPL

  // 0 to use the generic implementations; 1 for Metal, OpenCL, Cuda specific code if existing

  #if 1
    #if defined(DEVICE_IS_METAL)
      #define USE_NATIVE_METAL_IMPL   1
    #elif defined(DEVICE_IS_CUDA)
      #define USE_NATIVE_CUDA_IMPL    1
    #elif defined(DEVICE_IS_OPENCL)
      #define USE_NATIVE_OPENCL_IMPL  1
    #endif
  #endif

  #if defined(USE_NATIVE_METAL_IMPL)

    #define swi2(A,a,b)     (A).a##b
    #define swi3(A,a,b,c)   (A).a##b##c

    #define swi2S(a,b,c,d)   a.b##c = d

  #else

    #define swi2(A,a,b)     to_float2((A).a,(A).b)
    #define swi3(A,a,b,c)   to_float3((A).a,(A).b,(A).c)

    #define swi2S(a,b,c,d)   {float2 tmp = d; (a).b = tmp.x; (a).c = tmp.y;}

  #endif

// ----------------------------------------------------------------------------------------------------------
// mat2 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float2x2 mat2;

  #define to_mat2(A,B,C,D)   mat2((A),(B),(C),(D))

  #define mul_f2_mat2(A,B)   ((A)*(B))

#else

  typedef struct { float2 r0; float2 r1; } mat2;

  __DEVICE__ inline mat2 to_mat2      ( float  a, float  b, float c, float d)  { mat2 t; t.r0.x = a; t.r0.y = b; t.r1.x = c; t.r1.y = d;         return t; }

  __DEVICE__ inline float2 mul_f2_mat2( float2 v, mat2 m )
  {
    float2 t; t.x = v.x*m.r0.x + v.y*m.r0.y; t.y = v.x*m.r1.x + v.y*m.r1.y; return t;
  }

#endif // end of mat2 implementation

#if defined(USE_NATIVE_METAL_IMPL)

 #define fract_f2(A) fract(A)

 #define pow_f3(a,b) pow(a,b)
 #define refract_f3(I,N,eta) refract(I,N,eta)

#else

  #if defined(USE_NATIVE_OPENCL_IMPL)

    #define reflect(I,N) (I-2.0f*dot(N,I)*N)

    #define fract(a) ((a)-_floor(a))  // oder Pointer bauen: gentype fract(gentype x, gentype *itpr)

 #define fract_f2(A) to_float2(fract((A).x),fract((A).y))
 #define pow_f3(a,b) pow(a,b)

__DEVICE__ float3 refract_f3(float3 I, float3 N, float eta) {
   float dotNI = dot(N, I);
   float k = 1.0f - eta * eta * (1.0f - dotNI * dotNI);
   if (k < 0.0f) {
      return to_float3_s(0.0f);
   }
   return eta * I - (eta * dotNI * _sqrtf(k)) * N; //+0.5f;   * -01.50f;(MarchingCubes)  - 0.15f; (GlassDuck)
 }

 #else // Generic

 #if defined(DEVICE_IS_OPENCL)
   __DEVICE__ float3 reflect(float3 I, float3 N) {return I - 2.0f * dot(N, I) * N;}
 #endif

    #define fract(a) ((a)-_floor(a))

 #define fract_f2(A) to_float2(fract((A).x),fract((A).y))
 #define pow_f3(a,b) to_float3(_powf((a).x,(b).x),_powf((a).y,(b).y),_powf((a).z,(b).z))

 __DEVICE__ float3 refract_f3(float3 I, float3 N, float eta) {
    float dotNI = dot(N, I);
    float k = 1.0f - eta * eta * (1.0f - dotNI * dotNI);
    if (k < 0.0f) {
      return to_float3_s(0.0f);
    }
    return eta * I - (eta * dotNI * _sqrtf(k)) * N; //+0.5f;   * -01.50f;(MarchingCubes)  - 0.15f; (GlassDuck)
 }

  #endif

#endif

__DEVICE__ float4 decube_f3(__TEXTURE2D__ t, float3 xyz)
{
  float ax=_fabs(xyz.x);
  float ay=_fabs(xyz.y);
  float az=_fabs(xyz.z);

  if (xyz.x>0.0f && ax>=ay && ax>=az) // +X, Face 0, right
    return _tex2DVecN(t,(-xyz.z/ax+1.0f)/8.0f + 0.5f,(xyz.y/ax+1.0f)/6.0f + (1.0f/3.0f),15);

  if (xyz.y>0.0f && ay>=ax && ay>=az) // +Y, Face 2, top
    return _tex2DVecN(t,(xyz.x/ay+1.0f)/8.0f + 0.25f,(-xyz.z/ay+1.0f)/6.0f + (2.0f/3.0f),15);

  if (xyz.z>0.0f && az>=ax && az>=ay) // +Z, Face 4, front
    return _tex2DVecN(t,(xyz.x/az+1.0f)/8.0f + 0.25f,(xyz.y/az+1.0f)/6.0f + (1.0f/3.0f),15);

  if (xyz.x<0.0f && ax>=ay && ax>=az) // -X, Face 1, left
    return _tex2DVecN(t,(xyz.z/ax+1.0f)/8.0f,(xyz.y/ax+1.0f)/6.0f + (1.0f/3.0f),15);

  if (xyz.y<0.0f && ay>=ax && ay>=az) // -Y, Face 3, bottom
    return _tex2DVecN(t,(xyz.x/ay+1.0f)/8.0f + 0.25f,(xyz.z/ay+1.0f)/6.0f,15);

  if (xyz.z<0.0f && az>=ax && az>=ay) // -Z, Face 5, back
    return _tex2DVecN(t,(-xyz.x/az+1.0f)/8.0f + 0.75f,(xyz.y/az+1.0f)/6.0f + (1.0f/3.0f),15);

  return to_float4(1.0f,0.0f,0.0f,1.0f); // error
}


]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel implementation
-- // ------------------------------------------------------------------------

-- */
ShaderKernelCode =
[[

// ----------------------------------------------------------------------------------
// - Image                                                                          -
// ----------------------------------------------------------------------------------
// Connect Image 'Cubemap: Uffizi Gallery_0' to iChannel0
// Connect Image 'Cubemap: Uffizi Gallery Blurred_0' to iChannel1


// "RayMarching starting point"
// by Martijn Steinrucken aka The Art of Code/BigWings - 2020
// The MIT License
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// Email: countfrolic@gmail.com
// Twitter: @The_ArtOfCode
// YouTube: youtube.com/TheArtOfCodeIsCool
// Facebook: https://www.facebook.com/groups/theartofcode/
//
// You can use this shader as a template for ray marching shaders

// set these really low so my computer can handle it + dont mind the glitchy look
#define MAX_STEPS 40
#define MAX_DIST 20.0f
#define SURF_DIST 0.05f

#define S smoothstep
#define T iTime

__DEVICE__ mat2 Rot(float a) {
    float s=_sinf(a), c=_cosf(a);
    return to_mat2(c, -s, s, c);
}

__DEVICE__ float h21 (float2 a) {
    return fract(_sinf(dot(swi2(a,x,y), to_float2(12.9898f, 78.233f))) * 43758.5453123f);
}

__DEVICE__ float thc(float a, float b) {
    return _tanhf(a * _cosf(b)) / _tanhf(a);
}

__DEVICE__ float ths(float a, float b) {
    return _tanhf(a * _sinf(b)) / _tanhf(a);
}

__DEVICE__ float GetDist(float3 p, float iTime) {

    float sd = length(p - to_float3(0,1.5f + 0.5f * _cosf(iTime),0))
               - 0.6f  + 0.1f * _cosf(2.0f * iTime);

    float a = _atan2f(p.x, p.z);
    float l = length(swi2(p,x,z));
    float lf = length(fract_f2(swi2(p,x,z))-0.5f);
    //   p.y += 0.2f * thc(2.0f, 5.0f * l * (0.5f + 0.5f * thc(2.0f, 1.0f * l - iTime)) + a + 1.0f * iTime) / _coshf(0.35f * l);

    // float2 ipos = _floor(swi2(p,x,z)) - 0.0f;
    //vec2 fpos = fract(swi2(p,x,z)) - 0.25f;

    //p.y += 1.0f/_coshf(_mix(12.0f,40.0f, 0.5f + 0.5f * thc(4.0f, iTime + 11.0f * h21(ipos))) * lf);
    p.y *= 1.0f / _coshf(0.5f * l + _cosf(a + iTime));
    p.y += _mix(0.0f, 0.15f, 0.5f + 0.5f * thc(2.0f, 4.0f * l +  iTime)) * thc(4.0f, 4.0f * l + iTime);
    float d = dot(p, to_float3(0,1,0));//length(p) - 1.5f;

    return  _fminf(d, 1.0f * sd);
}

__DEVICE__ float RayMarch(float3 ro, float3 rd, float iTime) {
    float dO=0.0f;

    for(int i=0; i<MAX_STEPS; i++) {
      float3 p = ro + rd*dO;
        float dS = GetDist(p,iTime);
        dO += dS;
        if(dO>MAX_DIST || _fabs(dS)<SURF_DIST) break;
    }

    return dO;
}

__DEVICE__ float3 GetNormal(float3 p, float iTime) {
  float d = GetDist(p, iTime);
    float2 e = to_float2(0.001f, 0);

    float3 n = d - to_float3(
                            GetDist(p-swi3(e,x,y,y),iTime),
                            GetDist(p-swi3(e,y,x,y),iTime),
                            GetDist(p-swi3(e,y,y,x),iTime));

    return normalize(n);
}

__DEVICE__ float3 GetRayDir(float2 uv, float3 p, float3 l, float z) {
    float3 f = normalize(l-p),
        r = normalize(cross(to_float3(0,1,0), f)),
        u = cross(f,r),
        c = f*z,
        i = c + uv.x*r + uv.y*u,
        d = normalize(i);
    return d;
}

__DEVICE__ float3 Bg(float3 rd) {
    float k = rd.y*0.5f + 0.5f;

    float3 col = _mix(to_float3(0.5f,0.0f,0.0f),to_float3_s(0.0f),k);
    return col;
}


__KERNEL__ void TwizzlyCircleMessFuse(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0,  __TEXTURE2D__ iChannel1, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  float4 Color = to_float4(params->Color[0], params->Color[1], params->Color[2], params->Color[3]);
  float  Brightness = params->Brightness;

  // --------



    float2 uv = (fragCoord-0.5f*iResolution)/iResolution.y;
    float2 m = swi2(iMouse,x,y)/iResolution;
    float time = 0.25f * iTime;
    float3 ro = to_float3(4.0f * thc(5.0f,time), _mix(2.0f, 5.0f, 0.5f + 0.5f * thc(3.0f, 1.5f * time)), 4.0f * ths(5.0f,time));
    swi2S(ro,y,z, mul_f2_mat2(swi2(ro,y,z) , Rot(-m.y*3.14f+1.0f)));
    swi2S(ro,x,z, mul_f2_mat2(swi2(ro,x,z) , Rot(-m.x*6.2831f)));

    float3 rd = GetRayDir(uv, ro, to_float3(0,0.0f,0), 1.0f);
    float3 col = to_float3_s(0);

    float d = RayMarch(ro, rd, iTime);

    if(d<MAX_DIST) {
        float3 p = ro + rd * d;
        float3 n = GetNormal(p,iTime);
        float3 r = reflect(rd, n);
        float3 rf = refract_f3(rd, n,0.1f);

        float dif = dot(n, normalize(to_float3(1,2,3)))*0.5f+0.5f;
        col = 0.42f * to_float3_s(dif);

        float b = 0.5f + 0.5f * _cosf(iTime);

        uv = fragCoord / iResolution;
        col += 0.9f * swi3(decube_f3(iChannel0, r / (0.5f + n) ),x,y,z);

        float a = _atan2f(rf.z, rf.x);
        float c = _atan2f(rf.z, rf.y);
        col.x += 0.15f + (0.25f+Color.x) * thc(2.0f,10.0f * rf.x + iTime - 3.1415f / 2.0f);
        col.y += 0.15f + (0.25f+Color.y) * thc(2.0f,10.0f * rf.y + iTime);
        col.z += 0.15f + (0.25f+Color.z) * thc(2.0f,10.0f * rf.z + iTime + 3.1415f / 2.0f);

        float l = length(p);
        float pa = _atan2f(p.x ,p.z);
        col *= 0.7f + 0.5f * Brightness * thc(6.0f + 6.0f * _cosf(20.0f * l + 10.0f * pa + iTime),
                                              1.2f * l - 24.0f * pa - 0.5f * _cosf(l * 10.0f + 2.0f * pa + iTime) -  2.0f * iTime);
       // col *= 1.5f;
    } else {
        col = swi3(decube_f3(iChannel0,rd),x,y,z);
    }

    col.y = 0.5f * (col.x + col.z);

    col = pow_f3(col, to_float3_s(0.4545f));  // gamma correction

    fragColor = to_float4_aw(col,1.0f);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
]]
-- /*



-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ShaderFuse.begin_create()

  ----- In/Out

  InChannel0 = self:AddInput( "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
  InChannel1 = self:AddInput( "iChannel1",  "iChannel1",  { LINKID_DataType = "Image", LINK_Main = 2, INP_Required = false  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main       = 1,
  })

  ----- Inspector Panel Controls

  
  -- Speed Slider
  
  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",
  })
  
  -- iMouse Controls
  
  InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
  })
  
  InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
    INP_Disabled = true,
  })
  
  InMouseDrag = self:AddInput("Mouse Button Pressed", "iMouseClick", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = false,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0,
  })
  self:BeginControlNest("Color", "Color", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Color",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColorColorR = self:AddInput("Red",   "ColorRed",   { INP_Default  = 0.0, IC_ControlID = 0, attrs})
    InColorColorG = self:AddInput("Green", "ColorGreen", { INP_Default  = 0.0, IC_ControlID = 1, attrs})
    InColorColorB = self:AddInput("Blue",  "ColorBlue",  { INP_Default  = 0.0, IC_ControlID = 2, attrs})
    InColorColorA = self:AddInput("Alpha", "ColorAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  InBrightnessSlider = self:AddInput("Brightness", "Brightness", {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_MinScale       = -1.0,
      INP_MaxScale       = 5.0,
      INP_Default        = 1.0,
  })



  ShaderFuse.end_create()

end



-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------

function Process(req)

  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth  = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }

  local dst   = Image(imgattrs)
  local black = Pixel({R=0,G=0,B=0,A=0})
  dst:Fill(black)

  if req:IsPreCalc() then
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end

  local node = DVIPComputeNode(req,
    "TwizzlyCircleMessFuse", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )

  -- Extern texture or create a new one

  iChannel0 = InChannel0:GetValue(req)

  if iChannel0==nil then
    iChannel0 = Image(imgattrs)
    iChannel0:Fill(black)
  end

  iChannel1 = InChannel1:GetValue(req)

  if iChannel1==nil then
    iChannel1 = Image(imgattrs)
    iChannel1:Fill(black)
  end

  -- DCTL parameters

  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  params = node:GetParamBlock(ShaderParameters)

  params.iResolution[0] = dst.Width
  params.iResolution[1] = dst.Height
  params.iTime = (req.Time / framerate) * InFrequency:GetValue(req).Value
  
  -- iMouse
  
  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)
  
  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y
  
  if InMouseDrag:GetValue(req).Value ~= 0 then
    if params.iMouse[2]==-1 and params.iMouse[3]==-1 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = -1
    params.iMouse[3] = -1
  end
  
  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end
  
  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  if params.iMouse[2] == -1 and params.iMouse[3] == -1 then
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  else
    params.iMouse[2] = params.iMouse[2] * Width
    params.iMouse[3] = params.iMouse[3] * Height
  end

  params.Color = {
    InColorColorR:GetValue(req).Value,
    InColorColorG:GetValue(req).Value,
    InColorColorB:GetValue(req).Value,InColorColorA:GetValue(req).Value
  }
  params.Brightness = InBrightnessSlider:GetValue(req).Value
  -- Resolution

  params.width  = dst.Width
  params.height = dst.Height

  -- Per channel time and resolution


  -- Set parameters and add I/O

  node:SetParamBlock(params)
  node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
  node:AddInput("iChannel0",iChannel0) -- TODO: add a better channel name
  node:AddInput("iChannel1",iChannel1) -- TODO: add a better channel name
  node:AddOutput("dst", dst)

  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    dump(node:GetErrorLog())
	end

  OutImage:Set(req,dst)
end



-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

-- function NotifyChanged(inp, param, time)
-- 	if (param ~= nil) then
-- 		if (param.Value == 1) then
-- 			if (inp == ...) then
--         ...
-- 			end
-- 		end
-- 	end
-- end


-- */


