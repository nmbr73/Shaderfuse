--[[--/*

    FractalGliding.fuse

    Based on https://www.shadertoy.com/view/ftGGDR Erstellt von AntoineC am 2021-11-20

    V1 JiPi Shadertoy


*/--]]--

-- "LUA CODE..." /**


local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()





-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,
  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,

  REG_Source_GlobalCtrls = true,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  --REG_OpNoMask           = true,

  REG_TimeVariant        = true,
  REG_NoPreCalcProcess   = true,  -- call Process for precalc requests (instead of PreCalcProcess)
  })

-----------------------------------

-- **/ "End of LUA CODE"
-- // ------------------------------------------------------------------------
-- // DCTL kernel
-- // ------------------------------------------------------------------------

GlobalParams =
[[
  float center[2];
  float angle;
  float pivot[2];
  float debug;
  float scale;
  float freq;
  int width;
  int height;
  float itime;
  int iframe;
  float itimeDelta;
  bool reset;

	bool Alpha_Apply;
	float athres;
	float alpha;
	float color[4];
	
]]

----------------BufferA---------------
-- source of kernel
BufferAKernel =
    [[
//################## Common #####################

#if defined (DEVICE_IS_METAL)
#define inout thread
#define out thread
#else
#define inout
#define out
#endif

//-----------------------
//-------- mat2 ---------
//-----------------------
typedef struct  
  {  
    float2 r0, r1;  
  } mat2;  
  
__DEVICE__ inline mat2 make_mat2( float A, float B, float C, float D)  
  {  
    mat2 E;  
    E.r0 = to_float2(A,B);  
    E.r1 = to_float2(C,D);  
    return E;  
  } 

__DEVICE__ inline float2 f2_multi_mat2( float2 A, mat2 B )  
  {  
	float2 C;  
	C.x = A.x * B.r0.x + A.y * B.r0.y;  
	C.y = A.x * B.r1.x + A.y * B.r1.y;  
	return C;  
  }
__DEVICE__ inline float2 mat2_multi_f2( mat2 B, float2 A)  
  {  
	float2 C;  
	C.x = A.x * B.r0.x + A.y * B.r1.x;  
	C.y = A.x * B.r0.y + A.y * B.r1.y;  
	return C;  
  }  

__DEVICE__ float mod_f(float value, float divisor) {  return value - divisor * _floor(value / divisor);}
__DEVICE__ float fract_f(float A){return A - _floor(A);}
__DEVICE__ float2 fract_f2(float2 A){return make_float2(A.x - _floor(A.x), A.y - _floor(A.y));}
__DEVICE__ float3 fract_f3(float3 A){return make_float3(A.x - _floor(A.x), A.y - _floor(A.y), A.z - _floor(A.z));}
__DEVICE__ float4 fract_f4(float4 A){return make_float4(A.x - _floor(A.x), A.y - _floor(A.y), A.z - _floor(A.w), A.w - _floor(A.w));}

__DEVICE__ float2 abs_f2(float2 a) {return (to_float2(_fabs(a.x), _fabs(a.y)));}
__DEVICE__ float3 abs_f3(float3 a) {return (to_float3(_fabs(a.x), _fabs(a.y),_fabs(a.z)));}

__DEVICE__ float powcf(float x, float y) {
    float ret = _powf(x,y);
    if (isnan(ret)) {
        ret = 0.0001f;
    }
    return ret;
}

#define lpowf powcf
__DEVICE__ float3 pow_f3(float3 a, float3 b) {float3 r; r.x = lpowf(a.x,b.x); r.y = lpowf(a.y,b.y); r.z = lpowf(a.z,b.z); return r;}

#define swixy(V) to_float2((V).x,(V).y)
#define swixx(V) to_float2((V).x,(V).x)
#define swiyz(V) to_float2((V).y,(V).z)
#define swizy(V) to_float2((V).z,(V).y)

#define swixyz(V) to_float3((V).x,(V).y,(V).z)
#define swiyzx(V) to_float3((V).y,(V).z,(V).x)



//  Uncomment '#define Slow' for a slower animation. 
//#define Slow


#ifdef Slow
#define Time (0.9f*itime)
#else
#define Time (1.3f*itime)
#endif

//#define DebugFps

//################## BufferA->A #####################
#define Pi        3.14159265359f
#define Tau       6.28318530718f
#define ToRad(a)  ((a)*Pi/180.0f)
#define ToDeg(a)  ((a)*180.0f/Pi)
#define Rot(a)    make_mat2(_cosf(ToRad(a)),_sinf(ToRad(a)),-_sinf(ToRad(a)),_cosf(ToRad(a)))
#define Scale(s)  make_mat2((s),0.0f,0.0f,(s))


//__DEVICE__ float PreScale             = 0.0f;
//__DEVICE__ float PreGamma             = 1.0f;
//__DEVICE__ bool  RepeatEnabled        = false;
//__DEVICE__ float RepeatFrequency      = 1.0f;
//__DEVICE__ float ContrastStrength     = 0.0f;
//__DEVICE__ float ContrastHighlight    = 1.0f;
//__DEVICE__ float PostGamma            = 1.0f;
//__DEVICE__ int   MaxIter              = 256;
//__DEVICE__ float Rotation             = 0.0;
//__DEVICE__ float2  A                    = {1.0f,0.0f};//make_float2(1.0f,0.0f);
//__DEVICE__ float2  B                    = {1.0f,0.0f};//make_float2(1.0f,0.0f);
//__DEVICE__ float2  C                    = {-0.512511f,0.521295f};//make_float2(-0.512511f,0.521295f);

//__DEVICE__ float3  BackColor            = {0.286f,0.353f,0.459f};//make_float3(0.286f,0.353f,0.459f);
//__DEVICE__ float R0                   = 0.20884f;
//__DEVICE__ float R1                   = 2.21687f;


// -----------------------------------------------------------------------
// --- Fractal: ----------------------------------------------------------
// -----------------------------------------------------------------------

__DEVICE__ float2 Cube(float2 z)
{
	float2 b = make_float2(z.x*z.x - z.y*z.y, 2.0f*z.x*z.y);
	return make_float2(z.x*b.x - z.y*b.y, z.x*b.y + z.y*b.x);
}

__DEVICE__ float2 Mul(float2 a, float2 b)
{
	return make_float2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
}

__DEVICE__ float2 Julia(float2 z, int MaxIter,float2 A,float2 B,float2 C)
{
    float d = 0.0f;
    float2 z0 = z;
    float magnitude0 = length(z);
    for(int i=0; i<MaxIter; i++)
    {
    	// Formula: Zn+1 = b*_fabs(a*Zn^3) + c
    	//  Based on a formula seen a while ago on Tom Beddard's blog.
    	//  The Mandelbrot set is uninteresting.
    	//  But the Julia sets are quite varied and surprising!

		z = Mul(abs_f2(Mul(A, Cube(z))), B) + C;

		float magnitude = length(z);
		if(magnitude > 32.0f)
        {
			return to_float2_s(0.0f);
        }

		d += _expf(-1.0f/_fabs(magnitude0 - magnitude));
		z0 = z;
		magnitude0 = magnitude;
    }

    return make_float2(_logf(d), 1.0f);
}

// -----------------------------------------------------------------------
// --- Animation: --------------------------------------------------------
// -----------------------------------------------------------------------

__DEVICE__ float EaseOut(float x)
{
	// See: https://www.desmos.com/calculator/korqdwvlco
	const float q = 2.0f/8.0f, qd = 3.0f-2.0f*q;
	const float a = q/qd, b = -3.0f*q/qd, c = 3.0f*q/qd, d = 3.0f*(1.0f-q)/qd;
	float t = (x+q-1.0f)/q;
	return x <= 1.0f - q ? 3.0f*x/qd : t*(a*t*t + b*t + c) + d;
}

__DEVICE__ float DelayEnd(float x)
{

	return _fminf(x/(1.0f-0.5f/8.0f), 1.0f);
}

// -----------------------------------------------------------------------
// --- Sequencing: -------------------------------------------------------
// -----------------------------------------------------------------------

#define IntroDuration 9.0f

__DEVICE__ float3 Sequencing(float t, float itime)
{
	
//const float IntroDuration = 0.0f;//9.0f;
const float SequenceDuration = 8.0f;
const float SceneDuration = 2.0f*SequenceDuration + 3.0f; // 2*8s + 3s
//__DEVICE__ const float SceneDuration = 2.0f*8.0f + 3.0f; // 2*8s + 3s
const float SceneCount = 7.0f;
const float MovieDuration = SceneCount*SceneDuration;
//__DEVICE__ const float MovieDuration = 7.0f*2.0f*8.0f + 3.0f;

	if( t < IntroDuration)
	{
		//return make_float3(0.0f, 0.0f, 1000.0f);
		return make_float3(0.0f, 0.0f, _floor(7.0f*Time/IntroDuration)); //7*itime*1.3/9.0 -> 30 Frames oder 1s
	}
	t -= IntroDuration;

	float scene = 0.0f, sequence = 0.0f;
	t = mod_f(t, MovieDuration);
	scene = _floor(t / SceneDuration);
	t = mod_f(t, SceneDuration);
	sequence = _floor(t / SequenceDuration);
	t = mod_f(t, SequenceDuration);
	return make_float3(t, sequence, scene);
}

__DEVICE__ float3 GetTransform(float t, float itime, float3 Loc0,float2 Dst0,float3 Loc1,float2 Dst1,float3 Loc2,float2 Dst2)
{
	float3  ts = Sequencing(t, itime);
	float k  = EaseOut(DelayEnd(ts.x/8.0f));
	if     (ts.y == 0.0f) { return to_float3_aw(_mix(swixy(Loc0), Dst0, k), Loc0.z); }
	else if(ts.y == 1.0f) { return to_float3_aw(_mix(swixy(Loc1), Dst1, k), Loc1.z); }
	else                  { return to_float3_aw(_mix(swixy(Loc2), Dst2, k), Loc2.z); }
}


__DEVICE__ float2 Translation(float t, float itime, float2 iR, float3 Loc0,float2 Dst0,float3 Loc1,float2 Dst1,float3 Loc2,float2 Dst2)
{

	float3 TransZoom = GetTransform(t,itime, Loc0,Dst0,Loc1,Dst1,Loc2,Dst2);
	float2 trans = -TransZoom.z*swixy(TransZoom);
	return  iR.y*trans/2.0f;
}


__DEVICE__ float2 Jitter(float2 fragCoord, float itime)
{
	// Using Dave Hoskin's hash:
	float3 p3 = fract_f3(to_float3_aw(fragCoord, Time) * make_float3(0.1031f, 0.1030f, 0.0973f));
    p3 += dot(p3, swiyzx(p3)+19.19f);
	return fragCoord + (fract_f2((swixx(p3)+swiyz(p3))*swizy(p3)) - 0.5f);
}

__DEVICE__ void SetSceneParameters(float scene, float itime,
float3 *Loc0,
float2 *Dst0,
float3 *Loc1,
float2 *Dst1,
float3 *Loc2,
float2 *Dst2, int *MaxIter,float2 *A,float2 *B,float2*C,
float *PreScale,float *PreGamma,bool  *RepeatEnabled,float *RepeatFrequency,float *ContrastStrength,float *ContrastHighlight,float *PostGamma,float *Rotation,float3  *BackColor,float *R0,float *R1)
{
	// Settings were created interactively using Synthclipse
	// A nice IDE to code Shadertoys.
    //

	if(scene == 0.0f)
	{
		// Setting7:
		*A=make_float2(-0.05050397f,-0.168316f); *B=make_float2(0.96969604f,-1.242424f); *C=make_float2(-0.909088f,0.8788879f); *ContrastStrength=0.72245f; *Dst0=make_float2(1.51278f,0.0f); *Dst1=make_float2(0.25989f,0.50691f); *Loc0=make_float3(0.52830005f,0.0f,5.05447f); *Loc1=make_float3(0.25989f,1.6831f,3.45227f); *Loc2=make_float3(0.0f,0.0f,0.38554f); *MaxIter=232; *PostGamma=1.5959187f; *PreGamma=1.0685698f; *PreScale=-0.18775594f; *R0=1.1245f; *R1=5.644266f; *RepeatFrequency=2.2f; *Rotation=65.47356f;
	}
	else if(scene == 1.0f)
	{
		// Setting10:
		*A=make_float2(2.0f,1.0026519f); *B=make_float2(-0.27045596f,0.74801207f); *C=make_float2(-0.014915943f,-0.48476005f); *ContrastStrength=0.50204f; *Dst0=make_float2(-0.09985f,0.0516f); *Dst1=make_float2(0.0f,0.75789f); *Loc0=make_float3(-0.1517f,0.08739f,41.14481f); *Loc1=make_float3(0.0f,0.25713f,6.7275f); *MaxIter=243; *PostGamma=0.6497946f; *PreGamma=1.099593f; *PreScale=1.1199999f; *RepeatEnabled=true; *RepeatFrequency=0.72755504f; *Rotation=21.132f;
	}
	else if(scene == 2.0f)
	{
		// Setting1:
		*A=make_float2(1.0f,1.071604f); *B=make_float2(0.92345595f,-1.120988f); *BackColor=make_float3(0.28627452f,0.45882353f,0.42352942f); *C=make_float2(-0.34274006f,0.3664961f); *ContrastHighlight=0.155102f; *ContrastStrength=0.395918f; *Dst0=make_float2(0.0f,0.31722f); *Dst1=make_float2(0.38814f,0.0f); *Loc0=make_float3(-0.3941f,0.31722f,6.11591f); *Loc1=make_float3(0.38814f,-0.53359f,4.17725f); *MaxIter=252; *PostGamma=1.8440815f; *PreGamma=0.6546016f; *PreScale=0.42379594f; *R1=2.538152f; *RepeatFrequency=0.63f; *Rotation=14.2956f;
	}
	else if(scene == 3.0f)
	{
		// Setting9:
		*A=make_float2(2.0f,2.0f); *B=make_float2(-0.29177594f,0.75862f); *BackColor=make_float3(0.26666668f,0.36078432f,0.45882353f); *C=make_float2(-0.07557595f,-0.40087605f); *ContrastStrength=0.62576604f; *Dst0=make_float2(-0.20006f,0.0f); *Dst1=make_float2(0.24391f,0.4249f); *Loc0=make_float3(-0.26006f,0.0f,54.76373f); *Loc1=make_float3(0.24842f,0.43541f,276.8017f); *Loc2=make_float3(0.0f,0.0f,1.21f); *MaxIter=243; *PostGamma=0.773876f; *PreGamma=0.6546016f; *PreScale=1.232652f; *R1=1.95984f; *RepeatFrequency=2.2f; *Rotation=134.94635f;
	}
	else if(scene == 4.0f)
	{
		// Setting11:
		*A=make_float2(2.0f,0.8859401f); *B=make_float2(-1.1830239f,0.3662479f); *BackColor=make_float3(1.0f,0.9607843f,0.8f); *C=make_float2(0.3154359f,-0.30016804f); *ContrastHighlight=0.0f; *ContrastStrength=-0.640816f; *Dst0=make_float2(-0.715f,0.0f); *Dst1=make_float2(0.0f,-0.36f); *Loc0=make_float3(-0.65108f,0.0f,66.26409f); *Loc1=make_float3(0.0f,0.0f,15.86309f); *Loc2=make_float3(0.0f,0.0f,1.4641f); *MaxIter=243; *PostGamma=0.96f; *PreGamma=4.0f; *PreScale=1.134692f; *R0=0.353412f; *R1=1.783132f; *RepeatEnabled=true; *RepeatFrequency=0.9663227f; *Rotation=112.032715f;
	}
	else if(scene == 5.0f)
	{
		// Setting12:
		*A=make_float2(0.11140394f,-0.992044f); *B=make_float2(-0.854112f,0.3662479f); *BackColor=make_float3(0.38039216f,0.4392157f,0.56078434f); *C=make_float2(0.581028f,0.562248f); *ContrastHighlight=0.0f; *ContrastStrength=0.191836f; *Dst0=make_float2(-0.59736f,0.11306f); *Dst1=make_float2(0.0f,-1.06502f); *Loc0=make_float3(-0.59736f,-0.05234f,23.22517f); *Loc1=make_float3(0.0f,-0.76502f,13.11f); *Loc2=make_float3(0.0f,0.0f,0.75131f); *MaxIter=345; *PostGamma=0.96f; *PreScale=-0.808512f; *R0=0.096384f; *R1=3.084336f; *RepeatEnabled=true; *RepeatFrequency=1.494685f; *Rotation=57.81492f;
	}
	else if(scene == 6.0f)
	{
		// Setting6:
		*A=make_float2(-0.31983197f,-0.030303955f); *B=make_float2(0.96969604f,-0.19192004f); *BackColor=make_float3(0.19607843f,0.2627451f,0.4f); *C=make_float2(-0.90909195f,0.878788f); *ContrastHighlight=0.0f; *ContrastStrength=-0.67347f; *Dst0=make_float2(-0.88277f,0.0f); *Dst1=make_float2(0.0f,-1.01423f); *Loc0=make_float3(0.0f,0.0f,4.17725f); *Loc1=make_float3(0.0f,-1.23423f,13.11f); *Loc2=make_float3(0.0f,0.0f,0.51316f); *MaxIter=243; *PostGamma=1.5959187f; *PreScale=-0.773672f; *R0=1.140564f; *R1=3.598392f; *RepeatEnabled=true; *RepeatFrequency=0.8071442f; *Rotation=57.81492f;
	}

#ifdef XXX
//Umbau Test
	if(Time<IntroDuration)
	{
		*Loc0 = *Loc2; *Dst0 = *Dst2;
		*Loc1 = *Loc2; *Dst1 = *Dst2;
		BackColor = make_float3(0.286f,0.353f,0.459f); R0 = 0.20884f/ (*Loc2).z; R1 = 2.21687f/(*Loc2).z;
	}
#endif


}

__DEVICE__ void SetScene(float scene, float2 p, float itime, float3 *Loc0,float2 *Dst0,float3 *Loc1,float2 *Dst1,float3 *Loc2,float2 *Dst2, int *MaxIter,float2 *A,float2 *B,float2*C,
                         float *PreScale,float *PreGamma,bool  *RepeatEnabled,float *RepeatFrequency,float *ContrastStrength,float *ContrastHighlight,float *PostGamma,float *Rotation,float3  *BackColor,float *R0,float *R1)
{
//const float IntroDuration = 0.0f;//9.0f;
	SetSceneParameters(scene, itime, Loc0,Dst0,Loc1,Dst1,Loc2,Dst2, MaxIter,A,B,C,PreScale,PreGamma,RepeatEnabled,RepeatFrequency,ContrastStrength,ContrastHighlight,PostGamma,Rotation,BackColor,R0,R1);


	if(Time<IntroDuration)
	{
		*Loc0 = *Loc2; *Dst0 = *Dst2;
		*Loc1 = *Loc2; *Dst1 = *Dst2;
		*BackColor = make_float3(0.286f,0.353f,0.459f); *R0 = 0.20884f/ (*Loc2).z; *R1 = 2.21687f/(*Loc2).z;
	}

}

// -----------------------------------------------------------------------
// --- Image processing: -------------------------------------------------
// -----------------------------------------------------------------------
__DEVICE__ float3 Cubic(float3 c, float d0, float d1)
{

	return c*((d0+d1-2.0f)*c*c +(3.0f-2.0f*d0-d1)*c + d0);
}

__DEVICE__ float3 Contrast(float3 c, float ContrastStrength, float ContrastHighlight )
{
	float s = ContrastStrength, h = ContrastHighlight;
      float d0 = 1.0f-s, d1 = (1.0f-h) + h*(1.0f-s);
	return Cubic(Cubic(c, d0, d1), d0, d1);
}

__DEVICE__ float3 Repeat(float3 c, float RepeatFrequency )
{
	// Triangle:
	return abs_f3(2.0f*fract_f3(RepeatFrequency*c+0.5f) - 1.0f);
}

__DEVICE__ float3 Curve(float3 c, float ContrastStrength, float ContrastHighlight, float RepeatFrequency,float PreScale,float PreGamma,float PostGamma, bool  RepeatEnabled )
{
    c = _fmaxf(c, to_float3_s(0.0f));
    c = c*_powf(2.0f, PreScale);
    c = pow_f3(c, to_float3_s(PreGamma));
    c = RepeatEnabled ? c = Repeat(c, RepeatFrequency) : c;
    c = clamp(c, 0.0f, 1.0f);
    c = Contrast(c, ContrastStrength, ContrastHighlight);
    c = pow_f3(c, to_float3_s(PostGamma));

    return c;
}



// -----------------------------------------------------------------------
// --- Rendering: --------------------------------------------------------
// -----------------------------------------------------------------------

__DEVICE__ void Render(out float4 *fragColor, float2 fragCoord, float itime, float2 iR, float3 Loc0,float2 Dst0,float3 Loc1,float2 Dst1,float3 Loc2,float2 Dst2, int MaxIter,float2 A,float2 B,float2 C,float3 BackColor,float R0,float R1,
                       float ContrastStrength, float ContrastHighlight, float RepeatFrequency,float PreScale,float PreGamma,float PostGamma,bool  RepeatEnabled,float Rotation )
{
    float2 uv = (fragCoord - 0.5f*iR)*2.0f/iR.y;

    // Apply transform:
    //  Translation is already applied to fragCoord
    float3 transZoom = GetTransform(Time,itime, Loc0,Dst0,Loc1,Dst1,Loc2,Dst2);
    uv = uv / transZoom.z;
    mat2 tfm = Rot(Rotation);

    // Render:
    float2 cm   = Julia(mat2_multi_f2(tfm,uv), MaxIter,A,B,C);
    float3 col  = Curve(to_float3_s(cm.x), ContrastStrength, ContrastHighlight, RepeatFrequency, PreScale, PreGamma, PostGamma,RepeatEnabled );
    float3 back = _mix(to_float3_s(0.0f), BackColor, smoothstep(R0, R1, length(uv)));
    col = _mix(back, col, cm.y);

    *fragColor = to_float4_aw(col, 1.0f);
}


// ---------------------------------------------------------------------
// --- Load/Store from IQ (https://www.shadertoy.com/view/MddGzf) ------
// ---------------------------------------------------------------------

__DEVICE__ float isInside( float2 p, float2 c ) { float2 d = abs_f2(p-0.5f-c) - 0.5f; return -_fmaxf(d.x,d.y); }
__DEVICE__ float4 Load(float2 address,float2 iR, __TEXTURE2D__ iChannel0) { return _tex2DVecN(iChannel0, (0.5f+address.x) / iR.x, (0.5f+address.y) / iR.y, 15 ); }
__DEVICE__ void Store(float2 address, float4 value, inout float4 *fragColor, float2 fragCoord) { *fragColor = (isInside(fragCoord,address) > 0.0f) ? value : *fragColor; }



//############################################################################################################################
__KERNEL__ void BufferAKernel(__CONSTANTREF__ GlobalParams *params, __TEXTURE2D__ iChannel0, __TEXTURE2D__ iChannel1, __TEXTURE2D_WRITE__ dst)
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);
  //---------------------------------------
  if (x < params->width && y < params->height)
  {
    //-----------------------
     float2 fragCoord = to_float2(x+0.5f, y+0.5f); 
     float2 iResolution = to_float2(params->width, params->height);
     float ratio = (float)params->width/(float)params->height;
     float itime = params->itime*params->freq;
     float4 fragColor = to_float4_s(0.0f);
     //-----------------------

    //Functionality.......

    float iFrameRate = 30.0f;
    float iFrame = params->iframe;
	
	float3  Loc0                 = {0.0f,0.0f,1.0f};//make_float3(0.0f,0.0f,1.0f);
	float2  Dst0                 = {0.0f,0.0f};//make_float2(0.0f,0.0f);
	float3  Loc1                 = {0.0f,0.0f,1.0f};//make_float3(0.0f,0.0f,1.0f);
	float2  Dst1                 = {0.0f,0.0f};//make_float2(0.0f,0.0f);
	float3  Loc2                 = {0.0f,0.0f,1.0f};//make_float3(0.0f,0.0f,1.0f);
	float2  Dst2                 = {0.0f,0.0f};//make_float2(0.0f,0.0f);
	
	//Julia
	int   MaxIter                = 256;

	float2  A                    = {1.0f,0.0f};//make_float2(1.0f,0.0f);
	float2  B                    = {1.0f,0.0f};//make_float2(1.0f,0.0f);
	float2  C                    = {-0.512511f,0.521295f};//make_float2(-0.512511f,0.521295f);
	
	
	float PreScale             = 0.0f;
	float PreGamma             = 1.0f;
	bool  RepeatEnabled        = false;
	float RepeatFrequency      = 1.0f;
	float ContrastStrength     = 0.0f;
	float ContrastHighlight    = 1.0f;
	float PostGamma            = 1.0f;

	float Rotation             = 0.0;

	float3  BackColor          = {0.286f,0.353f,0.459f};//make_float3(0.286f,0.353f,0.459f);
	float R0                   = 0.20884f;
	float R1                   = 2.21687f;
	
    // Address:
    const float2 mWidthHeightTimeState = make_float2(0.0f, 0.0f);
    const float2 mScene                = make_float2(1.0f, 0.0f);
	const float2 debug1                = make_float2(2.0f, 0.0f);
   
	// Load state:
	float4 state = Load(mWidthHeightTimeState,iResolution,iChannel0);
	float t0 = state.z;
	float t1 = Time;
	float2 resolution0 = swixy(state);
	float2 resolution1 = iResolution;
    float threshold = state.w;
    float3 stateB = swixyz(Load(mScene,iResolution,iChannel0));
	float2 scene0 = swixy(stateB);
	float2 scene1 = swiyz(Sequencing(Time,itime));
    float thresholdTime = stateB.z;

	// Update scene parameters:
	SetScene(scene1.y, fragCoord, itime, &Loc0,&Dst0,&Loc1,&Dst1,&Loc2,&Dst2, &MaxIter, &A, &B, &C, &PreScale,&PreGamma,&RepeatEnabled,&RepeatFrequency,&ContrastStrength,&ContrastHighlight,&PostGamma,&Rotation,&BackColor,&R0, &R1);

	// Translation frag coordinates:
	//   Use integer translation to avoid smearing when accumulating values
	float2 trans0 = _floor(Translation(t0,itime, iResolution, Loc0,Dst0,Loc1,Dst1,Loc2,Dst2));
	float2 trans1 = _floor(Translation(t1,itime, iResolution, Loc0,Dst0,Loc1,Dst1,Loc2,Dst2));
	float2 deltaTrans = trans0 - trans1;

	// Coordinate of the current pixel the accumulation buffer:
	float2 uv0 = (fragCoord + deltaTrans)/iResolution;

	// Invalidate buffer?
	bool invalidate = (iFrame == 0 || params->reset);
	invalidate = invalidate || uv0.x < 0.0f || uv0.x > 1.0f || uv0.y < 0.0f || uv0.y > 1.0f;;
	invalidate = invalidate || (uv0.y < 1.0f/iResolution.y && uv0.x < 3.0f/iResolution.x);
	invalidate = invalidate || (resolution0.x != resolution1.x || resolution0.y != resolution1.y);
	invalidate = invalidate || (scene0.x != scene1.x || scene0.y != scene1.y);

	// Get accumulated color at previous coordinate:
	float4 color = invalidate ? to_float4_s(0) : _tex2DVecN(iChannel0, uv0.x,uv0.y,15);

    // Adaptive max accumulation per pixel:
    if(resolution0.x != resolution1.x || resolution0.y != resolution1.y)
    {
    	// Used to wait for FPS to settle down when changing resolution
        thresholdTime = itime + 40.0f/60.0f;
    }

    const float maxThreshold = 32.0f;
    if((iFrame < 60) || (resolution1.x < resolution0.x))
    {
        threshold = maxThreshold;
        thresholdTime = itime;
    }
    else if(itime > thresholdTime + 20.0f/60.0f)
    {
    	// Reduce max accumulation when FPS is low:
        threshold = iFrameRate < 45.0f ? threshold -= 2.0f : threshold;
        threshold = clamp(threshold, 4.0f, maxThreshold);
    }

	// Render:
	if(color.w < threshold)
	{
		Render(&fragColor, Jitter(fragCoord - trans1,itime), itime, iResolution, Loc0,Dst0,Loc1,Dst1,Loc2,Dst2, MaxIter,A,B,C, BackColor,R0,R1,ContrastStrength, ContrastHighlight,RepeatFrequency, PreScale, PreGamma, PostGamma,RepeatEnabled,Rotation );

		// Accumulate linear space:
		
		float3 colorrgb = pow_f3(swixyz(color), to_float3_s(2.2f)) * color.w + pow_f3(swixyz(fragColor), to_float3_s(2.2f));
		color.w += 1.0;
		colorrgb = pow_f3((colorrgb)/color.w, to_float3_s(1.0f/2.2f));
		color.x=colorrgb.x;color.y=colorrgb.y;color.z=colorrgb.z;
	}
    fragColor = color;


#ifdef DebugFps
    // Show FPS and threshold:
    if(fragCoord.y < 10.0f)
    {
        float4 bar = (0.5f+0.5f*_floor(mod_f(fragCoord.x/8.0f, 2.0f)))*make_float4(1,0,0,0);
        fragColor = _mix(_mix(bar, (bar+5.0f*fragColor)/6.0f, make_float4(fragCoord.x>2.0f*threshold)), fragColor, make_float4(fragCoord.x > 2.0f*32.0f));
    }
    else if(fragCoord.y < 20.0f)
    {
        float4 bar = (0.5f+0.5f*_floor(mod_f(fragCoord.x/15.0f, 2.0f)))*make_float4(0,1,0,0);
        fragColor = _mix(_mix(bar, (bar+5.0f*fragColor)/6.0f, make_float4(fragCoord.x>2.0f*iFrameRate)), fragColor, make_float4(fragCoord.x > 2.0f*60.0f));
    }
#endif

	// Store state:
	//  Only update time when an actual translation occurs.
	float t = (deltaTrans.x != 0.0f || deltaTrans.y != 0.0f) ? t1 : t0;
	Store(mWidthHeightTimeState, make_float4(resolution1.x,resolution1.y, t, threshold),  &fragColor, fragCoord);
	Store(mScene,                make_float4(scene1.x,scene1.y, thresholdTime, 0.0f), &fragColor, fragCoord);
	
	Store(debug1,                make_float4(Loc0.x,Loc0.y,Loc0.z, Rotation), &fragColor, fragCoord);
	

    _tex2DVec4Write(dst, x, y, fragColor);
  }
}
]]


----------------Image---------------
-- source of kernel
ImageKernel =
    [[
//  Uncomment '#define Slow' for a slower animation. 
//#define Slow


#ifdef Slow
#define Time (0.9f*itime)
#else
#define Time (1.3f*itime)
#endif

//#define DebugFps


__DEVICE__ float fract_f(float A){return A - _floor(A);}
__DEVICE__ float2 fract_f2(float2 A){return make_float2(A.x - _floor(A.x), A.y - _floor(A.y));}
__DEVICE__ float3 fract_f3(float3 A){return make_float3(A.x - _floor(A.x), A.y - _floor(A.y), A.z - _floor(A.z));}
__DEVICE__ float mod_f(float value, float divisor) {  return value - divisor * _floor(value / divisor);}


#define swixyz(V) to_float3((V).x,(V).y,(V).z)
#define swiyxz(V) to_float3((V).y,(V).x,(V).z)
#define swizyx(V) to_float3((V).z,(V).y,(V).x)

#define swiyxx(V) to_float3((V).y,(V).y,(V).x)
#define swixyx(V) to_float3((V).x,(V).y,(V).x)
#define swixxy(V) to_float3((V).x,(V).x,(V).y)



 //################## Image->A  #####################
// ----------------------------------------------------------------------------------------
//	"Fractal Gliding" by Antoine Clappier - Nov 2021
//
//	Licensed under:
//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0f International License.
//	http://creativecommons.org/licenses/by-nc-sa/4.0f/
// ----------------------------------------------------------------------------------------
//
//     The Julia set for Zn+1 = b*_fabs(a*Zn^3)+c offers a pretty amazing
//     variety of shapes and textures.
//
//     Go fullscreen, relax and enjoy the trip!
//
//
// Point of interests:
//  - Optimized for high quality full-screen rendering (tested to
//    run smoothly on a laptop GeForce 1650 at 2560x1440).
//
//  - Temporal oversampling up to 32 samples per pixel with rounded
//    image transformations to avoid smearing.
//
//  - Adaptive quality based on measured fps.
//
//  - Detection of scene transitions and screen resolution to reset
//    accumulation buffer.
//
//
//    Interactive version:  https://www.shadertoy.com/view/fty3zK
//    
//
//

//********** Standard Imageparameter: center,size, angle, pivot *************
__DEVICE__ float2 spin(float2 uv, float2 center, float angle, float aspect)
{
  float C = _cosf(angle);
  float S = _sinf(angle);
   
  uv -= center;
  float x = uv.x;
  uv.x = (x*aspect * C - uv.y * S);
  uv.y = (x*aspect * S + uv.y * C);
  uv += center;
   
return uv;
}

//************************************************************************
__KERNEL__ void ImageKernel(__CONSTANTREF__ GlobalParams *params, __TEXTURE2D__ iChannel0, __TEXTURE2D__ iChannel1, __TEXTURE2D_WRITE__ dst)
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);
  if (x < params->width && y < params->height)
  {
    //----------------------- 
     float2 coord = make_float2(x, y); 
     float2 iResolution = make_float2(params->width, params->height); 
     float ratio = (float)params->width/(float)params->height; 
     float itime = params->itime; 
     float4 color = to_float4_s(0.0f); 
     //----------------------- 
   
    //Functionality....... 
   
	// Read accumulation buffer, add fade between sequences:
	
	float2 uv = coord / iResolution;
      
    // Standardparameter
    uv-=0.5f;
    uv *= params->scale;
    uv -=  to_float2( (params->center[0]-1.0f), (params->center[1]-1.0f)); //*2.0f*ratio
    float2 pivot = to_float2(((params->pivot[0]+0.0f)*ratio),(params->pivot[1]+0.0f));
    uv = spin(to_float2(uv.x*ratio,uv.y), pivot*params->scale, params->angle, 1.0f);
	uv.x/=ratio;
	
	
    float4  c    = _tex2DVecN(iChannel0, uv.x,uv.y,15);
    float fade   = smoothstep(0.0f, 0.7f, Time < 9.0f ? 0.3f+6.0f*fract_f(7.0f*Time/9.0f) : mod_f(mod_f(Time-9.0f, 19.0f), 8.0f)); // Scene: 19s, Sequence: 8s
    color        = _mix(to_float4_s(0.0f), c, fade);

    // "De-banding" with 1-bit random dithering (use Dave Hoskins hash33):
    float3 p = fract_f3(to_float3_aw(coord, itime*30.0f) * make_float3(0.1031f, 0.1030f, 0.0973f));
    p += dot(p, swiyxz(p)+19.19f);
    float3 noise = fract_f3((swixxy(p) + swiyxx(p))*swizyx(p));
    color = to_float4_aw(swixyz(color) + (noise-0.5f)/255.0f, color.w);

	
	
	if (params->Alpha_Apply)
	{
		//if (fragColor.x < params->athres && fragColor.y < params->athres && fragColor.z < params->athres) fragColor.w=0.0f;
		color.w = params->alpha;
	}

    color +=  to_float4_aw((to_float3_v(params->color)-0.5f)*0.25f, 0.0f);


    _tex2DVec4Write(dst, x, y, color);
  }
}
]]

-- "LUA CODE..." /**

-------------------------------------------------------------------
--       Create
-------------------------------------------------------------------

function Create()

  ShaderFuse.begin_create()

  ----- Inspector Panel Controls

--self:BeginControlNest("Standard", "StandardParameter", true, {})

  Sep1 = self:AddInput(string.rep("_", 52), "Separator1", {
    LINKID_DataType    = "Text",
    INPID_InputControl = "LabelControl",
    INP_External       = false,
    INP_Passive        = true,
	IC_Visible         = false,
  })

  InCenter = self:AddInput("Center", "Center", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INPID_PreviewControl = "CrosshairControl",
    INP_DoNotifyChanged = true,
	IC_Visible         = true,
  })

  InScale = self:AddInput("Scale", "Scale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    --INPID_PreviewControl = "RectangleControl",
    RCD_LockAspect     = 1,
    RC_DoLockAspect    = true,
    RCID_Center        = "true",
    INP_Default = 1.0,
    INP_MinAllowed = 0.1,
    INP_MaxAllowed = 5.0,
	IC_Visible         = true,
  })

  InDebug = self:AddInput("Debug", "Debug", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 1.0,
    INP_MinScale = 0.0,
    INP_MaxScale = 5.0,
    --INPID_PreviewControl = "RectangleControl",
    RCD_LockAspect     = 1,
    RC_DoLockAspect    = true,
    RCID_Center = "Center",    
    IC_Visible         = false, 
  })

  InAngle = self:AddInput("Angle", "Angle", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INPID_PreviewControl = "AngleControl",
    --INP_MinAllowed =   0.0,
    INP_MinScale = 0.0,
	INP_MaxScale = 360.0,
    INP_Default = 0.0,
    ACID_Center = "Center",
	IC_Visible         = true,
    --PC_GrabPriority = 1 -- give this a higher priority than the rectangle
  })

  InPivot = self:AddInput("Pivot", "Pivot", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INPID_PreviewControl = "CrosshairControl",
    CHC_Style = "DiagonalCross",
    PC_GrabPriority = -1,
	IC_Visible         = true,
  })

  InWidgets = self:AddInput("On-Screen Widgets", "OnScreen Widgets", {
    LINKID_DataType = "Number",
    INPID_InputControl = "MultiButtonControl",
    INP_Default = 1,
    INP_Integer = true,
    INP_External        = false,
	INP_Passive         = true,
    INP_DoNotifyChanged = true,
    MBTNC_ForceButtons = true,
    MBTNC_StretchToFit = true,
    { MBTNC_AddButton = "Show", },
    { MBTNC_AddButton = "Hide", },
	IC_Visible          = true,
  })

  InFrequency = self:AddInput("Frequency", "Frequency", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "SliderControl",
    INP_Default         = 1.0,
	IC_Visible          = true,
    --INP_MinAllowed    = -1.0,
    --INP_MaxAllowed    = 1.0,
  })
  
  InStop = self:AddInput("Stop", "Stop", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
	INP_Integer = true,
    INP_DoNotifyChanged = true,
    INP_Default         = 0,
    IC_Visible          = true,
    --INP_External        = false,
  })
  InStartStop = self:AddInput("", "StartStop", {
    { MBTNC_AddButton  = "Stop", MBTNCID_AddID = "StopAnimation", },
    { MBTNC_AddButton  = "Start", MBTNCID_AddID = "StartAnimation", },
    INPID_DefaultID    = "StartAnimation",
    LINKID_DataType    = "FuID",
    INPID_InputControl = "MultiButtonIDControl",
    ICD_Width          = 1.0,
    MBTNC_StretchToFit = true,
    MBTNC_ForceButtons = true,
    INP_DoNotifyChanged  = true,
    IC_Visible         = false,
    --INP_External = false,
  })
  
  
  InActtime = self:AddInput("Acttime", "Acttime", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.0,
	IC_Visible         = true,
    --INP_MinAllowed   = -1.0,
    --INP_MaxAllowed   = 1.0,
    })
  
  InTimeoffset = self:AddInput("Timeoffset", "Timeoffset", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default      = 0.0,
	IC_Visible       = true,
    INP_MinScale     = -10.0,
	INP_MaxScale     = 10.0,
	--INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    })   

--self:EndControlNest()  

  Sep2 = self:AddInput(string.rep("_", 52), "Separator2", {
    LINKID_DataType    = "Text",
    INPID_InputControl = "LabelControl",
    INP_External       = false,
    INP_Passive        = true,
	IC_Visible         = false,
  })


  Reset = self:AddInput("Reset", "_Reset", {
    INPID_InputControl  = "ButtonControl",
	INP_DoNotifyChanged = true,
    INP_External        = false,
    IC_Visible          = true,
    BTNCS_Execute       = "fusion.CacheManager:Purge()",
  })

  InResetclick = self:AddInput("Resetclick", "Resetclick", {
    LINKID_DataType     = "Number",
	--INPID_InputControl = "SliderControl",
    INPID_InputControl  = "CheckboxControl",
	INP_Integer         = true,
    INP_DoNotifyChanged = true,
    INP_Default         = 0,
    IC_Visible          = false,
    INP_External        = false,
  })


self:BeginControlNest("Color_Parameter", "ColorParameter", true, {})

	InBrightness = self:AddInput("Brightness", "Brightness", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1.5,
		IC_Visible          = false,
		INP_MinScale 		= 0.0,
		INP_MaxScale 		= 1.0,
	})

	InAlpha_Apply = self:AddInput("Apply Alpha", "Alpha_Apply", {
		LINKID_DataType = "Number",
		INPID_InputControl = "CheckboxControl",
		INP_Integer = false,
		INP_Default = 0,
		ICD_Width = 1,
		--INP_DoNotifyChanged = true,
	})
	InAlphaThres = self:AddInput("AlphaThres", "AlphaThres", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 0.02,
		IC_Visible          = false,
		INP_MinScale 		= 0.0,
		INP_MaxScale 		= 1.0,
	})
	InAlpha = self:AddInput("Alpha", "Alpha", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1.0,
		INP_MinScale 		= 0.0,
		INP_MaxScale 		= 1.0,
	})


 InRedCH = self:AddInput("Red", "RedCH", {
    ICS_Name            = "Color",
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.5,
    INP_MaxScale        = 1.0,
    CLRC_ShowWheel      = false,
    IC_ControlGroup     = 1,
    IC_ControlID        = 0,
  })
  InGreenCH = self:AddInput("Green", "GreenCH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.5,
    IC_ControlGroup     = 1,
    IC_ControlID        = 1,
  })
  InBlueCH = self:AddInput("Blue", "BlueCH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.5,
    IC_ControlGroup     = 1,
    IC_ControlID        = 2,
  }) 
  
  
self:EndControlNest()

--self:BeginControlNest("Image "..dctlfuse_name, "ImageNest2", true, {ICS_ControlPage  = "Image",})
  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
	{ CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	{ CCS_AddString  = "Image1", },
    { CCS_AddString  = "1920x1080", },
	{ CCS_AddString  = "1200x675", },
	{ CCS_AddString  = "800x450", },
	{ CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	ICS_ControlPage  = "Image",
  })
  
  	InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})

  
  
  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
	ICS_ControlPage  = "Image",
  })
  
    InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false })
  
  
--self:EndControlNest()


self:AddControlPage("Image")
InGlobalIn = self:AddInput("Global In", "GlobalIn", {
  LINKID_DataType     = "Number",
})
InGlobalOut = self:AddInput("Global Out", "GlobalOut", {
  LINKID_DataType     = "Number",
})

  ShaderFuse.end_create()

------------------- In/Out -----------------

  InImage1 = self:AddInput("Image", "Image", {
    LINKID_DataType = "Image",
	LINK_Visible = false,
    LINK_Main = 1,
    INP_Required = false
  })
  InImage2 = self:AddInput("Barrier", "Barrier", {
    LINKID_DataType = "Image",
	LINK_Visible = false,
    LINK_Main = 2,
    INP_Required = false
  })
  
  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
  })

end

function NotifyChanged(inp, param, time)
	if inp ~= nil and param ~= nil then

		if inp == InCenter then
			-- the center moved, reposition the axis according to the current offset
			nCenterX = param.X
			nCenterY = param.Y

			InPivot:SetAttrs({
			PCD_OffsetX = nCenterX - 0.5,
			PCD_OffsetY = nCenterY - 0.5,
			})

			InAngle:SetAttrs({
			PCD_OffsetX = (nCenterX - 0.5)/100,
			PCD_OffsetY = (nCenterY - 0.5)/100,
			})
		
		end
		if inp == InWidgets then
		  if param.Value == 1.0 then
			 InCenter:SetAttrs({ PC_Visible = false })
			 InAngle:SetAttrs({ PC_Visible = false })
			 InPivot:SetAttrs({ PC_Visible = false })
			 InScale:SetAttrs({ PC_Visible = false })
		  else
			 InCenter:SetAttrs({ PC_Visible = true })
			 InAngle:SetAttrs({ PC_Visible = true })
			 InPivot:SetAttrs({ PC_Visible = true })
			 InScale:SetAttrs({ PC_Visible = true })
		  end
		end
		
		if inp == InSize then
		  if param.Value == 1 then
			 InWidth:SetAttrs({ IC_Visible = true })
			 InHeight:SetAttrs({ IC_Visible = true })
		  else
			 InWidth:SetAttrs({ IC_Visible = false })
			 InHeight:SetAttrs({ IC_Visible = false })
		  end
		  
		  if param.Value == 3 then --1920x1080
			 InWidth:SetSource(Number(1920),0,0)
			 InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			 InWidth:SetSource(Number(1200),0,0)
			 InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			 InWidth:SetSource(Number(800),0,0)
			 InHeight:SetSource(Number(450),0,0)
		  end
 	      if param.Value == 6 then --640x360
		     InWidth:SetSource(Number(640),0,0)
			 InHeight:SetSource(Number(360),0,0)
		  end
		end

		if inp == InStop then  
		  if param.Value == 1 then
			 InActtime:SetAttrs({IC_Visible = true})
		  else
			 InActtime:SetAttrs({IC_Visible = false})
		  end
		end  


		if inp == Reset then
		  if param.Value == 1 then
			InResetclick:SetSource(Number(1),0,0)
		  end
			end

		if inp == InLogoSw then  
		  if param.Value == 1 then
			 --authorlogo:SetAttrs({IC_Visible = true})
		  else
			 --authorlogo:SetAttrs({IC_Visible = false})
		  end
		end  

	end
end

-------------------------------------------------------------------
--       Process
-------------------------------------------------------------------
ImgAttrs_Global = {
        { IMG_Channel = "Red", },
        { IMG_Channel = "Green", },
        { IMG_Channel = "Blue", },
        { IMG_Channel = "Alpha", },
        IMG_Width = Width,
        IMG_Height = Height,
	    IMG_DeferAlloc = false,
        }

Image_Buff_GlobalA = Image(ImgAttrs_Global)


timestamp = 0
--------------------------------------------------------------------
function Process(req)
    local center = InCenter:GetValue(req)
    local angle  = -InAngle:GetValue(req).Value/360*3.1415*2
    local scale  = InScale:GetValue(req).Value
    local freq   = InFrequency:GetValue(req).Value
    local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate") -- get the frame rate of the comp set in the preferences

	-- Imagesize and Depth
    if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InImage2:GetValue(req) ~= nil) then
			   Width = InImage2:GetValue(req).Width
			   Height = InImage2:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value 
		end
	end	
	if InDepth:GetValue(req).Value == 0 then
		SourceDepth = 7
	else
	    SourceDepth = 8
	end

    --This creates an image for us to work on.
    local imgattrs = {
        IMG_Document = self.Comp,
        { IMG_Channel = "Red", },
        { IMG_Channel = "Green", },
        { IMG_Channel = "Blue", },
        { IMG_Channel = "Alpha", },
        IMG_Width = Width,
        IMG_Height = Height,
        IMG_XScale = XAspect,
        IMG_YScale = YAspect,
        IMAT_OriginalWidth = realwidth,
        IMAT_OriginalHeight = realheight,
        IMG_Quality = not req:IsQuick(),
        IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
        }

    if not req:IsStampOnly() then
        imgattrs.IMG_ProxyScale = 1
    end

    if SourceDepth ~= 0 then
        imgattrs.IMG_Depth = SourceDepth
    end

    local p = Pixel({R=0,G=0,B=0,A=0})
    src1 = Image(imgattrs)
    src1:Fill(p)

    tex = false
	  if (InImage2:GetValue(req) ~= nil) then
         src2 = InImage2:GetValue(req)
		 tex = true
      else
         src2 = Image(imgattrs)
         src2:Fill(p)
      end

    local dstA = Image {IMG_Like = src1, IMG_DeferAlloc = true}
	local dstI = Image {IMG_Like = src1, IMG_DeferAlloc = true}


	if req:IsPreCalc() then
		 --print("\n######################### Precalc ##############################\n")
		 local out = Image({IMG_Like = dstI, IMG_NoData = true})
		 OutImage:Set(req, out)
		 return
	end
	
	    --StartStop	
    if InStop:GetValue(req).Value == 0 then             
	   _acttime = req.Time + InTimeoffset:GetValue(req).Value
	   startstopsema = 1
	else
	   if startstopsema == 1 then
	      InActtime:SetSource(Number(req.Time),0)
	      startstopsema = 0
	      _acttime = req.Time + InTimeoffset:GetValue(req).Value
	   else
	      _acttime = InActtime:GetValue(req).Value + InTimeoffset:GetValue(req).Value
	   end	
	end

    acttime = _acttime / framerate
	
    -------------------------- BufferA-Kernel----------------------------------------
    local nodeName = self.Name
    BufferAKernel = string.gsub(BufferAKernel, "BufferAKernel", nodeName.."A")
    nodeA = DVIPComputeNode(req, nodeName.."A", BufferAKernel, "GlobalParams", GlobalParams)
	
	--nodeA = DVIPComputeNode(req, "BufferAKernel", BufferAKernel, "GlobalParams", GlobalParams)

	local params = {}
	if not pcall(function ()

		params.center = {center.X,center.Y}
		params.scale  = 1/scale
		params.debug  = InDebug:GetValue(req).Value
		params.angle  = angle
		params.pivot  = {InPivot:GetValue(req).X,InPivot:GetValue(req).Y}
		params.freq   = freq
		params.width  = src1.DataWindow:Width()
		params.height = src1.DataWindow:Height()
		params.itime        = acttime --req.Time / framerate
		params.iframe       = req.Time
		
		params.reset        = InResetclick:GetValue(req).Value

		--params.brightness   = InBrightness:GetValue(req).Value
		params.Alpha_Apply 	= InAlpha_Apply:GetValue(req).Value
		params.athres    	= InAlphaThres:GetValue(req).Value
		params.alpha    	= InAlpha:GetValue(req).Value
		params.color        = {InRedCH:GetValue(req).Value, InGreenCH:GetValue(req).Value*1.0, InBlueCH:GetValue(req).Value*1.0,InAlpha:GetValue(req).Value}
		
		nodeA:SetParamBlock(params)
    end) then

		params = nodeA:GetParamBlock(GlobalParams)

		params.center = {center.X,center.Y}
		params.scale  = 1/scale
		params.debug  = InDebug:GetValue(req).Value
		params.angle  = angle
		params.pivot  = {InPivot:GetValue(req).X,InPivot:GetValue(req).Y}
		params.freq   = freq
		params.width  = src1.DataWindow:Width()
		params.height = src1.DataWindow:Height()
		params.itime        = acttime --req.Time / framerate
		params.iframe       = req.Time
		
		params.reset        = InResetclick:GetValue(req).Value
		
		--params.brightness   = InBrightness:GetValue(req).Value
		params.Alpha_Apply 	= InAlpha_Apply:GetValue(req).Value
		params.athres    	= InAlphaThres:GetValue(req).Value		
		params.alpha    	= InAlpha:GetValue(req).Value
        params.color        = {InRedCH:GetValue(req).Value, InGreenCH:GetValue(req).Value*1.0, InBlueCH:GetValue(req).Value*1.0,InAlpha:GetValue(req).Value}
		
		nodeA:SetParamBlock(params)
	end

    nodeA:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)

    nodeA:AddInput("iChannel0", Image_Buff_GlobalA)
	nodeA:AddInput("iChannel1", src2)
    nodeA:AddOutput("dst", dstA)


    local success = nodeA:RunSession(req)
    if not success then
        dstA = nil
        dump(nodeA:GetErrorLog())
    end

    Image_Buff_GlobalA = dstA --Recursiv Image


    if (InResetclick:GetValue(req).Value == 1) then
       InResetclick:SetSource(Number(0),0,0)
    end


  -------------------------- ImageKernel----------------------------------------
  --node = DVIPComputeNode(req, "ImageKernel", ImageKernel, "GlobalParams", GlobalParams)

  ImageKernel = string.gsub(ImageKernel, "ImageKernel", "IK"..nodeName)
  node = DVIPComputeNode(req, "IK"..nodeName, ImageKernel, "GlobalParams", GlobalParams)

  node:SetParamBlock(params)

  node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
  --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_WRAP, TEX_NORMALIZED_COORDS_TRUE)
  --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
  --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_CLAMP,  TEX_NORMALIZED_COORDS_TRUE)
  

  node:AddInput("iChannel0", Image_Buff_GlobalA)
  node:AddInput("iChannel1", src2)
  node:AddOutput("dst", dstI)

  local success = node:RunSession(req)
  if not success then
      dstI = nil
      dump(node:GetErrorLog())
  end

  OutImage:Set(req, dstI)
	collectgarbage();
end


-- **/ "End of LUA CODE"

