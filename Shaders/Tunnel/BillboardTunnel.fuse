--[[--/*

  BillboardTunnel.fuse

  Based on https://www.shadertoy.com/view/lf3fWf a WebGL shader created by wyatt.
  Converted to DCTL and embeddet into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT).
  Place this file in your Fusion's and/or DaVinci Resolve's 'Fuses/' folder to use it.

*/--]]--




-- /*
local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()



-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,
  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  })



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------

-- */
ShaderParameters =
[[

  float  iResolution[2];
  float  iTime;
  float  iMouse[4];
  bool   LIGHT_CHANGE;
  bool   NEON_OPPOSITE;
  bool   Pic2;
  bool   Pic3;
  bool   Pic4;
  bool   Pic5;
  float  NEON_COLOR[4];
  float  NEON_COLOR2[4];
  float  NEON_COLOR3[4];
  float  NEON_COLOR4[4];
  float  NEON_COLOR5[4];
  float  LIGHT_COLOR[4];
  float  Pic1XY[2];
  float  Pic1OffXY[2];
  float  Pic2XY[2];
  float  Pic2OffXY[2];
  float  Pic3XY[2];
  float  Pic3OffXY[2];
  float  Pic4XY[2];
  float  Pic4OffXY[2];
  float  Pic5XY[2];
  float  Pic5OffXY[2];
  float  Pic1Off;
  float  Pic2Off;
  float  Pic3Off;
  float  Pic4Off;
  float  Pic5Off;
  float  Pic1Scale;
  float  Pic2Scale;
  float  Pic3Scale;
  float  Pic4Scale;
  float  Pic5Scale;
  float  TUNNEL_SPEED;
  float  TUNNEL_FLEXIBILITY;
  float  LIGHT_RANGE;
  float  NEON_RANGE;
  float  COLOR_CHANGE_SPEED;
  float  AMBIENT;
  float  Alpha;
  float  WallShift;

  int    width,height;
  int    compOrder;

]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel compatibility code
-- // ------------------------------------------------------------------------

-- */
ShaderCompatibilityCode =
[[


#if defined(DEVICE_IS_METAL)
  #define in
  #define out thread
  #define inout thread
#else
  #define in
  #define out
  #define inout
#endif

#undef USE_NATIVE_METAL_IMPL
#undef USE_NATIVE_CUDA_IMPL
#undef USE_NATIVE_OPENCL_IMPL

  // 0 to use the generic implementations; 1 for Metal, OpenCL, Cuda specific code if existing

  #if 1
    #if defined(DEVICE_IS_METAL)
      #define USE_NATIVE_METAL_IMPL   1
    #elif defined(DEVICE_IS_CUDA)
      #define USE_NATIVE_CUDA_IMPL    1
    #elif defined(DEVICE_IS_OPENCL)
      #define USE_NATIVE_OPENCL_IMPL  1
    #endif
  #endif

  #if defined(USE_NATIVE_METAL_IMPL)

    #define swi2(A,a,b)     (A).a##b
    #define swi3(A,a,b,c)   (A).a##b##c
    #define swi4(A,a,b,c,d) (A).a##b##c##d

    #define swi2S(a,b,c,d)   a.b##c = d
    #define swi3S(a,b,c,d,e) a.b##c##d = e

  #else

    #define swi2(A,a,b)     to_float2((A).a,(A).b)
    #define swi3(A,a,b,c)   to_float3((A).a,(A).b,(A).c)
    #define swi4(A,a,b,c,d) to_float4((A).a,(A).b,(A).c,(A).d)

    #define swi2S(a,b,c,d)   {float2 tmp = d; (a).b = tmp.x; (a).c = tmp.y;}
    #define swi3S(a,b,c,d,e) {float3 tmp = e; (a).b = tmp.x; (a).c = tmp.y; (a).d = tmp.z;}
    #define swi4S(a,b,c,d,e,f) {float4 tmp = f; (a).b = tmp.x; (a).c = tmp.y; (a).d = tmp.z; (a).e = tmp.w;}

  #endif

// ----------------------------------------------------------------------------------------------------------
// mat2 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float2x2 mat2;

  #define to_mat2(A,B,C,D)   mat2((A),(B),(C),(D))

  #define mul_f2_mat2(A,B)   ((A)*(B))

#else

  typedef struct { float2 r0; float2 r1; } mat2;

  __DEVICE__ inline mat2 to_mat2      ( float  a, float  b, float c, float d)  { mat2 t; t.r0.x = a; t.r0.y = b; t.r1.x = c; t.r1.y = d;         return t; }

  __DEVICE__ inline float2 mul_f2_mat2( float2 v, mat2 m )
  {
    float2 t; t.x = v.x*m.r0.x + v.y*m.r0.y; t.y = v.x*m.r1.x + v.y*m.r1.y; return t;
  }

#endif // end of mat2 implementation

#if defined(USE_NATIVE_METAL_IMPL)

 #define fract_f3(A) fract(A)

 #define mod_f(a,b)  fmod((a),(b))

 #define sin_f4(i) sin(i)
 #define abs_f2(a) _fabs(a)
 #define sqrt_f4(a) _sqrtf(a)
 #define ceil_f2(a) ceil(a)

#else

  #if defined(USE_NATIVE_OPENCL_IMPL)

    #define reflect(I,N) (I-2.0f*dot(N,I)*N)

    #define fract(a) ((a)-_floor(a))  // oder Pointer bauen: gentype fract(gentype x, gentype *itpr)

 #define fract_f3(A) to_float3(fract((A).x),fract((A).y),fract((A).z))
 #define mod_f(a,b) _fmod(a,b)
 #define sin_f4(i) sin(i)
 #define abs_f2(a) fabs(a)
 #define sqrt_f4(a) _sqrtf(a)
 #define ceil_f2(a) ceil(a)

 #else // Generic

    #define fract(a) ((a)-_floor(a))

 #define fract_f3(A) to_float3(fract((A).x),fract((A).y),fract((A).z))
 #define mod_f(a,b) ((a)-(b)*_floor((a)/(b)))
 #define sin_f4(i) to_float4( _sinf((i).x), _sinf((i).y), _sinf((i).z), _sinf((i).w))
 #define abs_f2(a) to_float2(_fabs((a).x), _fabs((a).y))
 #define sqrt_f4(a) to_float4(_sqrtf((a).x),_sqrtf((a).y),_sqrtf((a).z),_sqrtf((a).w))
 #define ceil_f2(a) to_float2(_ceil((a).x), _ceil((a).y))

  #endif

#endif

#define to_float4_f2f2(A,B) to_float4((A).x,(A).y,(B).x,(B).y ) // or is there some to_float_..() for that?!? - No - that is missing in DCTL :-) but now we have "one"


]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel implementation
-- // ------------------------------------------------------------------------

-- */
ShaderKernelCode =
[[

// ----------------------------------------------------------------------------------
// - Image                                                                          -
// ----------------------------------------------------------------------------------
// Connect Image 'Texture: Picture1' to iChannel0
// Connect Image 'Texture: Picture2' to iChannel1
// Connect Image 'Texture: Picture3' to iChannel2
// Connect Image 'Texture: Picture4' to iChannel3
// Connect Image 'Texture: Picture5' to iChannel4

#define texture(ch,uv) _tex2DVecN(ch, (uv).x, (uv).y, 15)

// Fork of "Billboard Tunnel" by wyatt. https://shadertoy.com/view/sttyR4
// 2024-12-07 07:35:36

//#define TUNNEL_SPEED 1.0f
//#define TUNNEL_FLEXIBILITY 1.0f
//#define LIGHT_RANGE 1.0f
//#define NEON_RANGE 1.0f
//#define COLOR_CHANGE_SPEED 0.1f
//#define NEON_COLOR to_float3(1,0,1)
//#define NEON_OPPOSITE true
//#define AMBIENT 0.3f
//#define LIGHT_COLOR to_float3(1,1,1)
//#define LIGHT_CHANGE true
#define R iResolution
#define ei(a) to_mat2(_cosf(a),_sinf(a),-_sinf(a),_cosf(a))

__DEVICE__ float segment (float2 p, float2 a, float2 b) {
    float l =  length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.0f,1.0f));
    return 0.5f*_expf(-10.0f*l*l)+smoothstep(0.05f,0.03f,l);
}
__DEVICE__ float box(float2 p, float2 b) {
      float2 d = abs_f2(p) - b*0.5f;
      return _fminf(_fmaxf(d.x,d.y),0.0f) + length(_fmaxf(d,to_float2_s(0.0f)));
}

//float3 uv;

__DEVICE__ float3 hash (float2 p)
{
    float3 p3 = fract_f3((swi3(p,x,y,x)) * to_float3(0.1031f, 0.1030f, 0.0973f));
    p3 += dot(p3, swi3(p3,y,x,z)+33.33f);
    return fract_f3((swi3(p3,x,x,y)+swi3(p3,y,z,z))*swi3(p3,z,y,x));
}

__DEVICE__ float3 noise(float2 p)
{
    float4 w = to_float4_f2f2(_floor(p), ceil_f2 (p)  );
    float3
        _00 = hash(swi2(w,x,y)),
        _01 = hash(swi2(w,x,w)),
        _10 = hash(swi2(w,z,y)),
        _11 = hash(swi2(w,z,w)),
        _0 = _mix(_00,_01,fract(p.y)),
        _1 = _mix(_10,_11,fract(p.y));
    return _mix(_0,_1,fract(p.x));
}
__DEVICE__ float3 fbm (float2 p)
{
    float3 w = to_float3_s(0);
    float N = 5.0f;
    for (float i = 1.0f; i < N; i++)
    {
        p = mul_f2_mat2(p*1.7f,ei(0.5f));
        w += noise(p)/N/i;
    }
    return w;
}
__DEVICE__ float map (float3 p, float TUNNEL_FLEXIBILITY, float TUNNEL_SPEED, float iTime, inout float3 *uv, float4 Box, float Boxb) {
    p.x += TUNNEL_FLEXIBILITY*0.4f*(_sinf(0.8f*p.z+TUNNEL_SPEED*iTime));
    float3 n = to_float3(0,0,1);
    float3 c = to_float3_s(0);
    float d = dot(p,n);
    float l = -(length(p-(c+n*d))-1.0f);
    l = _fminf(l,length(swi2(p,x,y)+to_float2(0,-1.0f))-0.04f);
    swi2S(*uv,x,y, to_float2( d+TUNNEL_SPEED*iTime, _atan2f(p.x,p.y)/3.1459 ));
    if ((*uv).y<0.0f) {
        (*uv).x += 7.33f+Boxb;
    }
    (*uv).x = mod_f((*uv).x,14.0f);
    (*uv).z = 0.0f;
    float rd = _fminf(l,_fabs(p.y+0.6f)-0.05f);
    float2 v = swi2(p,x,y);

    //v += swi2(Box,x,y);//Bürgersteig !!
    v.y += 0.57f;
    v.x = _fabs(v.x)-0.75f;
    float b = box(v,to_float2(0.2f,0.1f))-0.02f;
    if (b<rd&&b<l) { // Bürgersteig
        (*uv).z = 2.0f;
        return b;
    }

    if (rd<l) { // Fahrstreifen
        swi2S(*uv,x,y, to_float2( p.x, 0.25f*(*uv).x ));
        (*uv).z = 1.0f;
        return rd;
    } else return l;
}

__DEVICE__ float3 normal (float3 p, float TUNNEL_FLEXIBILITY, float TUNNEL_SPEED, float iTime, inout float3 *uv, float4 Box, float Boxb) {
    float2 e = to_float2(1e-3,0);
    return normalize(to_float3(
                                map(p+swi3(e,x,y,y), TUNNEL_FLEXIBILITY, TUNNEL_SPEED, iTime, uv, Box, Boxb)-map(p-swi3(e,x,y,y), TUNNEL_FLEXIBILITY, TUNNEL_SPEED, iTime, uv, Box, Boxb),
                                map(p+swi3(e,y,x,y), TUNNEL_FLEXIBILITY, TUNNEL_SPEED, iTime, uv, Box, Boxb)-map(p-swi3(e,y,x,y), TUNNEL_FLEXIBILITY, TUNNEL_SPEED, iTime, uv, Box, Boxb),
                                map(p+swi3(e,y,y,x), TUNNEL_FLEXIBILITY, TUNNEL_SPEED, iTime, uv, Box, Boxb)-map(p-swi3(e,y,y,x), TUNNEL_FLEXIBILITY, TUNNEL_SPEED, iTime, uv, Box, Boxb)
                             ));
}

__KERNEL__ void BillboardTunnelFuse(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0,  __TEXTURE2D__ iChannel1,  __TEXTURE2D__ iChannel2,  __TEXTURE2D__ iChannel3,  __TEXTURE2D__ iChannel4, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  float4 Q   = to_float4_s(0.0f);
  float2 U   = to_float2(fusion_x,fusion_y);

  bool   LIGHT_CHANGE = params->LIGHT_CHANGE;
  bool   NEON_OPPOSITE = params->NEON_OPPOSITE;
  bool   Pic2 = params->Pic2;
  bool   Pic3 = params->Pic3;
  bool   Pic4 = params->Pic4;
  bool   Pic5 = params->Pic5;
  float4 NEON_COLOR = to_float4(params->NEON_COLOR[0], params->NEON_COLOR[1], params->NEON_COLOR[2], params->NEON_COLOR[3]);
  float4 NEON_COLOR2 = to_float4(params->NEON_COLOR2[0], params->NEON_COLOR2[1], params->NEON_COLOR2[2], params->NEON_COLOR2[3]);
  float4 NEON_COLOR3 = to_float4(params->NEON_COLOR3[0], params->NEON_COLOR3[1], params->NEON_COLOR3[2], params->NEON_COLOR3[3]);
  float4 NEON_COLOR4 = to_float4(params->NEON_COLOR4[0], params->NEON_COLOR4[1], params->NEON_COLOR4[2], params->NEON_COLOR4[3]);
  float4 NEON_COLOR5 = to_float4(params->NEON_COLOR5[0], params->NEON_COLOR5[1], params->NEON_COLOR5[2], params->NEON_COLOR5[3]);
  float4 LIGHT_COLOR = to_float4(params->LIGHT_COLOR[0], params->LIGHT_COLOR[1], params->LIGHT_COLOR[2], params->LIGHT_COLOR[3]);
  float2 Pic1XY = to_float2(params->Pic1XY[0], params->Pic1XY[1]);
  float2 Pic1OffXY = to_float2(params->Pic1OffXY[0], params->Pic1OffXY[1]);
  float2 Pic2XY = to_float2(params->Pic2XY[0], params->Pic2XY[1]);
  float2 Pic2OffXY = to_float2(params->Pic2OffXY[0], params->Pic2OffXY[1]);
  float2 Pic3XY = to_float2(params->Pic3XY[0], params->Pic3XY[1]);
  float2 Pic3OffXY = to_float2(params->Pic3OffXY[0], params->Pic3OffXY[1]);
  float2 Pic4XY = to_float2(params->Pic4XY[0], params->Pic4XY[1]);
  float2 Pic4OffXY = to_float2(params->Pic4OffXY[0], params->Pic4OffXY[1]);
  float2 Pic5XY = to_float2(params->Pic5XY[0], params->Pic5XY[1]);
  float2 Pic5OffXY = to_float2(params->Pic5OffXY[0], params->Pic5OffXY[1]);
  float  Pic1Off = params->Pic1Off;
  float  Pic2Off = params->Pic2Off;
  float  Pic3Off = params->Pic3Off;
  float  Pic4Off = params->Pic4Off;
  float  Pic5Off = params->Pic5Off;
  float  Pic1Scale = params->Pic1Scale;
  float  Pic2Scale = params->Pic2Scale;
  float  Pic3Scale = params->Pic3Scale;
  float  Pic4Scale = params->Pic4Scale;
  float  Pic5Scale = params->Pic5Scale;
  float  TUNNEL_SPEED = params->TUNNEL_SPEED;
  float  TUNNEL_FLEXIBILITY = params->TUNNEL_FLEXIBILITY;
  float  LIGHT_RANGE = params->LIGHT_RANGE;
  float  NEON_RANGE = params->NEON_RANGE;
  float  COLOR_CHANGE_SPEED = params->COLOR_CHANGE_SPEED;
  float  AMBIENT = params->AMBIENT;
  float  Alpha = params->Alpha;
  float  WallShift = params->WallShift;

  // --------

  // Test
  float4 Box  = to_float4_f2f2(Pic3XY, Pic3OffXY);//to_float4_s(0.0f);//
  float  Boxb = WallShift;//Pic2Off;

    mat2 dummy;
    float3 uv;

    float2 mouse = swi2(iMouse,x,y)/iResolution - 0.5f;

    U = 2.0f*(U-0.5f*R)/R.y + mouse;
    float3 p = to_float3(0,0,0);
    p.x -= TUNNEL_FLEXIBILITY*0.4f*_sinf(p.z+TUNNEL_SPEED*iTime);
    float3 d = normalize(to_float3_aw(U,2));
    swi2S(d,x,z, mul_f2_mat2(swi2(d,x,z) ,ei(0.5f*TUNNEL_FLEXIBILITY*0.4f*-_cosf(p.z+TUNNEL_SPEED*iTime))));
    for (float i = 0.0f; i < 40.0f; i++) {
        p += d*map(p, TUNNEL_FLEXIBILITY, TUNNEL_SPEED, iTime, &uv, Box, Boxb);
    }
    float x = uv.x;
    if (uv.z==1.0f) {
        if (_fabs(_fabs(uv.x)-0.04f)<0.02f)
            Q = to_float4(1,1,0,1);
        else Q = to_float4_s(0.2f);

        if (_fabs(_fabs(uv.x)-0.55f)<0.02f)
            Q = to_float4_s(0.5f);
        Q *= (0.8f+fbm(60.0f*swi2(uv,x,y)).x);
        swi2S(uv,x,y, swi2(uv,y,x));
        uv.x *= 4.0f;
        uv.y *= 0.25f;
    }
    if (uv.z == 2.0f) {
         Q = to_float4_s(0.9f)*(0.7f-0.3f*_fabs(normal(p, TUNNEL_FLEXIBILITY, TUNNEL_SPEED, iTime, &uv, Box, Boxb).x));
         Q *= smoothstep(0.0f,0.015f,_fabs(fract(0.5f+1.5f*uv.x)-0.1f));
         Q *= (0.8f+0.5f*fbm(200.0f*swi2(uv,x,y)).x);
    }
    if (uv.z == 0.0f) {

        float3 n = normal(p, TUNNEL_FLEXIBILITY, TUNNEL_SPEED, iTime, &uv, Box, Boxb);
        uv.y = 1.0f-_fabs(uv.y);
        swi2S(uv,x,y, swi2(uv,x,y)*3.0f-1.0f);
        uv.x *= 0.5f;
        Q = 0.8f*sqrt_f4(0.5f+0.5f*swi4(uv,y,y,y,y))*
           (0.9f+0.1f*smoothstep(0.0f,0.001f,_fabs(fbm(swi2(uv,x,y)).x-0.2f)))*
           (0.8f+0.4f*fbm(10.0f*swi2(uv,x,y)).x) *
           smoothstep(0.0f,0.01f,_fabs(fract(1.0f*uv.x)-0.1f));

     }else {
        uv.y = 1.0f-_fabs(uv.y);
        swi2S(uv,x,y, swi2(uv,x,y)*3.0f-1.0f);
        uv.x *= 0.5f;
     }
     Q *= AMBIENT;
     float4 light_color = 0.5f+0.5f*sin_f4(COLOR_CHANGE_SPEED*iTime+to_float4(1,2,3,4));
     if (!LIGHT_CHANGE) light_color = LIGHT_COLOR;//swi3S(light_color,x,y,z, swi3(LIGHT_COLOR,x,y,z));
     light_color.w = 1.0f;
     swi3S(light_color,x,y,z, swi3(light_color,x,y,z) * 0.5f);
     if (uv.z!=1.0f&&_fabs(2.0f-uv.y)<0.04f){
        Q =0.4f+light_color;
        Q *= smoothstep(0.02f,0.04f,_fabs(fract(0.5f+1.5f*x)-0.1f));
     }
     else if (uv.z!=1.0f&&_fabs(2.0f-uv.y)<0.06f) Q *=0.0f;

        Q += Q/AMBIENT*light_color*_expf(-_fabs(2.0f-uv.y)/LIGHT_RANGE);
        uv.y -= 0.15f;
        uv.x -= 9.25f;
        uv.x*=0.5f;
        swi2S(uv,x,y, swi2(uv,x,y) + 0.05f);
        swi2S(uv,x,y, swi2(uv,x,y) * 1.05f);

        {
            float2 tuv = (swi2(uv,x,y) + Pic1XY) * Pic1Scale;
            float d = box(tuv-0.5f,to_float2_s(1.0f-0.03f)+Pic1OffXY)-0.03f+Pic1Off;
            if (_fabs(d)<0.01f) Q *= 0.0f;
            float4 col = NEON_COLOR;//to_float4_aw(NEON_COLOR,1);
            if (LIGHT_CHANGE) col = 0.5f+(NEON_OPPOSITE?-1.0f:1.0f)*0.5f*sin_f4(COLOR_CHANGE_SPEED*iTime+to_float4(1,2,3,4));
            col.w = 1.0f;
            if (uv.z == 1.0f) col *= 3.0f;
            Q += Q/AMBIENT*(
               smoothstep(5.0f,4.0f,_fabs(tuv.x))*
               smoothstep(2.0f,1.8f,tuv.y)*
               (0.5f+col)*0.2f*_expf(-2.5f/NEON_RANGE*_fabs(d))+
                col*1.5f*_expf(-50.0f*_fabs(d-0.01f))
                );
            if (d < 0.0f) {
              Q = texture(iChannel0,swi2(tuv,x,y));
            }
        }

        if(Pic2)
        { // Picture2
            float2 tuv = (swi2(uv,x,y) + Pic2XY) * Pic2Scale;
            float d = box(tuv-0.5f,to_float2_s(1.0f-0.03f)+Pic2OffXY)-0.03f+Pic2Off;
            if (_fabs(d)<0.01f) Q *= 0.0f;
            float4 col = NEON_COLOR2;//to_float4_aw(NEON_COLOR,1);
            if (LIGHT_CHANGE) col = 0.5f+(NEON_OPPOSITE?-1.0f:1.0f)*0.5f*sin_f4(COLOR_CHANGE_SPEED*iTime+to_float4(1,2,3,4));
            col.w = 1.0f;
            if (uv.z == 1.0f) col *= 3.0f;
            Q += Q/AMBIENT*(
               smoothstep(5.0f,4.0f,_fabs(tuv.x))*
               smoothstep(2.0f,1.8f,tuv.y)*
               (0.5f+col)*0.2f*_expf(-2.5f/NEON_RANGE*_fabs(d))+
                col*1.5f*_expf(-50.0f*_fabs(d-0.01f))
                );
            if (d < 0.0f) {
            Q = texture(iChannel1,swi2(tuv,x,y));
            }
        }

        if(Pic3)
        { // Picture2
            float2 tuv = (swi2(uv,x,y) + Pic3XY) * Pic3Scale;
            float d = box(tuv-0.5f,to_float2_s(1.0f-0.03f)+Pic3OffXY)-0.03f+Pic3Off;
            if (_fabs(d)<0.01f) Q *= 0.0f;
            float4 col = NEON_COLOR3;//to_float4_aw(NEON_COLOR,1);
            if (LIGHT_CHANGE) col = 0.5f+(NEON_OPPOSITE?-1.0f:1.0f)*0.5f*sin_f4(COLOR_CHANGE_SPEED*iTime+to_float4(1,2,3,4));
            col.w = 1.0f;
            if (uv.z == 1.0f) col *= 3.0f;
            Q += Q/AMBIENT*(
               smoothstep(5.0f,4.0f,_fabs(tuv.x))*
               smoothstep(2.0f,1.8f,tuv.y)*
               (0.5f+col)*0.2f*_expf(-2.5f/NEON_RANGE*_fabs(d))+
                col*1.5f*_expf(-50.0f*_fabs(d-0.01f))
                );
            if (d < 0.0f) {
            Q = texture(iChannel2,swi2(tuv,x,y));
            }
        }

        if(Pic4)
        { // Picture2
            float2 tuv = (swi2(uv,x,y) + Pic4XY) * Pic4Scale;
            float d = box(tuv-0.5f,to_float2_s(1.0f-0.03f)+Pic4OffXY)-0.03f+Pic4Off;
            if (_fabs(d)<0.01f) Q *= 0.0f;
            float4 col = NEON_COLOR4;//to_float4_aw(NEON_COLOR,1);
            if (LIGHT_CHANGE) col = 0.5f+(NEON_OPPOSITE?-1.0f:1.0f)*0.5f*sin_f4(COLOR_CHANGE_SPEED*iTime+to_float4(1,2,3,4));
            col.w = 1.0f;
            if (uv.z == 1.0f) col *= 3.0f;
            Q += Q/AMBIENT*(
               smoothstep(5.0f,4.0f,_fabs(tuv.x))*
               smoothstep(2.0f,1.8f,tuv.y)*
               (0.5f+col)*0.2f*_expf(-2.5f/NEON_RANGE*_fabs(d))+
                col*1.5f*_expf(-50.0f*_fabs(d-0.01f))
                );
            if (d < 0.0f) {
            Q = texture(iChannel3,swi2(tuv,x,y));
            }
        }

        if(Pic5)
        { // Picture2
            float2 tuv = (swi2(uv,x,y) + Pic5XY) * Pic5Scale;
            float d = box(tuv-0.5f,to_float2_s(1.0f-0.03f)+Pic5OffXY)-0.03f+Pic5Off;
            if (_fabs(d)<0.01f) Q *= 0.0f;
            float4 col = NEON_COLOR5;//to_float4_aw(NEON_COLOR,1);
            if (LIGHT_CHANGE) col = 0.5f+(NEON_OPPOSITE?-1.0f:1.0f)*0.5f*sin_f4(COLOR_CHANGE_SPEED*iTime+to_float4(1,2,3,4));
            col.w = 1.0f;
            if (uv.z == 1.0f) col *= 3.0f;
            Q += Q/AMBIENT*(
               smoothstep(5.0f,4.0f,_fabs(tuv.x))*
               smoothstep(2.0f,1.8f,tuv.y)*
               (0.5f+col)*0.2f*_expf(-2.5f/NEON_RANGE*_fabs(d))+
                col*1.5f*_expf(-50.0f*_fabs(d-0.01f))
                );
            if (d < 0.0f) {
            Q = texture(iChannel4,swi2(tuv,x,y));
            }
        }

    Q *= _expf(-0.01f*p.z*p.z);

    Q.w = Alpha == 0.0f ? Q.w : Alpha;

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, Q);
}
]]
-- /*



-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ShaderFuse.begin_create()

  ----- Inspector Panel Controls

  
  -- Speed Slider
  
  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",
  })
  
  -- iMouse Controls
  
  InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
  })
  
  InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
    INP_Disabled = true,
  })
  
  InMouseDrag = self:AddInput("Mouse Button Pressed", "iMouseClick", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = false,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0,
  })
  InLIGHT_CHANGECheckbox = self:AddInput("LIGHT_CHANGE", "LIGHT_CHANGE", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 1,
  })

  InNEON_OPPOSITECheckbox = self:AddInput("NEON_OPPOSITE", "NEON_OPPOSITE", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 1,
  })

  InPic2Checkbox = self:AddInput("Pic2", "Pic2", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  InPic3Checkbox = self:AddInput("Pic3", "Pic3", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  InPic4Checkbox = self:AddInput("Pic4", "Pic4", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

  InPic5Checkbox = self:AddInput("Pic5", "Pic5", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })


  self:BeginControlNest("Colors", "Colors", false, {})
  self:BeginControlNest("NEON_COLOR", "NEON_COLOR", true, {})
  
    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "NEON_COLOR",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InNEON_COLORColorR = self:AddInput("Red",   "NEON_COLORRed",   { INP_Default  = 1.0, IC_ControlID = 0, attrs})
    InNEON_COLORColorG = self:AddInput("Green", "NEON_COLORGreen", { INP_Default  = 0.0, IC_ControlID = 1, attrs})
    InNEON_COLORColorB = self:AddInput("Blue",  "NEON_COLORBlue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InNEON_COLORColorA = self:AddInput("Alpha", "NEON_COLORAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("NEON_COLOR2", "NEON_COLOR2", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "NEON_COLOR2",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InNEON_COLOR2ColorR = self:AddInput("Red",   "NEON_COLOR2Red",   { INP_Default  = 1.0, IC_ControlID = 0, attrs})
    InNEON_COLOR2ColorG = self:AddInput("Green", "NEON_COLOR2Green", { INP_Default  = 0.0, IC_ControlID = 1, attrs})
    InNEON_COLOR2ColorB = self:AddInput("Blue",  "NEON_COLOR2Blue",  { INP_Default  = 0.0, IC_ControlID = 2, attrs})
    InNEON_COLOR2ColorA = self:AddInput("Alpha", "NEON_COLOR2Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("NEON_COLOR3", "NEON_COLOR3", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "NEON_COLOR3",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InNEON_COLOR3ColorR = self:AddInput("Red",   "NEON_COLOR3Red",   { INP_Default  = 1.0, IC_ControlID = 0, attrs})
    InNEON_COLOR3ColorG = self:AddInput("Green", "NEON_COLOR3Green", { INP_Default  = 1.0, IC_ControlID = 1, attrs})
    InNEON_COLOR3ColorB = self:AddInput("Blue",  "NEON_COLOR3Blue",  { INP_Default  = 0.0, IC_ControlID = 2, attrs})
    InNEON_COLOR3ColorA = self:AddInput("Alpha", "NEON_COLOR3Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("NEON_COLOR4", "NEON_COLOR4", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "NEON_COLOR4",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InNEON_COLOR4ColorR = self:AddInput("Red",   "NEON_COLOR4Red",   { INP_Default  = 0.0, IC_ControlID = 0, attrs})
    InNEON_COLOR4ColorG = self:AddInput("Green", "NEON_COLOR4Green", { INP_Default  = 0.0, IC_ControlID = 1, attrs})
    InNEON_COLOR4ColorB = self:AddInput("Blue",  "NEON_COLOR4Blue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InNEON_COLOR4ColorA = self:AddInput("Alpha", "NEON_COLOR4Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("NEON_COLOR5", "NEON_COLOR5", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "NEON_COLOR5",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InNEON_COLOR5ColorR = self:AddInput("Red",   "NEON_COLOR5Red",   { INP_Default  = 0.0, IC_ControlID = 0, attrs})
    InNEON_COLOR5ColorG = self:AddInput("Green", "NEON_COLOR5Green", { INP_Default  = 1.0, IC_ControlID = 1, attrs})
    InNEON_COLOR5ColorB = self:AddInput("Blue",  "NEON_COLOR5Blue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InNEON_COLOR5ColorA = self:AddInput("Alpha", "NEON_COLOR5Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("LIGHT_COLOR", "LIGHT_COLOR", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "LIGHT_COLOR",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InLIGHT_COLORColorR = self:AddInput("Red",   "LIGHT_COLORRed",   { INP_Default  = 1.0, IC_ControlID = 0, attrs})
    InLIGHT_COLORColorG = self:AddInput("Green", "LIGHT_COLORGreen", { INP_Default  = 1.0, IC_ControlID = 1, attrs})
    InLIGHT_COLORColorB = self:AddInput("Blue",  "LIGHT_COLORBlue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InLIGHT_COLORColorA = self:AddInput("Alpha", "LIGHT_COLORAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()
  self:EndControlNest()

  InPic1XYPoint = self:AddInput("Pic1XY", "Pic1XY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic1OffXYPoint = self:AddInput("Pic1OffXY", "Pic1OffXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic2XYPoint = self:AddInput("Pic2XY", "Pic2XY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic2OffXYPoint = self:AddInput("Pic2OffXY", "Pic2OffXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic3XYPoint = self:AddInput("Pic3XY", "Pic3XY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic3OffXYPoint = self:AddInput("Pic3OffXY", "Pic3OffXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic4XYPoint = self:AddInput("Pic4XY", "Pic4XY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic4OffXYPoint = self:AddInput("Pic4OffXY", "Pic4OffXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic5XYPoint = self:AddInput("Pic5XY", "Pic5XY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic5OffXYPoint = self:AddInput("Pic5OffXY", "Pic5OffXY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InPic1OffSlider = self:AddInput("Pic1Off", "Pic1Off", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InPic2OffSlider = self:AddInput("Pic2Off", "Pic2Off", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InPic3OffSlider = self:AddInput("Pic3Off", "Pic3Off", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InPic4OffSlider = self:AddInput("Pic4Off", "Pic4Off", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InPic5OffSlider = self:AddInput("Pic5Off", "Pic5Off", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InPic1ScaleSlider = self:AddInput("Pic1Scale", "Pic1Scale", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InPic2ScaleSlider = self:AddInput("Pic2Scale", "Pic2Scale", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InPic3ScaleSlider = self:AddInput("Pic3Scale", "Pic3Scale", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InPic4ScaleSlider = self:AddInput("Pic4Scale", "Pic4Scale", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InPic5ScaleSlider = self:AddInput("Pic5Scale", "Pic5Scale", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InTUNNEL_SPEEDSlider = self:AddInput("TUNNEL_SPEED", "TUNNEL_SPEED", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InTUNNEL_FLEXIBILITYSlider = self:AddInput("TUNNEL_FLEXIBILITY", "TUNNEL_FLEXIBILITY", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InLIGHT_RANGESlider = self:AddInput("LIGHT_RANGE", "LIGHT_RANGE", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InNEON_RANGESlider = self:AddInput("NEON_RANGE", "NEON_RANGE", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 1.0,
      })

  InCOLOR_CHANGE_SPEEDSlider = self:AddInput("COLOR_CHANGE_SPEED", "COLOR_CHANGE_SPEED", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 2.0,
          INP_Default        = 0.1,
      })

  InAMBIENTSlider = self:AddInput("AMBIENT", "AMBIENT", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 2.0,
          INP_Default        = 0.3,
      })

  InAlphaSlider = self:AddInput("Alpha", "Alpha", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = 0.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 1.0,
      })

  InWallShiftSlider = self:AddInput("WallShift", "WallShift", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })



  Sep3 = self:AddInput(string.rep("_", 152), "Separator3", {
    LINKID_DataType     = "Text",
    INPID_InputControl  = "LabelControl",
    INP_External        = false,
    INP_Passive         = true,
    IC_Visible          = true,
    INP_DoNotifyChanged = true,
    IC_NoLabel          = true,
  })
  
  
  InEdges = self:AddInput("Edges", "Edges", {
    LINKID_DataType = "Number",
    INPID_InputControl  = "MultiButtonControl",
    INP_Default         = 3.0,
    INP_Integer         = true,
    INP_DoNotifyChanged = true,
    INP_External        = false,
    MBTNC_ForceButtons  = true,
    INP_MinScale        = 0,
    INP_MaxScale        = 3,
    INP_MinAllowed      = 0,
    INP_MaxAllowed      = 3,
    MBTNC_ShowBasicButton = true,
    MBTNC_StretchToFit  = false, --true,
    MBTNC_ShowToolTip   = true,
    { MBTNC_AddButton = "Canvas", MBTNCD_ButtonWidth = 4/16, },
    { MBTNC_AddButton = "Wrap",MBTNCD_ButtonWidth = 3/16, },
    { MBTNC_AddButton = "Duplicate", MBTNCD_ButtonWidth = 5/16, },
    { MBTNC_AddButton = "Mirror", MBTNCD_ButtonWidth = 4/16, }, 
   }) 

  ----- Size & Depth
  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
    INP_DoNotifyChanged = true,
    INP_Default        = 0,
    INP_Integer        = true,
    ICD_Width          = 1,
	  { CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	  { CCS_AddString  = "Image0", },
    { CCS_AddString  = "1920x1080", },
	  { CCS_AddString  = "1200x675", },
	  { CCS_AddString  = "800x450", },
	  { CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
  
  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
    INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
    { CCS_AddString  = "Default", },
    { CCS_AddString  = "int8", },
    { CCS_AddString  = "int16", },
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
    ICS_ControlPage  = "Image",
  })
  
  InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false }) 

  ----- In/Out

  InChannel0 = self:AddInput( "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
  InChannel1 = self:AddInput( "iChannel1",  "iChannel1",  { LINKID_DataType = "Image", LINK_Main = 2, INP_Required = false  })
  InChannel2 = self:AddInput( "iChannel2",  "iChannel2",  { LINKID_DataType = "Image", LINK_Main = 3, INP_Required = false  })
  InChannel3 = self:AddInput( "iChannel3",  "iChannel3",  { LINKID_DataType = "Image", LINK_Main = 4, INP_Required = false  })
  InChannel4 = self:AddInput( "iChannel4",  "iChannel4",  { LINKID_DataType = "Image", LINK_Main = 5, INP_Required = false  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main       = 1,
  })


  ShaderFuse.end_create()

end



-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------
function DefineEdges(edges, nodeX)

    --This gets the value of our input image for us to modify inside the kernel
    if edges == 0 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 1 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_WRAP, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 2 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_DUPLICATE, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 3 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 4 then
      --print("Sampler 4")
    end
end


function Process(req)

	-- Imagesize and Depth
  if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InChannel0:GetValue(req) ~= nil) then
			   Width = InChannel0:GetValue(req).Width
			   Height = InChannel0:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value 
		end
	end	
  
  -- Alle ( int und float )
  if (InDepth:GetValue(req).Value > 0) then
	  if InDepth:GetValue(req).Value == 1 then 
	    SourceDepth = 5 
    else 
	    if InDepth:GetValue(req).Value == 2 then 
	        SourceDepth = 6 
	    else 
	        if InDepth:GetValue(req).Value == 3 then 
 		        SourceDepth = 7 
		    	else
			      SourceDepth = 8
	        end
		  end
	  end
	end

  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth  = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }

  local dst   = Image(imgattrs)
  local black = Pixel({R=0,G=0,B=0,A=0})
  dst:Fill(black)

  if req:IsPreCalc() then
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end


  node = DVIPComputeNode(req,
    "BillboardTunnelFuse", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )

  -- Extern texture or create a new one

  iChannel0 = InChannel0:GetValue(req)

  if iChannel0==nil then
    iChannel0 = Image(imgattrs)
    iChannel0:Fill(black)
  end

  iChannel1 = InChannel1:GetValue(req)

  if iChannel1==nil then
    iChannel1 = Image(imgattrs)
    iChannel1:Fill(black)
  end

  iChannel2 = InChannel2:GetValue(req)

  if iChannel2==nil then
    iChannel2 = Image(imgattrs)
    iChannel2:Fill(black)
  end

  iChannel3 = InChannel3:GetValue(req)

  if iChannel3==nil then
    iChannel3 = Image(imgattrs)
    iChannel3:Fill(black)
  end

  iChannel4 = InChannel4:GetValue(req)

  if iChannel4==nil then
    iChannel4 = Image(imgattrs)
    iChannel4:Fill(black)
  end

  -- DCTL parameters

  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}
  params = node:GetParamBlock(ShaderParameters)

  params.iResolution[0] = dst.Width
  params.iResolution[1] = dst.Height
  params.iTime = (req.Time / framerate) * InFrequency:GetValue(req).Value
  
  -- iMouse
  
  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)
  
  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y
  
  if InMouseDrag:GetValue(req).Value ~= 0 then
    if params.iMouse[2]==-1 and params.iMouse[3]==-1 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = -1
    params.iMouse[3] = -1
  end
  
  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end
  
  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  if params.iMouse[2] == -1 and params.iMouse[3] == -1 then
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  else
    params.iMouse[2] = params.iMouse[2] * Width
    params.iMouse[3] = params.iMouse[3] * Height
  end

  params.LIGHT_CHANGE = InLIGHT_CHANGECheckbox:GetValue(req).Value
  params.NEON_OPPOSITE = InNEON_OPPOSITECheckbox:GetValue(req).Value
  params.Pic2 = InPic2Checkbox:GetValue(req).Value
  params.Pic3 = InPic3Checkbox:GetValue(req).Value
  params.Pic4 = InPic4Checkbox:GetValue(req).Value
  params.Pic5 = InPic5Checkbox:GetValue(req).Value
  params.NEON_COLOR = {
    InNEON_COLORColorR:GetValue(req).Value,
    InNEON_COLORColorG:GetValue(req).Value,
    InNEON_COLORColorB:GetValue(req).Value,InNEON_COLORColorA:GetValue(req).Value
  }
  params.NEON_COLOR2 = {
    InNEON_COLOR2ColorR:GetValue(req).Value,
    InNEON_COLOR2ColorG:GetValue(req).Value,
    InNEON_COLOR2ColorB:GetValue(req).Value,InNEON_COLOR2ColorA:GetValue(req).Value
  }
  params.NEON_COLOR3 = {
    InNEON_COLOR3ColorR:GetValue(req).Value,
    InNEON_COLOR3ColorG:GetValue(req).Value,
    InNEON_COLOR3ColorB:GetValue(req).Value,InNEON_COLOR3ColorA:GetValue(req).Value
  }
  params.NEON_COLOR4 = {
    InNEON_COLOR4ColorR:GetValue(req).Value,
    InNEON_COLOR4ColorG:GetValue(req).Value,
    InNEON_COLOR4ColorB:GetValue(req).Value,InNEON_COLOR4ColorA:GetValue(req).Value
  }
  params.NEON_COLOR5 = {
    InNEON_COLOR5ColorR:GetValue(req).Value,
    InNEON_COLOR5ColorG:GetValue(req).Value,
    InNEON_COLOR5ColorB:GetValue(req).Value,InNEON_COLOR5ColorA:GetValue(req).Value
  }
  params.LIGHT_COLOR = {
    InLIGHT_COLORColorR:GetValue(req).Value,
    InLIGHT_COLORColorG:GetValue(req).Value,
    InLIGHT_COLORColorB:GetValue(req).Value,InLIGHT_COLORColorA:GetValue(req).Value
  }
  params.Pic1XY = {InPic1XYPoint:GetValue(req).X,InPic1XYPoint:GetValue(req).Y}
  params.Pic1OffXY = {InPic1OffXYPoint:GetValue(req).X,InPic1OffXYPoint:GetValue(req).Y}
  params.Pic2XY = {InPic2XYPoint:GetValue(req).X,InPic2XYPoint:GetValue(req).Y}
  params.Pic2OffXY = {InPic2OffXYPoint:GetValue(req).X,InPic2OffXYPoint:GetValue(req).Y}
  params.Pic3XY = {InPic3XYPoint:GetValue(req).X,InPic3XYPoint:GetValue(req).Y}
  params.Pic3OffXY = {InPic3OffXYPoint:GetValue(req).X,InPic3OffXYPoint:GetValue(req).Y}
  params.Pic4XY = {InPic4XYPoint:GetValue(req).X,InPic4XYPoint:GetValue(req).Y}
  params.Pic4OffXY = {InPic4OffXYPoint:GetValue(req).X,InPic4OffXYPoint:GetValue(req).Y}
  params.Pic5XY = {InPic5XYPoint:GetValue(req).X,InPic5XYPoint:GetValue(req).Y}
  params.Pic5OffXY = {InPic5OffXYPoint:GetValue(req).X,InPic5OffXYPoint:GetValue(req).Y}
  params.Pic1Off = InPic1OffSlider:GetValue(req).Value
  params.Pic2Off = InPic2OffSlider:GetValue(req).Value
  params.Pic3Off = InPic3OffSlider:GetValue(req).Value
  params.Pic4Off = InPic4OffSlider:GetValue(req).Value
  params.Pic5Off = InPic5OffSlider:GetValue(req).Value
  params.Pic1Scale = InPic1ScaleSlider:GetValue(req).Value
  params.Pic2Scale = InPic2ScaleSlider:GetValue(req).Value
  params.Pic3Scale = InPic3ScaleSlider:GetValue(req).Value
  params.Pic4Scale = InPic4ScaleSlider:GetValue(req).Value
  params.Pic5Scale = InPic5ScaleSlider:GetValue(req).Value
  params.TUNNEL_SPEED = InTUNNEL_SPEEDSlider:GetValue(req).Value
  params.TUNNEL_FLEXIBILITY = InTUNNEL_FLEXIBILITYSlider:GetValue(req).Value
  params.LIGHT_RANGE = InLIGHT_RANGESlider:GetValue(req).Value
  params.NEON_RANGE = InNEON_RANGESlider:GetValue(req).Value
  params.COLOR_CHANGE_SPEED = InCOLOR_CHANGE_SPEEDSlider:GetValue(req).Value
  params.AMBIENT = InAMBIENTSlider:GetValue(req).Value
  params.Alpha = InAlphaSlider:GetValue(req).Value
  params.WallShift = InWallShiftSlider:GetValue(req).Value
  -- Resolution

  params.width  = dst.Width
  params.height = dst.Height

  -- Per channel time and resolution
  local edges = InEdges:GetValue(req).Value

  -- Set parameters and add I/O
  node:SetParamBlock(params)
  --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
  DefineEdges(edges, node)
    
  node:AddInput("iChannel0",iChannel0) -- TODO: add a better channel name
  node:AddInput("iChannel1",iChannel1) -- TODO: add a better channel name
  node:AddInput("iChannel2",iChannel2) -- TODO: add a better channel name
  node:AddInput("iChannel3",iChannel3) -- TODO: add a better channel name
  node:AddInput("iChannel4",iChannel4) -- TODO: add a better channel name
  node:AddOutput("dst", dst)

  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    dump(node:GetErrorLog())
	end

  OutImage:Set(req,dst)
  
  collectgarbage();
end

-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

function NotifyChanged(inp, param, time)
 	if (param ~= nil) then

		if inp == InSize then
		  if param.Value == 1 then
			  InWidth:SetAttrs({ IC_Visible = true })
			  InHeight:SetAttrs({ IC_Visible = true })
		  else
			  InWidth:SetAttrs({ IC_Visible = false })
			  InHeight:SetAttrs({ IC_Visible = false })
		  end
		  
		  if param.Value == 3 then --1920x1080
			  InWidth:SetSource(Number(1920),0,0)
			  InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			  InWidth:SetSource(Number(1200),0,0)
			  InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			  InWidth:SetSource(Number(800),0,0)
			  InHeight:SetSource(Number(450),0,0)
		  end
 	    if param.Value == 6 then --640x360
		    InWidth:SetSource(Number(640),0,0)
		    InHeight:SetSource(Number(360),0,0)
		  end
		end 

 	end
end

-- */
