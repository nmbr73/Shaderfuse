--[[--/*

  MountainbytesPppp4KibWindows.fuse

  Based on https://www.shadertoy.com/view/lX2GzD a WebGL shader created by mrange.
  Converted to DCTL and embeddet into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT).
  Place this file in your Fusion's and/or DaVinci Resolve's 'Fuses/' folder to use it.

*/--]]--




-- /*
local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()



-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,
  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  })



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------

-- */
ShaderParameters =
[[

  float  iResolution[2];
  float  iTime;
  float  iMouse[4];
  bool   noFlash;
  float  SunCol0[4];
  float  SunCol1[4];
  float  GridCol0[4];
  float  GridCol1[4];
  float  RoadGlow[4];
  float  BikeFlash[4];
  float  AbsorbCol[4];
  float  SunDir[4];
  float  path_a;
  float  path_b;
  float  minh;
  float  maxh;
  float  wl;
  float  innerAdj;
  float  ch;
  float  ibpm;
  float  Per;
  float  stp;
  float  Lp;
  float  FoF;
  float  rnd;
  float  period;
  float  AbsorbFkt;
  float  SkyColFkt;
  float  InnerGlowFkt;
  float  tilt;
  float  zoom;

  int    width,height;
  int    compOrder;

]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel compatibility code
-- // ------------------------------------------------------------------------

-- */
ShaderCompatibilityCode =
[[


#if defined(DEVICE_IS_METAL)
  #define in
  #define out thread
  #define inout thread
#else
  #define in
  #define out
  #define inout
#endif

#undef USE_NATIVE_METAL_IMPL
#undef USE_NATIVE_CUDA_IMPL
#undef USE_NATIVE_OPENCL_IMPL

  // 0 to use the generic implementations; 1 for Metal, OpenCL, Cuda specific code if existing

  #if 1
    #if defined(DEVICE_IS_METAL)
      #define USE_NATIVE_METAL_IMPL   1
    #elif defined(DEVICE_IS_CUDA)
      #define USE_NATIVE_CUDA_IMPL    1
    #elif defined(DEVICE_IS_OPENCL)
      #define USE_NATIVE_OPENCL_IMPL  1
    #endif
  #endif

  #if defined(USE_NATIVE_METAL_IMPL)

    #define swi2(A,a,b)     (A).a##b
    #define swi3(A,a,b,c)   (A).a##b##c

    #define swi2S(a,b,c,d)   a.b##c = d

  #else

    #define swi2(A,a,b)     to_float2((A).a,(A).b)
    #define swi3(A,a,b,c)   to_float3((A).a,(A).b,(A).c)

    #define swi2S(a,b,c,d)   {float2 tmp = d; (a).b = tmp.x; (a).c = tmp.y;}

  #endif

// ----------------------------------------------------------------------------------------------------------
// mat2 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float2x2 mat2;

  #define to_mat2(A,B,C,D)   mat2((A),(B),(C),(D))

  #define mul_f2_mat2(A,B)   ((A)*(B))

#else

  typedef struct { float2 r0; float2 r1; } mat2;

  __DEVICE__ inline mat2 to_mat2      ( float  a, float  b, float c, float d)  { mat2 t; t.r0.x = a; t.r0.y = b; t.r1.x = c; t.r1.y = d;         return t; }

  __DEVICE__ inline float2 mul_f2_mat2( float2 v, mat2 m )
  {
    float2 t; t.x = v.x*m.r0.x + v.y*m.r0.y; t.y = v.x*m.r1.x + v.y*m.r1.y; return t;
  }

#endif // end of mat2 implementation

#if defined(USE_NATIVE_METAL_IMPL)

 #define fract_f2(A) fract(A)

 #define mod_f(a,b)  fmod((a),(b))

 #define tanh_f3(i) tanh(i)
 #define abs_f2(a) _fabs(a)
 #define sqrt_f3(a) _sqrtf(a)
 #define exp_f3(a) _expf((a))
 #define sign_f(a) sign(a)
 #define refract_f3(I,N,eta) refract(I,N,eta)

#else

  #if defined(USE_NATIVE_OPENCL_IMPL)

    #define reflect(I,N) (I-2.0f*dot(N,I)*N)

    #define fract(a) ((a)-_floor(a))  // oder Pointer bauen: gentype fract(gentype x, gentype *itpr)

 #define fract_f2(A) to_float2(fract((A).x),fract((A).y))
 #define mod_f(a,b) _fmod(a,b)
 #define tanh_f3(i) tanh(i)
 #define abs_f2(a) fabs(a)
 #define sqrt_f3(a) _sqrtf(a)
 #define exp_f3(a) _expf((a))
 #define sign_f(a) sign(a)

__DEVICE__ float3 refract_f3(float3 I, float3 N, float eta) {
   float dotNI = dot(N, I);
   float k = 1.0f - eta * eta * (1.0f - dotNI * dotNI);
   if (k < 0.0f) {
      return to_float3_s(0.0f);
   }
   return eta * I - (eta * dotNI * _sqrtf(k)) * N; //+0.5f;   * -01.50f;(MarchingCubes)  - 0.15f; (GlassDuck)
 }

 #else // Generic

 #if defined(DEVICE_IS_OPENCL)
   __DEVICE__ float3 reflect(float3 I, float3 N) {return I - 2.0f * dot(N, I) * N;}
 #endif

    #define fract(a) ((a)-_floor(a))

 #define fract_f2(A) to_float2(fract((A).x),fract((A).y))
 #define mod_f(a,b) ((a)-(b)*_floor((a)/(b)))
 #define tanh_f3(i) to_float3(_tanhf((i).x), _tanhf((i).y), _tanhf((i).z))
 #define abs_f2(a) to_float2(_fabs((a).x), _fabs((a).y))
 #define sqrt_f3(a) to_float3(_sqrtf((a).x),_sqrtf((a).y),_sqrtf((a).z))
 #define exp_f3(a) to_float3(_expf((a).x), _expf((a).y),_expf((a).z))
 #define sign_f(a) (a==0.0f?0.0f:a>0.0f?1.0f:-1.0f)

 __DEVICE__ float3 refract_f3(float3 I, float3 N, float eta) {
    float dotNI = dot(N, I);
    float k = 1.0f - eta * eta * (1.0f - dotNI * dotNI);
    if (k < 0.0f) {
      return to_float3_s(0.0f);
    }
    return eta * I - (eta * dotNI * _sqrtf(k)) * N; //+0.5f;   * -01.50f;(MarchingCubes)  - 0.15f; (GlassDuck)
 }

  #endif

#endif


]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel implementation
-- // ------------------------------------------------------------------------

-- */
ShaderKernelCode =
[[

// ----------------------------------------------------------------------------------
// - Common                                                                         -
// ----------------------------------------------------------------------------------
#define texture(ch,uv) _tex2DVecN(ch, (uv).x, (uv).y, 15)

// ----------------------------------------------
// CC0: Phosphorescent Purple Pixel Peaks
// ----------------------------------------------
//  `----- - --- ---------?\___/?\/zS!?\___/?\/-o
//                mrange & virgill              |
//  `----- - --- ------ -----\___/?\/!?\___/?\/-o
//                                              |
//   release: Phosphorescent Purple Pixel Peaks |
//      type: Windows 4k intro                  |
//      date: 17.02.2024                        |
//     party: Mountainbytes 2024                |
//                                              |
//                                              |
//  code: mrange                                |
//  music: Virgill                              |
//                                              |
//                                              |
// mrange - So, in this release, I set out to   |
// whip up a terrain marcher in a snug 4KiB     |
// space. Started with your usual terrain,      |
// thinking, "Let's give it a synthwave twist." |
// Now, my previous attempts at a synthwave-    |
// style terrain marcher were kinda meh, but    |
// guess what? Lightning struck, and I managed  |
// to sculpt some visually pleasing mountains.  |
//                                              |
// They're not a perfect match for the synthwave|
// vibe, but hey, check out these transparent,  |
// glowing ice cream peaks. Cool, right?        |
//                                              |
// Big shoutout to Virgill for dropping another |
// killer tune that totally catches the vibe.   |
// Sadly, we had to ditch some funky sound      |
// effects this time around—blame it on the     |
// space crunch. Fingers crossed, next time,    |
// we'll pack in the funk.                      |
//                                              |
// Oh, and a quick nod to sointu by our main    |
// man Pestis. This nifty tool churns out tunes |
// that sound fantastic, and even a music novice|
// like me could tinker around with its         |
// user-friendly tracker.                       |
//                                              |
// We're banking on you having a blast with our |
// creation, hoping it dishes out that feel-good|
// synthwave goodness. Cheers!                  |
//                                              |
//                                         _  .:!
//  <----- ----- -  -   -     - ----- ----\/----'

#define TIME        iTime
#define RESOLUTION  iResolution

#define  pi _acosf(-1.0f)

const float3 Units = {0, 1, 1E-2f};

__DEVICE__ mat2 rot(float a) {
  float c=_cosf(a),s=_sinf(a);
  return to_mat2(c,s,-s,c);
}

// License: Unknown, author: Unknown, found: don't remember
__DEVICE__ float hash2(float2 co) {
  return fract(_sinf(dot(swi2(co,x,y) ,to_float2(12.9898f,58.233f))) * 13758.5453f);
}

// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/lsf3WH
//  Value noise function
__DEVICE__ float vnoise(float2 p) {
 float2 i = _floor(p);
 float2 f = fract_f2(p);

 float2 u = f*f*(3.0f-2.0f*f);

 float a = hash2(i);
 float b = hash2(i+swi2(Units,y,x));
 float c = hash2(i+swi2(Units,x,y));
 float d = hash2(i+swi2(Units,y,y));

 float m0 = _mix(a, b, u.x);
 float m1 = _mix(c, d, u.x);
 float m2 = _mix(m0, m1, u.y);

 return m2;
}


// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/fbm/
//  Scales and rotates and aggregates multiple layers of value noise
//  to create something that looks like mountains
__DEVICE__ float3 fbm(float2 p, int ii) {
  float2 np = p;
  float2 cp = p;
  float nh = 0.0f;
  float na = 1.0f;
  float ns = 0.0f;
  for (int i = 0; i < ii; ++i) {
    nh += na*vnoise(np);
    np += 123.4f;
    np = mul_f2_mat2(np*2.11f , rot(1.0f));
    ns += na;
    na *= 0.5f;
  }

  nh /= ns;

  return to_float3_s(nh);
}


// ----------------------------------------------------------------------------------
// - Buffer A                                                                       -
// ----------------------------------------------------------------------------------


// ----------------------------------------------
// CC0: Phosphorescent Purple Pixel Peaks
// ----------------------------------------------
//  `----- - --- ---------?\___/?\/zS!?\___/?\/-o
//                mrange & virgill              |
//  `----- - --- ------ -----\___/?\/!?\___/?\/-o
//                                              |
//   release: Phosphorescent Purple Pixel Peaks |
//      type: Windows 4k intro                  |
//      date: 17.02.2024                        |
//     party: Mountainbytes 2024                |
//                                              |
//                                              |
//  code: mrange                                |
//  music: Virgill                              |
//                                              |
//                                              |
// mrange - So, in this release, I set out to   |
// whip up a terrain marcher in a snug 4KiB     |
// space. Started with your usual terrain,      |
// thinking, "Let's give it a synthwave twist." |
// Now, my previous attempts at a synthwave-    |
// style terrain marcher were kinda meh, but    |
// guess what? Lightning struck, and I managed  |
// to sculpt some visually pleasing mountains.  |
//                                              |
// They're not a perfect match for the synthwave|
// vibe, but hey, check out these transparent,  |
// glowing ice cream peaks. Cool, right?        |
//                                              |
// Big shoutout to Virgill for dropping another |
// killer tune that totally catches the vibe.   |
// Sadly, we had to ditch some funky sound      |
// effects this time around—blame it on the     |
// space crunch. Fingers crossed, next time,    |
// we'll pack in the funk.                      |
//                                              |
// Oh, and a quick nod to sointu by our main    |
// man Pestis. This nifty tool churns out tunes |
// that sound fantastic, and even a music novice|
// like me could tinker around with its         |
// user-friendly tracker.                       |
//                                              |
// We're banking on you having a blast with our |
// creation, hoping it dishes out that feel-good|
// synthwave goodness. Cheers!                  |
//                                              |
//                                         _  .:!
//  <----- ----- -  -   -     - ----- ----\/----'


__KERNEL__ void MountainbytesPppp4KibWindowsFuse__Buffer_A(__CONSTANTREF__ Params*  params, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);

  bool   noFlash = params->noFlash;
  float4 SunCol0 = to_float4(params->SunCol0[0], params->SunCol0[1], params->SunCol0[2], params->SunCol0[3]);
  float4 SunCol1 = to_float4(params->SunCol1[0], params->SunCol1[1], params->SunCol1[2], params->SunCol1[3]);
  float4 GridCol0 = to_float4(params->GridCol0[0], params->GridCol0[1], params->GridCol0[2], params->GridCol0[3]);
  float4 GridCol1 = to_float4(params->GridCol1[0], params->GridCol1[1], params->GridCol1[2], params->GridCol1[3]);
  float4 RoadGlow = to_float4(params->RoadGlow[0], params->RoadGlow[1], params->RoadGlow[2], params->RoadGlow[3]);
  float4 BikeFlash = to_float4(params->BikeFlash[0], params->BikeFlash[1], params->BikeFlash[2], params->BikeFlash[3]);
  float4 AbsorbCol = to_float4(params->AbsorbCol[0], params->AbsorbCol[1], params->AbsorbCol[2], params->AbsorbCol[3]);
  float4 SunDir = to_float4(params->SunDir[0], params->SunDir[1], params->SunDir[2], params->SunDir[3]);
  float  path_a = params->path_a;
  float  path_b = params->path_b;
  float  minh = params->minh;
  float  maxh = params->maxh;
  float  wl = params->wl;
  float  innerAdj = params->innerAdj;
  float  ch = params->ch;
  float  ibpm = params->ibpm;
  float  Per = params->Per;
  float  stp = params->stp;
  float  Lp = params->Lp;
  float  FoF = params->FoF;
  float  rnd = params->rnd;
  float  period = params->period;
  float  AbsorbFkt = params->AbsorbFkt;
  float  SkyColFkt = params->SkyColFkt;
  float  InnerGlowFkt = params->InnerGlowFkt;
  float  tilt = params->tilt;
  float  zoom = params->zoom;

  // --------

  fragCoord+=0.5f;

  float2 q = fragCoord/swi2(RESOLUTION,x,y);
  float2 p = -1.0f + 2.0f * q;
  p.x *= RESOLUTION.x/RESOLUTION.y;

  // High resolution FBM
  //  Used for normal computation and raymarching of the detailed mountain
  float3 col = fbm(p, 6);

  fragColor = to_float4_aw(col, 1.0f);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
// ----------------------------------------------------------------------------------
// - Buffer B                                                                       -
// ----------------------------------------------------------------------------------


// ----------------------------------------------
// CC0: Phosphorescent Purple Pixel Peaks
// ----------------------------------------------
//  `----- - --- ---------?\___/?\/zS!?\___/?\/-o
//                mrange & virgill              |
//  `----- - --- ------ -----\___/?\/!?\___/?\/-o
//                                              |
//   release: Phosphorescent Purple Pixel Peaks |
//      type: Windows 4k intro                  |
//      date: 17.02.2024                        |
//     party: Mountainbytes 2024                |
//                                              |
//                                              |
//  code: mrange                                |
//  music: Virgill                              |
//                                              |
//                                              |
// mrange - So, in this release, I set out to   |
// whip up a terrain marcher in a snug 4KiB     |
// space. Started with your usual terrain,      |
// thinking, "Let's give it a synthwave twist." |
// Now, my previous attempts at a synthwave-    |
// style terrain marcher were kinda meh, but    |
// guess what? Lightning struck, and I managed  |
// to sculpt some visually pleasing mountains.  |
//                                              |
// They're not a perfect match for the synthwave|
// vibe, but hey, check out these transparent,  |
// glowing ice cream peaks. Cool, right?        |
//                                              |
// Big shoutout to Virgill for dropping another |
// killer tune that totally catches the vibe.   |
// Sadly, we had to ditch some funky sound      |
// effects this time around—blame it on the     |
// space crunch. Fingers crossed, next time,    |
// we'll pack in the funk.                      |
//                                              |
// Oh, and a quick nod to sointu by our main    |
// man Pestis. This nifty tool churns out tunes |
// that sound fantastic, and even a music novice|
// like me could tinker around with its         |
// user-friendly tracker.                       |
//                                              |
// We're banking on you having a blast with our |
// creation, hoping it dishes out that feel-good|
// synthwave goodness. Cheers!                  |
//                                              |
//                                         _  .:!
//  <----- ----- -  -   -     - ----- ----\/----'

__KERNEL__ void MountainbytesPppp4KibWindowsFuse__Buffer_B(__CONSTANTREF__ Params*  params, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);

  bool   noFlash = params->noFlash;
  float4 SunCol0 = to_float4(params->SunCol0[0], params->SunCol0[1], params->SunCol0[2], params->SunCol0[3]);
  float4 SunCol1 = to_float4(params->SunCol1[0], params->SunCol1[1], params->SunCol1[2], params->SunCol1[3]);
  float4 GridCol0 = to_float4(params->GridCol0[0], params->GridCol0[1], params->GridCol0[2], params->GridCol0[3]);
  float4 GridCol1 = to_float4(params->GridCol1[0], params->GridCol1[1], params->GridCol1[2], params->GridCol1[3]);
  float4 RoadGlow = to_float4(params->RoadGlow[0], params->RoadGlow[1], params->RoadGlow[2], params->RoadGlow[3]);
  float4 BikeFlash = to_float4(params->BikeFlash[0], params->BikeFlash[1], params->BikeFlash[2], params->BikeFlash[3]);
  float4 AbsorbCol = to_float4(params->AbsorbCol[0], params->AbsorbCol[1], params->AbsorbCol[2], params->AbsorbCol[3]);
  float4 SunDir = to_float4(params->SunDir[0], params->SunDir[1], params->SunDir[2], params->SunDir[3]);
  float  path_a = params->path_a;
  float  path_b = params->path_b;
  float  minh = params->minh;
  float  maxh = params->maxh;
  float  wl = params->wl;
  float  innerAdj = params->innerAdj;
  float  ch = params->ch;
  float  ibpm = params->ibpm;
  float  Per = params->Per;
  float  stp = params->stp;
  float  Lp = params->Lp;
  float  FoF = params->FoF;
  float  rnd = params->rnd;
  float  period = params->period;
  float  AbsorbFkt = params->AbsorbFkt;
  float  SkyColFkt = params->SkyColFkt;
  float  InnerGlowFkt = params->InnerGlowFkt;
  float  tilt = params->tilt;
  float  zoom = params->zoom;

  // --------

  fragCoord+=0.5f;

  float2 q = fragCoord/swi2(RESOLUTION,x,y);
  float2 p = -1.0f + 2.0f * q;
  p.x *= RESOLUTION.x/RESOLUTION.y;

  // Low resolution FBM
  //  Used for snow normal computation and inner glowing mountains
  float3 col = fbm(p, 4);

  fragColor = to_float4_aw(col, 1.0f);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
// ----------------------------------------------------------------------------------
// - Image                                                                          -
// ----------------------------------------------------------------------------------
// Connect Image 'Previsualization: Buffer A' to iChannel0
// Connect Image 'Previsualization: Buffer B' to iChannel1
// Connect Image 'Texture: Audio' to iChannel2


// ----------------------------------------------
// CC0: Phosphorescent Purple Pixel Peaks
// ----------------------------------------------
//  `----- - --- ---------?\___/?\/zS!?\___/?\/-o
//                mrange & virgill              |
//  `----- - --- ------ -----\___/?\/!?\___/?\/-o
//                                              |
//   release: Phosphorescent Purple Pixel Peaks |
//      type: Windows 4k intro                  |
//      date: 17.02.2024                        |
//     party: Mountainbytes 2024                |
//                                              |
//                                              |
//  code: mrange                                |
//  music: Virgill                              |
//                                              |
//                                              |
// mrange - So, in this release, I set out to   |
// whip up a terrain marcher in a snug 4KiB     |
// space. Started with your usual terrain,      |
// thinking, "Let's give it a synthwave twist." |
// Now, my previous attempts at a synthwave-    |
// style terrain marcher were kinda meh, but    |
// guess what? Lightning struck, and I managed  |
// to sculpt some visually pleasing mountains.  |
//                                              |
// They're not a perfect match for the synthwave|
// vibe, but hey, check out these transparent,  |
// glowing ice cream peaks. Cool, right?        |
//                                              |
// Big shoutout to Virgill for dropping another |
// killer tune that totally catches the vibe.   |
// Sadly, we had to ditch some funky sound      |
// effects this time around—blame it on the     |
// space crunch. Fingers crossed, next time,    |
// we'll pack in the funk.                      |
//                                              |
// Oh, and a quick nod to sointu by our main    |
// man Pestis. This nifty tool churns out tunes |
// that sound fantastic, and even a music novice|
// like me could tinker around with its         |
// user-friendly tracker.                       |
//                                              |
// We're banking on you having a blast with our |
// creation, hoping it dishes out that feel-good|
// synthwave goodness. Cheers!                  |
//                                              |
//                                         _  .:!
//  <----- ----- -  -   -     - ----- ----\/----'

// Some commented they don't enjoy the flashes
//  This is fair and it's not very synthwave-y
//  So I included this option to drop them
// #define IDONTLIKETHEFLASHING

#define hifbm iChannel0
#define lofbm iChannel1


#define tau        2.0f*pi
#define max_dist   14.0f
#define near_dist  10.0f
#define tolerance  1E-3f
#define eps1       1E-1f


const int lo_max_iter = 10, hi_max_iter = 90;


__DEVICE__ float2 segment(float2 p) {
  float d0 = length(p);
  return to_float2(p.y>0.0f?d0:_fabs(p.x), d0);
}

// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm
__DEVICE__ float raySphere(float3 ro, float3 rd, float4 sph) {

  float3 oc = ro - swi3(sph,x,y,z);
  float b = dot(oc, rd);
  float c = dot(oc, oc) - sph.w*sph.w;
  float h = b*b - c;
  return h>0.0f ? -b - _sqrtf(h) :  -1.0f;
}

// Camera path
__DEVICE__ float3 cam_path(float z, float path_a, float path_b, float lp) {
  return to_float3(_sinf(z*path_a)*path_b, 1.0f-0.4f*_cosf(z*lp), -z);
}

// Derivate of Camera path, used to determine which direction camera points in
__DEVICE__ float3 dcam_path(float z, float path_a, float path_b, float lp) {
  return (cam_path(z+eps1, path_a, path_b, lp) - cam_path(z-eps1, path_a, path_b, lp))/(2.0f*eps1);
}

// Derivate of Derivate of Camera path, used to determine camera tilt
__DEVICE__ float3 ddcam_path(float z, float path_a, float path_b, float lp) {
  return (dcam_path(z+eps1, path_a, path_b, lp) - dcam_path(z-eps1, path_a, path_b, lp))/(2.0f*eps1);
}

// License: Unknown, author: Unknown, found: don't remember
__DEVICE__ float hash1(float co) {
  return fract(_sinf(co*12.9898f) * 13758.5453f);
}

// Diffuse lighting
__DEVICE__ float dif(float3 n, float3 ld) {
  return _fmaxf(dot(n, ld),0.0f);
}

// Fake fresnel effect (more reflective at "edges")
__DEVICE__ float fre(float3 rd, float3 n, float pwr) {
  return _powf(1.0f+dot(rd,n), pwr);
}

// License: MIT OR CC-BY-NC-4.0f, author: mercury, found: https://mercury.sexy/hg_sdf/
__DEVICE__ float mod1(inout float *p, float size) {
  float halfsize = 0.5f*size;
  float c = _floor((*p + halfsize)/size);
  *p = mod_f(*p + halfsize, size) - halfsize;
  return c;
}


// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
//  Soft max function, used in the sun for example to round the edges
__DEVICE__ float pmax(float a, float b, float k) {
  float h = clamp(0.5f+0.5f*(a-b)/k, 0.0f, 1.0f);
  return _mix(b, a, h) + k*h*(1.0f-h);
}

// Height function for mountains
__DEVICE__ float hf(__TEXTURE2D__ sampler, float2 p, float path_a, float path_b, float lp, float minh, float maxh, float wl, float g_part) {
  float3 cam = cam_path(p.y, path_a, path_b, lp);
  float f = _fabs(cam.x+p.x);
  // Global height function
  float g = _mix(minh, maxh*(0.5f-0.5f*_cosf(lp*p.y)), smoothstep(0.3f, 2.0f-0.5f*_sinf(lp*p.y), f));
  p *= 0.125f;
  p += 0.5f;
  float2 n = fract_f2(0.5f*_floor(p));
  p = fract_f2(p);
  p.x = n.x == 0.0f ? p.x : 1.0f-p.x;
  p.y = n.y == 0.0f ? p.y : 1.0f-p.y;
  // Combine global height function and mountain FBM
  int RowSampler = 15; // Total irre !!! Tausend Shader, die liefen ohne diese Zeile mit OpenCL. Dieser Shader braucht aber genau dies nur für OpenCL -> Total irre !!!
  return _mix(wl-1E-2f, g*_tex2DVecN(sampler,p.x,p.y,15).x, g_part > 1.0f ? smoothstep(0.06f, 0.12f, f) : 1.0f);
}

// Raymarches against height function
__DEVICE__ float rayMarch(__TEXTURE2D__ sampler, float3 ro, float3 rd, int maxi, float initt, float yadj, float sgn, float wlt,
                          float path_a, float path_b, float lp, float minh, float maxh, float wl, float g_part) {
  float t = initt;
  float stp = 0.9f;
  float lastt;

  int i;

  for (i = 0; i < maxi; ++i) {
    if (t > max_dist) {
      break;
    }
    float3 p = ro+rd*t;
    if (p.y < wl) {
      return wlt;
    }

    float h = hf(sampler, swi2(p,x,z), path_a, path_b, lp, minh, maxh, wl, g_part)-yadj;
    float d = sgn*(p.y - h);

    if (d < tolerance) {
      // If we have an intercept we just step back a bit and tries again
      //  To reduce the potentiel overshoots
      if (stp >= 0.125f) {
        stp *= 0.5f;
        t = lastt;
      } else {
        break;
      }
    }
    lastt = t;

    t += _fmaxf(stp*d, tolerance);
  }

  return t;
}

__DEVICE__ float3 normal(__TEXTURE2D__ sampler, float2 p, float path_a, float path_b, float lp, float minh, float maxh, float wl, float g_part) {
   return normalize(to_float3(
      hf(sampler, p - swi2(Units,z,x), path_a, path_b, lp, minh, maxh, wl, g_part) - hf(sampler, p + swi2(Units,z,x), path_a, path_b, lp, minh, maxh, wl, g_part)
    , 2.0f*Units.z
    , hf(sampler, p - swi2(Units,x,z), path_a, path_b, lp, minh, maxh, wl, g_part) - hf(sampler, p + swi2(Units,x,z), path_a, path_b, lp, minh, maxh, wl, g_part)
   ));
}

__DEVICE__ float lorayMarch(__TEXTURE2D__ lofbm, float3 ro, float3 rd, float initt, float yadj, float sgn, float wlt, float path_a, float path_b, float lp, float minh, float maxh, float wl, float g_part) {
  return rayMarch(lofbm, ro, rd, lo_max_iter, initt, yadj, sgn, wlt, path_a, path_b, lp, minh, maxh, wl, g_part);
}

__DEVICE__ float3 lonormal(__TEXTURE2D__ lofbm,float2 p, float path_a, float path_b, float lp, float minh, float maxh, float wl, float g_part) {
  return normal(lofbm, p, path_a, path_b, lp, minh, maxh, wl, g_part);
}

__DEVICE__ float hirayMarch(__TEXTURE2D__ hifbm,float3 ro, float3 rd, float initt, float wlt, float path_a, float path_b, float lp, float minh, float maxh, float wl, float g_part) {
  return rayMarch(hifbm, ro, rd, hi_max_iter, initt, 0.0f, 1.0f, wlt, path_a, path_b, lp, minh, maxh, wl, g_part);
}

__DEVICE__ float3 hinormal(__TEXTURE2D__ hifbm,float2 p, float path_a, float path_b, float lp, float minh, float maxh, float wl, float g_part) {
  return normal(hifbm, p, path_a, path_b, lp, minh, maxh, wl, g_part);
}

__DEVICE__ float sun(float2 p, float ch) {
  p.y += -0.2f;
  float d0 = length(p) - 0.5f;
  float d2 = p.y;
  
  float tmp = p.y;
  //mod1(&(p.y), ch*6.0f);
  mod1(&tmp, ch*6.0f);
  p.y = tmp;
  
  float d1 = _fabs(p.y) -  ch;
  return pmax(d0, -_fmaxf(d1, d2), ch);
}

// The sky
__DEVICE__ float3 skyRender(float3 ro, float3 rd, float ch, float3 sunCol0, float3 sunCol1, float3 skyCol, float3 sunDir, float rnd, float g_part, float g_beat, float g_time) {
  float2 sp   = swi2(rd,x,y)*2.0f;
  float ds = sun(sp,ch);

  float3 bscol = _mix(sunCol0, sunCol1, clamp(1.4f*sp.y, 0.0f, 1.0f));
  bscol *= sqrt_f3(bscol*2.0f);

  // The Sun
  float3 col = 1E-2f/_fmaxf(_fabs(ds), 1E-2f)*bscol;
  col += bscol*smoothstep(3E-3f, 0.0f, ds);

  float gd = rd.y+5E-3f;

  float t = 1.0f;
  if (g_part > 2.0f) {
      // The City
      col += 1E-3f/_fmaxf(_fabs(sp.x*(sp.y*sp.y+1.0f)), 2E-3f)*(0.5f+2.0f*g_beat)*sunCol1;
      for (float i = 0.0f; i < 4.0f; ++i) {
        float2 cp = sp;
        cp *= 1.0f+0.1f*i;
        float tmp = cp.x;
        //float cn = mod1(&(cp.x), 0.015f);
        float cn = mod1(&tmp, 0.015f);
        cp.x = tmp;
        float ch = hash1(cn+rnd*i)*smoothstep(32.0f, 4.0f, _fabs(cn));
        t = _fminf(t, _mix((i+1.0f)*0.125f, 1.0f, step(0.2f*ch, cp.y)));
      }
    col *= t;
  }

  const float4 planet = to_float4(1.25f,0.5f,-1,0.45f)*1E5f;

  float si = raySphere(ro, rd, planet);

  float3 spos = ro+rd*si,
           sn = normalize(spos-swi3(planet,x,y,z)+swi3(Units,x,y,x)*5E3f*_sinf(1E3f*spos.y/1E5f)),
           sr = reflect(rd, sn);

  if (si > 0.0f) {
    // The Planet
    float sdif = dif(sn, sunDir),
          sspe = 4.0f*_powf(dif(sr, sunDir), 80.0f)*fre(rd, sn, 4.0f);
    col = sunCol0*sdif+sunCol1*sspe;
  }

  float at = g_time-48.0f;
  if (at > 0.0f) {
    // The Rocket
    float2 rp = swi2(rd,x,y)-to_float2(-0.4f-0.2f*rd.y*rd.y, 5E-3f*(at*at-1.0f));
    float2 dr = segment(rp);
    float rfo = smoothstep(0.4f, 0.0f, dr.y);
    col += 1E-3f*(sunCol0)/_fmaxf(_fabs(dr.x), 2E-4f*(2.0f-rfo))*rfo;
    col += 3E-3f*sunCol1/_fabs(dr.y)*hash1(_floor(g_time*20.0f));
  }

  col *= step(0.0f, gd);
  // The horizon
  col += 1E-2f/_fmaxf(_sqrtf(_fabs(gd))*(75E-2f*rd.x*rd.x+75E-4f), 5E-4f*(1.0f+30.0f*rd.x*rd.x))*(1.0f+0.5f*g_beat)*skyCol;

  return col;
}

// The ground
__DEVICE__ float3 groundRender(float3 rd, float3 pp, float pt, float path_a, float path_b, float lp, float3 upDir, float3 gridCol0, float3 gridCol1, float3 roadGlow, float3 bikeFlash, float g_part, float g_time) {

  float gfre  = fre(rd, upDir, 1.0f), rp    = pp.x;
  rp += cam_path(pp.z, path_a, path_b, lp).x;

  // The grid
  float2 ggp    = swi2(pp,x,z);
  float gcf   = 0.5f+0.5f*(_sinf(ggp.x)*_sinf(ggp.y));
  ggp         *= 3.0f;
  ggp         -= round(ggp);
  ggp         = abs_f2(ggp);
  float ggd   = _fminf(ggp.x, ggp.y) ;

  float3 gcol = _mix(gridCol0, gridCol1, gcf);
  gcol *= sqrt_f3(gcol)*1E-2f;

  float fo = _expf(-0.5f*_fmaxf(pt-2.0f, 0.0f));
  float sm = 0.025f*smoothstep(0.6f, 1.0f, gfre)+1E-3f;
  float bp = _fabs(rp)-5E-2f;
  float cp = _fabs(rp)-25E-3f;
  float cs = sign_f(rp);

  float3 pcol = gcol/_fmaxf(ggd, sm);
  sm *= 1E-4f;
  if (g_part > 1.0f) {
    // The road
    pcol *= step(0.0f, bp);
    pcol += roadGlow/_fmaxf((rp*rp), sm)*smoothstep(0.25f, 0.5f, _sinf(20.0f*pp.z));
    pcol += 0.25f/_fmaxf(bp*bp, sm)*roadGlow;
  }

  float off = pp.z+g_time*3.0f;
  float noff = mod1(&off, 10.0f);
  float hoff = hash1(noff);
  float ht = hash1(_floor(g_time*10.0f));
  off += 3.0f*cs*(hoff-0.5f);

  float2 cp2 = to_float2(cp,off);
  if (g_part > 2.0f) {
    // The motorbikes
    pcol += step(0.0f, off)/_fmaxf(cp*cp, sm)*smoothstep(2.0f, 0.0f, off)*(cs > 0.0f ? swi3(roadGlow,x,z,y) : swi3(roadGlow,z,y,x))*0.25f;
    pcol += ht*ht/_fmaxf(dot(cp2, cp2), sm)*bikeFlash;
  }
  pcol *= fo;
  return pcol;
}

__DEVICE__ float3 sceneRender(float3 ro, float3 rd, float ch, float3 sunCol0, float3 sunCol1, float3 skyCol, float3 sunDir, float rnd, float g_part, float g_beat, float g_time,
                              float path_a, float path_b, float lp, float minh, float maxh, float wl, float fof,
                              float3 upDir, float3 gridCol0, float3 gridCol1, float3 roadGlow, float3 bikeFlash, float innerAdj, float3 innerGlow, float3 absorbCol, __TEXTURE2D__ lofbm, __TEXTURE2D__ hifbm) {
  float3 sky = skyRender(ro, rd, ch, sunCol0, sunCol1, skyCol, sunDir, rnd, g_part, g_beat, g_time);

  float pt = -(ro.y-wl)/rd.y;
  // Intersect the mountains
  float gt = hirayMarch(hifbm,ro, rd, 1E-2f, pt, path_a, path_b, lp, minh, maxh, wl, g_part);

  float3 col = to_float3_s(0);

  float ft = _fmaxf(gt-near_dist, 0.0f)/(max_dist-near_dist);
  float fm = _expf(-ft*fof);

  float3 gp = ro+rd*gt;
  float3 gn = hinormal(hifbm, swi2(gp,x,z), path_a, path_b, lp, minh, maxh, wl, g_part);
  float3 sn = lonormal(lofbm, swi2(gp,x,z), path_a, path_b, lp, minh, maxh, wl, g_part);
  float sdif = dif(sn, sunDir);
  if (pt > 0.0f && pt <= gt) {
    // Hit the ground
    float3 pp = ro+pt*rd;
    float3 pr = reflect(rd, upDir);
    float pfre = fre(rd, upDir, 2.0f);
    // To find the reflection
    float pgt = hirayMarch(hifbm, pp, pr, 5E-2f, max_dist, path_a, path_b, lp, minh, maxh, wl, g_part);

    if (pgt < max_dist) {
      pfre *= 0.125f*smoothstep(2.0f, 4.0f, pgt);
    }

    // The ground
    col = groundRender(rd, pp, pt, path_a, path_b, lp, upDir, gridCol0, gridCol1, roadGlow, bikeFlash, g_part, g_time);
    // The reflection
    col += skyRender(pp, pr, ch, sunCol0, sunCol1, skyCol, sunDir, rnd, g_part, g_beat, g_time)*pfre;
  } else if (gt < max_dist) {
    // The mountains
    float3 gr = reflect(rd, gn);
    float3 grr = refract_f3(rd, gn, 1.0f-0.025f);
    float3 sr = reflect(rd, sn);

    // Ray march the inner mountains
    float nlt = lorayMarch(lofbm, gp, grr, eps1, innerAdj, 1.0f, max_dist, path_a, path_b, lp, minh, maxh, wl, g_part);
    float rpt = -(gp.y-wl)/grr.y;

    // Compute inner grid
    float3 rpp = gp+grr*rpt;
    float3 groundCol = groundRender(grr, rpp, rpt+gt, path_a, path_b, lp, upDir, gridCol0, gridCol1, roadGlow, bikeFlash, g_part, g_time);
    float3 nlp = gp+grr*nlt;

    float gfre = fre(rd, gn, 8.0f);
    float sfre = fre(rd, sn, 2.0f);

    float sspe = _powf(dif(sr, sunDir), 40.0f);
    float gspe = _powf(dif(gr, sunDir), 100.0f);
    if (gp.y > _mix(0.2f, 0.5f, 0.5f+0.5f*_sinf(gp.z+1.23f*gp.x))+0.6f/_fmaxf(_sqrtf(gn.y), 0.1f)) {
      // The snow
      col += sfre*sspe;
      col += sfre*gspe;
      col += sdif*sqrt_f3(sunCol1);
      col += -0.125f*_fabs(sn.x*sn.y);
      col += sqrt_f3(skyCol)/sn.y;
    } else {
      if (rpt > 0.0f) {
        // The inner grid
        col += 0.5f*exp_f3(rpt*absorbCol)*groundCol;
      }

      if (nlt < max_dist) {
        // Raymarch through the inner mountain
        float flt = lorayMarch(lofbm, nlp, grr, 5E-2f, innerAdj, -1.0f, max_dist, path_a, path_b, lp, minh, maxh, wl, g_part);
        if (flt >= max_dist) {
          flt = rpt-nlt;
        }

        // The inner glow
        col = _mix(col, innerGlow*exp_f3((1.5f-0.5f*g_beat)*nlt*absorbCol), _expf(0.25f*flt)-1.0f);
      }
      col += gfre*0.5f*skyRender(gp, gr, ch, sunCol0, sunCol1, skyCol, sunDir, rnd, g_part, g_beat, g_time);
    }
  } else {
    // Sky
    col = sky;
  }

  // Apply glow
  col = _mix(sky, col, fm);

  return col;
}

__DEVICE__ float3 effect(float2 p, float period, inout float *g_time, inout float *g_part, inout float *g_beat, float ibpm, float per, float stp,
                         float ch, float3 sunCol0, float3 sunCol1, float3 skyCol, float3 sunDir, float rnd,
                         float path_a, float path_b, float lp, float minh, float maxh, float wl, float fof,
                         float3 upDir, float3 gridCol0, float3 gridCol1, float3 roadGlow, float3 bikeFlash, float innerAdj, float3 innerGlow, float3 absorbCol,
                         float tilt, float zoom, bool noFlash, float4 iMouse, float iTime, float2 iResolution, __TEXTURE2D__ lofbm, __TEXTURE2D__ hifbm) {
  *g_time = mod_f(TIME, period);
  float lt = *g_time + 0.25f*ibpm;
  float ct = mod_f(lt, per);
  float nt = _floor(lt/per);
  *g_part   = nt;
  // Beats that control mountain and city flashes
  *g_beat   = _expf(-2.0f*mod_f(ct+ibpm, 2.0f*ibpm))*mod_f(nt, 2.0f);

  float pt  = ct+stp*nt;
  float3 ro   = cam_path(pt, path_a, path_b, lp);
  float3 dro  = dcam_path(pt, path_a, path_b, lp);
  float3 ddro = ddcam_path(pt, path_a, path_b, lp);
  //swi2S(dro,y,x, mul_f2_mat2(swi2(dro,y,x) , rot(tilt)));

  swi2S(dro,y,z, mul_f2_mat2(swi2(dro,y,z) , rot(iMouse.y/iResolution.y -0.5f)));
  swi2S(dro,x,z, mul_f2_mat2(swi2(dro,x,z) , rot(iMouse.x/iResolution.x -0.5f)));

  float3 ww = normalize(dro);
  float3 uu = normalize(cross(upDir+(2.0f+tilt)*ddro, ww));
  float3 vv = cross(ww, uu);
  float3 rd = normalize(p.x*uu + p.y*vv + (2.0f+zoom)*ww);

  float3 col = sceneRender(ro, rd, ch, sunCol0, sunCol1, skyCol, sunDir, rnd, *g_part, *g_beat, *g_time,
                           path_a, path_b, lp, minh, maxh, wl, fof,
                           upDir, gridCol0, gridCol1, roadGlow, bikeFlash, innerAdj, innerGlow, absorbCol, lofbm, hifbm);
  // Go black if beyond last part
  col *= *g_part < 4.0f ? 1.0f : 0.0f;
  float sf = 4.0f*dot(sunDir, rd);

  if(noFlash)
  {
    col *= 1.0f-_expf(-4.0f*ct);
    float ft = ct - 31.75f*ibpm;
    if (ft > 0.0f)
      col *= _expf(-16.0f*ft);
  }
  else
  {
    col += sf*_expf(-6.0f*ct)*sunCol1;
    float ft = ct - 31.75f*ibpm;
    if (ft > 0.0f)
      col += sf*_expf(-16.0f*ft)*sunCol1;
  }

  col = tanh_f3(col)-3E-2f*(length(p)+0.125f);
  // Fade in
  col *= smoothstep(0.0f, 0.25f*per, *g_time-4.0f+sf);
  col *= 1.25f;
  col = sqrt_f3(col);
  return col;
}

__KERNEL__ void MountainbytesPppp4KibWindowsFuse(__CONSTANTREF__ Params*  params,  __TEXTURE2D__ iChannel0,  __TEXTURE2D__ iChannel1,  __TEXTURE2D__ iChannel2, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  bool   noFlash = params->noFlash;
  float4 SunCol0 = to_float4(params->SunCol0[0], params->SunCol0[1], params->SunCol0[2], params->SunCol0[3]);
  float4 SunCol1 = to_float4(params->SunCol1[0], params->SunCol1[1], params->SunCol1[2], params->SunCol1[3]);
  float4 GridCol0 = to_float4(params->GridCol0[0], params->GridCol0[1], params->GridCol0[2], params->GridCol0[3]);
  float4 GridCol1 = to_float4(params->GridCol1[0], params->GridCol1[1], params->GridCol1[2], params->GridCol1[3]);
  float4 RoadGlow = to_float4(params->RoadGlow[0], params->RoadGlow[1], params->RoadGlow[2], params->RoadGlow[3]);
  float4 BikeFlash = to_float4(params->BikeFlash[0], params->BikeFlash[1], params->BikeFlash[2], params->BikeFlash[3]);
  float4 AbsorbCol = to_float4(params->AbsorbCol[0], params->AbsorbCol[1], params->AbsorbCol[2], params->AbsorbCol[3]);
  float4 SunDir = to_float4(params->SunDir[0], params->SunDir[1], params->SunDir[2], params->SunDir[3]);
  float  path_a = params->path_a;
  float  path_b = params->path_b;
  float  minh = params->minh;
  float  maxh = params->maxh;
  float  wl = params->wl;
  float  innerAdj = params->innerAdj;
  float  ch = params->ch;
  float  ibpm = params->ibpm;
  float  Per = params->Per;
  float  stp = params->stp;
  float  Lp = params->Lp;
  float  FoF = params->FoF;
  float  rnd = params->rnd;
  float  period = params->period;
  float  AbsorbFkt = params->AbsorbFkt;
  float  SkyColFkt = params->SkyColFkt;
  float  InnerGlowFkt = params->InnerGlowFkt;
  float  tilt = params->tilt;
  float  zoom = params->zoom;

  // --------
#ifdef XXX
CONNECT_CHECKBOX0(noFlash, 0);

CONNECT_COLOR0(SunCol0  , 0.3f, 0.1f, 1.0f, 1.0f);
CONNECT_COLOR1(SunCol1  , 0.1f, 0.7f, 1.0f, 1.0f);
CONNECT_COLOR2(GridCol0 , 0.8f, 0.1f, 1.0f, 1.0f);
CONNECT_COLOR3(GridCol1 , 0.1f, 0.5f, 1.0f, 1.0f);
CONNECT_COLOR4(RoadGlow , 1.0f, 0.3f, 0.2f, 1.0f);
CONNECT_COLOR5(BikeFlash, 0.5f, 0.1f, 0.2f, 1.0f);
CONNECT_COLOR6(AbsorbCol, 0.5f, 2.0f, 1.0f, 1.0f);
CONNECT_COLOR7(SunDir   , 0.0f, 0.2f, -1.0f, 1.0f);

CONNECT_SLIDER0(path_a  , -1.0f, 1.0f, 0.2f);
CONNECT_SLIDER1(path_b  , -1.0f, 10.0f, 3.0f);
CONNECT_SLIDER2(minh    , -1.0f, 3.0f, 0.5f);
CONNECT_SLIDER3(maxh    , -1.0f, 10.0f, 2.5f);
CONNECT_SLIDER4(wl      , -1.0f, 1.0f, 0.3f);
CONNECT_SLIDER5(innerAdj, -1.0f, 1.0f, 0.25f);
CONNECT_SLIDER6(ch      , -1.0f, 1.0f, 0.0175f);
CONNECT_SLIDER7(ibpm    , -1.0f, 2.0f, 0.6667f);
CONNECT_SLIDER8(Per     , -1.0f, 128.0f, 32.0f);
CONNECT_SLIDER9(stp     , -1.0f, 100.0f, 66.0f);
CONNECT_SLIDER10(Lp    , -1.0f, 3.0f, 0.33f);
CONNECT_SLIDER11(FoF   , -1.0f, 100.0f, 20.0f);
CONNECT_SLIDER12(rnd   , -1.0f, 300.0f, 123.4f);
CONNECT_SLIDER13(period, -1.0f, 500.0f, 92.0f);
CONNECT_SLIDER14(AbsorbFkt, -10.0f, 10.0f, -4.0f);
CONNECT_SLIDER15(SkyColFkt, -1.0f, 10.0f, 3.0f);
CONNECT_SLIDER16(InnerGlowFkt, -1.0f, 20.0f, 8.0f);
CONNECT_SLIDER17(tilt, -20.0f, 20.0f, 0.0f);
CONNECT_SLIDER18(zoom, -20.0f, 20.0f, 0.0f);
#endif



float g_time;
float g_beat;
float g_part;

// path_a    = 0.2f
// path_b    = 3.0f
// minh      = 0.5f
// maxh      = 2.5f
// wl        = 0.3f
// innerAdj  = 0.25f
// ch        = 0.0175f
// ibpm      = 6.0f/9.0f
float per   = Per*ibpm,
//, stp       = 66.0f,
      lp        = Lp*tau/stp,
      fof       = _logf(FoF);
//rnd       = 123.4f,
//period    = 92.0f;


const float3
            sunCol0    = swi3(SunCol0,x,y,z),
            sunCol1    = swi3(SunCol1,x,y,z),
            gridCol0   = swi3(GridCol0,x,y,z),
            gridCol1   = swi3(GridCol1,x,y,z),
            roadGlow   = swi3(RoadGlow,x,y,z)*2E-5f,
            bikeFlash  = swi3(BikeFlash,x,y,z)*5E-4f,
            skyCol     = gridCol0/SkyColFkt,
            innerGlow  = sunCol1*InnerGlowFkt,
            absorbCol  = AbsorbFkt*swi3(AbsorbCol,x,y,z),
            sunDir     = normalize(swi3(SunDir,x,y,z)),
            upDir      = swi3(Units,x,y,x);



  float2 q = fragCoord/swi2(RESOLUTION,x,y);
  float2 p = -1.0f+2.0f*q;
  p.x *= RESOLUTION.x/RESOLUTION.y;

  float3 col = effect(p, period, &g_time, &g_part, &g_beat, ibpm, per, stp,
                         ch, sunCol0, sunCol1, skyCol, sunDir, rnd,
                         path_a, path_b, lp, minh, maxh, wl, fof,
                         upDir, gridCol0, gridCol1, roadGlow, bikeFlash, innerAdj, innerGlow, absorbCol,
                         tilt, zoom, noFlash, iMouse, iTime, iResolution, lofbm, hifbm);
  fragColor = to_float4_aw(col,1.0f);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
]]
-- /*



-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ShaderFuse.begin_create()

  ----- Inspector Panel Controls

  
  -- Speed Slider
  
  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",
  })
  
  -- iMouse Controls
  
  InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
  })
  
  InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
    INP_Disabled = true,
  })
  
  InMouseDrag = self:AddInput("Mouse Button Pressed", "iMouseClick", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = false,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0,
  })
  InnoFlashCheckbox = self:AddInput("noFlash", "noFlash", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })


self:BeginControlNest("Colors", "Colors", false, {})
  self:BeginControlNest("SunCol0", "SunCol0", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "SunCol0",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InSunCol0ColorR = self:AddInput("Red",   "SunCol0Red",   { INP_Default  = 0.3, IC_ControlID = 0, attrs})
    InSunCol0ColorG = self:AddInput("Green", "SunCol0Green", { INP_Default  = 0.1, IC_ControlID = 1, attrs})
    InSunCol0ColorB = self:AddInput("Blue",  "SunCol0Blue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InSunCol0ColorA = self:AddInput("Alpha", "SunCol0Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("SunCol1", "SunCol1", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "SunCol1",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InSunCol1ColorR = self:AddInput("Red",   "SunCol1Red",   { INP_Default  = 0.1, IC_ControlID = 0, attrs})
    InSunCol1ColorG = self:AddInput("Green", "SunCol1Green", { INP_Default  = 0.7, IC_ControlID = 1, attrs})
    InSunCol1ColorB = self:AddInput("Blue",  "SunCol1Blue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InSunCol1ColorA = self:AddInput("Alpha", "SunCol1Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("GridCol0", "GridCol0", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "GridCol0",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InGridCol0ColorR = self:AddInput("Red",   "GridCol0Red",   { INP_Default  = 0.8, IC_ControlID = 0, attrs})
    InGridCol0ColorG = self:AddInput("Green", "GridCol0Green", { INP_Default  = 0.1, IC_ControlID = 1, attrs})
    InGridCol0ColorB = self:AddInput("Blue",  "GridCol0Blue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InGridCol0ColorA = self:AddInput("Alpha", "GridCol0Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("GridCol1", "GridCol1", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "GridCol1",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InGridCol1ColorR = self:AddInput("Red",   "GridCol1Red",   { INP_Default  = 0.1, IC_ControlID = 0, attrs})
    InGridCol1ColorG = self:AddInput("Green", "GridCol1Green", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InGridCol1ColorB = self:AddInput("Blue",  "GridCol1Blue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InGridCol1ColorA = self:AddInput("Alpha", "GridCol1Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("RoadGlow", "RoadGlow", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "RoadGlow",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InRoadGlowColorR = self:AddInput("Red",   "RoadGlowRed",   { INP_Default  = 1.0, IC_ControlID = 0, attrs})
    InRoadGlowColorG = self:AddInput("Green", "RoadGlowGreen", { INP_Default  = 0.3, IC_ControlID = 1, attrs})
    InRoadGlowColorB = self:AddInput("Blue",  "RoadGlowBlue",  { INP_Default  = 0.2, IC_ControlID = 2, attrs})
    InRoadGlowColorA = self:AddInput("Alpha", "RoadGlowAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("BikeFlash", "BikeFlash", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "BikeFlash",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InBikeFlashColorR = self:AddInput("Red",   "BikeFlashRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InBikeFlashColorG = self:AddInput("Green", "BikeFlashGreen", { INP_Default  = 0.1, IC_ControlID = 1, attrs})
    InBikeFlashColorB = self:AddInput("Blue",  "BikeFlashBlue",  { INP_Default  = 0.2, IC_ControlID = 2, attrs})
    InBikeFlashColorA = self:AddInput("Alpha", "BikeFlashAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("AbsorbCol", "AbsorbCol", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "AbsorbCol",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InAbsorbColColorR = self:AddInput("Red",   "AbsorbColRed",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InAbsorbColColorG = self:AddInput("Green", "AbsorbColGreen", { INP_Default  = 2.0, IC_ControlID = 1, attrs})
    InAbsorbColColorB = self:AddInput("Blue",  "AbsorbColBlue",  { INP_Default  = 1.0, IC_ControlID = 2, attrs})
    InAbsorbColColorA = self:AddInput("Alpha", "AbsorbColAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("SunDir", "SunDir", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "SunDir",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InSunDirColorR = self:AddInput("Red",   "SunDirRed",   { INP_Default  = 0.0, IC_ControlID = 0, attrs})
    InSunDirColorG = self:AddInput("Green", "SunDirGreen", { INP_Default  = 0.2, IC_ControlID = 1, attrs})
    InSunDirColorB = self:AddInput("Blue",  "SunDirBlue",  { INP_Default  = -1.0, IC_ControlID = 2, attrs})
    InSunDirColorA = self:AddInput("Alpha", "SunDirAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()
self:EndControlNest()

  Inpath_aSlider = self:AddInput("path_a", "path_a", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.2,
      })

  Inpath_bSlider = self:AddInput("path_b", "path_b", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 3.0,
      })

  InminhSlider = self:AddInput("minh", "minh", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 3.0,
          INP_Default        = 0.5,
      })

  InmaxhSlider = self:AddInput("maxh", "maxh", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 2.5,
      })

  InwlSlider = self:AddInput("wl", "wl", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.3,
      })

  IninnerAdjSlider = self:AddInput("innerAdj", "innerAdj", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.25,
      })

  InchSlider = self:AddInput("ch", "ch", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.0175,
      })

  InibpmSlider = self:AddInput("ibpm", "ibpm", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 2.0,
          INP_Default        = 0.6667,
      })

  InPerSlider = self:AddInput("Per", "Per", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 128.0,
          INP_Default        = 32.0,
      })

  InstpSlider = self:AddInput("stp", "stp", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 100.0,
          INP_Default        = 66.0,
      })

  InLpSlider = self:AddInput("Lp", "Lp", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 3.0,
          INP_Default        = 0.33,
      })

  InFoFSlider = self:AddInput("FoF", "FoF", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 100.0,
          INP_Default        = 20.0,
      })

  InrndSlider = self:AddInput("rnd", "rnd", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 300.0,
          INP_Default        = 123.4,
      })

  InperiodSlider = self:AddInput("period", "period", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 500.0,
          INP_Default        = 92.0,
      })

  InAbsorbFktSlider = self:AddInput("AbsorbFkt", "AbsorbFkt", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = -4.0,
      })

  InSkyColFktSlider = self:AddInput("SkyColFkt", "SkyColFkt", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 3.0,
      })

  InInnerGlowFktSlider = self:AddInput("InnerGlowFkt", "InnerGlowFkt", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 20.0,
          INP_Default        = 8.0,
      })

  IntiltSlider = self:AddInput("tilt", "tilt", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -20.0,
          INP_MaxScale       = 20.0,
          INP_Default        = 0.0,
      })

  InzoomSlider = self:AddInput("zoom", "zoom", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -20.0,
          INP_MaxScale       = 20.0,
          INP_Default        = 0.0,
      })



  Sep3 = self:AddInput(string.rep("_", 152), "Separator3", {
    LINKID_DataType     = "Text",
    INPID_InputControl  = "LabelControl",
    INP_External        = false,
    INP_Passive         = true,
    IC_Visible          = true,
    INP_DoNotifyChanged = true,
    IC_NoLabel          = true,
  })
  
  
  InEdges = self:AddInput("Edges", "Edges", {
    LINKID_DataType = "Number",
    INPID_InputControl  = "MultiButtonControl",
    INP_Default         = 3.0,
    INP_Integer         = true,
    INP_DoNotifyChanged = true,
    INP_External        = false,
    MBTNC_ForceButtons  = true,
    INP_MinScale        = 0,
    INP_MaxScale        = 3,
    INP_MinAllowed      = 0,
    INP_MaxAllowed      = 3,
    MBTNC_ShowBasicButton = true,
    MBTNC_StretchToFit  = false, --true,
    MBTNC_ShowToolTip   = true,
    { MBTNC_AddButton = "Canvas", MBTNCD_ButtonWidth = 4/16, },
    { MBTNC_AddButton = "Wrap",MBTNCD_ButtonWidth = 3/16, },
    { MBTNC_AddButton = "Duplicate", MBTNCD_ButtonWidth = 5/16, },
    { MBTNC_AddButton = "Mirror", MBTNCD_ButtonWidth = 4/16, }, 
   }) 

  InDebugImage = self:AddInput("DebugImage", "DebugImage", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "Final", },
    { CCS_AddString = "BufferA", },
    { CCS_AddString = "BufferB", },
    CC_LabelPosition = "Horizontal",
  })

  ----- Size & Depth
  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
    INP_DoNotifyChanged = true,
    INP_Default        = 0,
    INP_Integer        = true,
    ICD_Width          = 1,
	  { CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	  { CCS_AddString  = "Image0", },
    { CCS_AddString  = "1920x1080", },
	  { CCS_AddString  = "1200x675", },
	  { CCS_AddString  = "800x450", },
	  { CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
  
  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
    INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
    { CCS_AddString  = "Default", },
    { CCS_AddString  = "int8", },
    { CCS_AddString  = "int16", },
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
    ICS_ControlPage  = "Image",
  })
  
  InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false }) 

  ----- In/Out

  InChannel0 = self:AddInput( "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
  InChannel1 = self:AddInput( "iChannel1",  "iChannel1",  { LINKID_DataType = "Image", LINK_Visible = false, LINK_Main = 2, INP_Required = false  })
  InChannel2 = self:AddInput( "iChannel2",  "iChannel2",  { LINKID_DataType = "Image", LINK_Visible = false, LINK_Main = 3, INP_Required = false  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main       = 1,
  })


  ShaderFuse.end_create()

end



-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------
function DefineEdges(edges, nodeX)

    --This gets the value of our input image for us to modify inside the kernel
    if edges == 0 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 1 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_WRAP, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 2 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_DUPLICATE, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 3 then
      nodeX:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    elseif edges == 4 then
      --print("Sampler 4")
    end
end



MULTIBUFFER = true
if MULTIBUFFER then   -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  ImgAttrs_Global = {
          { IMG_Channel = "Red", },
          { IMG_Channel = "Green", },
          { IMG_Channel = "Blue", },
          { IMG_Channel = "Alpha", },
          IMG_Width = Width,
          IMG_Height = Height,
          IMG_DeferAlloc = false,
          }

  Image_Buff_GlobalA = Image(ImgAttrs_Global)
  Image_Buff_GlobalB = Image(ImgAttrs_Global)
end


function Process(req)

	-- Imagesize and Depth
  if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InChannel0:GetValue(req) ~= nil) then
			   Width = InChannel0:GetValue(req).Width
			   Height = InChannel0:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value 
		end
	end	
  
  -- Alle ( int und float )
  if (InDepth:GetValue(req).Value > 0) then
	  if InDepth:GetValue(req).Value == 1 then 
	    SourceDepth = 5 
    else 
	    if InDepth:GetValue(req).Value == 2 then 
	        SourceDepth = 6 
	    else 
	        if InDepth:GetValue(req).Value == 3 then 
 		        SourceDepth = 7 
		    	else
			      SourceDepth = 8
	        end
		  end
	  end
	end

  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth  = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }

  local dst   = Image(imgattrs)
  local black = Pixel({R=0,G=0,B=0,A=0})
  dst:Fill(black)

if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  dstA = Image {IMG_Like = dst, IMG_DeferAlloc = true}
	dstB = Image {IMG_Like = dst, IMG_DeferAlloc = true}
end

  if req:IsPreCalc() then
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end


if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA = DVIPComputeNode(req,
    "MountainbytesPppp4KibWindowsFuse__Buffer_A", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
else
    node = DVIPComputeNode(req,
    "MountainbytesPppp4KibWindowsFuse", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )
end
  -- Extern texture or create a new one

  iChannel0 = InChannel0:GetValue(req)

  if iChannel0==nil then
    iChannel0 = Image(imgattrs)
    iChannel0:Fill(black)
  end

  iChannel1 = InChannel1:GetValue(req)

  if iChannel1==nil then
    iChannel1 = Image(imgattrs)
    iChannel1:Fill(black)
  end

  iChannel2 = InChannel2:GetValue(req)

  if iChannel2==nil then
    iChannel2 = Image(imgattrs)
    iChannel2:Fill(black)
  end

  -- DCTL parameters

  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    params = nodeA:GetParamBlock(ShaderParameters)
  else  
    params = node:GetParamBlock(ShaderParameters)
  end  

  params.iResolution[0] = dst.Width
  params.iResolution[1] = dst.Height
  params.iTime = (req.Time / framerate) * InFrequency:GetValue(req).Value
  
  -- iMouse
  
  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)
  
  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y
  
  if InMouseDrag:GetValue(req).Value ~= 0 then
    if params.iMouse[2]==-1 and params.iMouse[3]==-1 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = -1
    params.iMouse[3] = -1
  end
  
  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end
  
  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  if params.iMouse[2] == -1 and params.iMouse[3] == -1 then
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  else
    params.iMouse[2] = params.iMouse[2] * Width
    params.iMouse[3] = params.iMouse[3] * Height
  end

  params.noFlash = InnoFlashCheckbox:GetValue(req).Value
  params.SunCol0 = {
    InSunCol0ColorR:GetValue(req).Value,
    InSunCol0ColorG:GetValue(req).Value,
    InSunCol0ColorB:GetValue(req).Value,InSunCol0ColorA:GetValue(req).Value
  }
  params.SunCol1 = {
    InSunCol1ColorR:GetValue(req).Value,
    InSunCol1ColorG:GetValue(req).Value,
    InSunCol1ColorB:GetValue(req).Value,InSunCol1ColorA:GetValue(req).Value
  }
  params.GridCol0 = {
    InGridCol0ColorR:GetValue(req).Value,
    InGridCol0ColorG:GetValue(req).Value,
    InGridCol0ColorB:GetValue(req).Value,InGridCol0ColorA:GetValue(req).Value
  }
  params.GridCol1 = {
    InGridCol1ColorR:GetValue(req).Value,
    InGridCol1ColorG:GetValue(req).Value,
    InGridCol1ColorB:GetValue(req).Value,InGridCol1ColorA:GetValue(req).Value
  }
  params.RoadGlow = {
    InRoadGlowColorR:GetValue(req).Value,
    InRoadGlowColorG:GetValue(req).Value,
    InRoadGlowColorB:GetValue(req).Value,InRoadGlowColorA:GetValue(req).Value
  }
  params.BikeFlash = {
    InBikeFlashColorR:GetValue(req).Value,
    InBikeFlashColorG:GetValue(req).Value,
    InBikeFlashColorB:GetValue(req).Value,InBikeFlashColorA:GetValue(req).Value
  }
  params.AbsorbCol = {
    InAbsorbColColorR:GetValue(req).Value,
    InAbsorbColColorG:GetValue(req).Value,
    InAbsorbColColorB:GetValue(req).Value,InAbsorbColColorA:GetValue(req).Value
  }
  params.SunDir = {
    InSunDirColorR:GetValue(req).Value,
    InSunDirColorG:GetValue(req).Value,
    InSunDirColorB:GetValue(req).Value,InSunDirColorA:GetValue(req).Value
  }
  params.path_a = Inpath_aSlider:GetValue(req).Value
  params.path_b = Inpath_bSlider:GetValue(req).Value
  params.minh = InminhSlider:GetValue(req).Value
  params.maxh = InmaxhSlider:GetValue(req).Value
  params.wl = InwlSlider:GetValue(req).Value
  params.innerAdj = IninnerAdjSlider:GetValue(req).Value
  params.ch = InchSlider:GetValue(req).Value
  params.ibpm = InibpmSlider:GetValue(req).Value
  params.Per = InPerSlider:GetValue(req).Value
  params.stp = InstpSlider:GetValue(req).Value
  params.Lp = InLpSlider:GetValue(req).Value
  params.FoF = InFoFSlider:GetValue(req).Value
  params.rnd = InrndSlider:GetValue(req).Value
  params.period = InperiodSlider:GetValue(req).Value
  params.AbsorbFkt = InAbsorbFktSlider:GetValue(req).Value
  params.SkyColFkt = InSkyColFktSlider:GetValue(req).Value
  params.InnerGlowFkt = InInnerGlowFktSlider:GetValue(req).Value
  params.tilt = IntiltSlider:GetValue(req).Value
  params.zoom = InzoomSlider:GetValue(req).Value
  -- Resolution

  params.width  = dst.Width
  params.height = dst.Height

  -- Per channel time and resolution
  local edges = InEdges:GetValue(req).Value

  -- Set parameters and add I/O
  if MULTIBUFFER then -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA:SetParamBlock(params)
    --nodeA:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, nodeA)
    
  else   
    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)
    
    node:AddInput("iChannel0",iChannel0) -- TODO: add a better channel name
    node:AddInput("iChannel1",iChannel1) -- TODO: add a better channel name
    node:AddInput("iChannel2",iChannel2) -- TODO: add a better channel name
    node:AddOutput("dst", dst)
  end
  
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
    nodeA:AddOutput("dst", dstA)

    local ok = nodeA:RunSession(req)

    if (not ok) then
      dstA = nil
      dump(nodeA:GetErrorLog())
    end
    
    Image_Buff_GlobalA = dstA

  -------------------------- BufferB-Kernel----------------------------------------
    local nodeB = DVIPComputeNode(req,
      "MountainbytesPppp4KibWindowsFuse__Buffer_B", ShaderCompatibilityCode..ShaderKernelCode,
      "Params", ShaderParameters
    )
    
    nodeB:SetParamBlock(params)

    --nodeB:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, nodeB)
    nodeB:AddOutput("dst", dstB)

    local success = nodeB:RunSession(req)
    if not success then
      dstB = nil
      dump(nodeB:GetErrorLog())
    end
    
    Image_Buff_GlobalB = dstB --Recursiv Image	


    -------------------------- ImageKernel----------------------------------------
    node = DVIPComputeNode(req,
      "MountainbytesPppp4KibWindowsFuse", ShaderCompatibilityCode..ShaderKernelCode,
      "Params", ShaderParameters
    )

    node:SetParamBlock(params)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    DefineEdges(edges, node)

    node:AddInput("iChannel0", Image_Buff_GlobalA)  -- Anpassen !!
    node:AddInput("iChannel1", Image_Buff_GlobalB)  -- Anpassen !!
    node:AddInput("iChannel2", iChannel0)           -- Anpassen !!
    node:AddOutput("dst", dst)
 
  end -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER 
  

  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    dump(node:GetErrorLog())
	end

  OutImage:Set(req,dst)
    
    --Debugging
  if MULTIBUFFER then  -- MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER MULTIBUFFER
    InDebugImage:SetAttrs({ IC_Visible = true })
    
    if (InDebugImage:GetValue(req).Value == 1) then OutImage:Set(req, Image_Buff_GlobalA) end
    if (InDebugImage:GetValue(req).Value == 2) then OutImage:Set(req, Image_Buff_GlobalB) end
  else
    InDebugImage:SetAttrs({ IC_Visible = false })
  end
    
  
  collectgarbage();
end



-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

function NotifyChanged(inp, param, time)
 	if (param ~= nil) then

		if inp == InSize then
		  if param.Value == 1 then
			  InWidth:SetAttrs({ IC_Visible = true })
			  InHeight:SetAttrs({ IC_Visible = true })
		  else
			  InWidth:SetAttrs({ IC_Visible = false })
			  InHeight:SetAttrs({ IC_Visible = false })
		  end
		  
		  if param.Value == 3 then --1920x1080
			  InWidth:SetSource(Number(1920),0,0)
			  InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			  InWidth:SetSource(Number(1200),0,0)
			  InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			  InWidth:SetSource(Number(800),0,0)
			  InHeight:SetSource(Number(450),0,0)
		  end
 	    if param.Value == 6 then --640x360
		    InWidth:SetSource(Number(640),0,0)
		    InHeight:SetSource(Number(360),0,0)
		  end
		end 

 	end
end


-- */
