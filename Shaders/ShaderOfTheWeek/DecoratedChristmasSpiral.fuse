--[[--/*

  DecoratedChristmasSpiral.fuse

  Based on https://www.shadertoy.com/view/3dVfDc a WebGL shader created by sylvain69780.
  Converted to DCTL and embeddet into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT).
  Place this file in your Fusion's and/or DaVinci Resolve's 'Fuses/' folder to use it.

*/--]]--




-- /*
local ShaderFuse = require("Shaderfuse/ShaderFuse")
ShaderFuse.init()



-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass(ShaderFuse.FuRegister.Name, CT_SourceTool, {
  ShaderFuse.FuRegister.Attributes,

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,
  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  })



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------

-- */
ShaderParameters =
[[

  float  iResolution[2];
  float  iTime;
  float  iMouse[4];
  bool   AA;
  float  ColorBG[4];
  float  Balls1[4];
  float  Balls2[4];
  float  Tube1[4];
  float  Tube2[4];
  float  Spiral[4];
  float  Color1[4];
  float  Color2[4];
  float  Color3[4];
  float  Color4[4];
  float  Glow[4];
  float  View1XY[2];
  float  View1Z;
  float  View2XY[2];
  float  View2Z;
  float  Level0;

  int    width,height;
  int    compOrder;

]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel compatibility code
-- // ------------------------------------------------------------------------

-- */
ShaderCompatibilityCode =
[[


#if defined(DEVICE_IS_METAL)
  #define in
  #define out thread
  #define inout thread
#else
  #define in
  #define out
  #define inout
#endif

#undef USE_NATIVE_METAL_IMPL
#undef USE_NATIVE_CUDA_IMPL
#undef USE_NATIVE_OPENCL_IMPL

  // 0 to use the generic implementations; 1 for Metal, OpenCL, Cuda specific code if existing

  #if 1
    #if defined(DEVICE_IS_METAL)
      #define USE_NATIVE_METAL_IMPL   1
    #elif defined(DEVICE_IS_CUDA)
      #define USE_NATIVE_CUDA_IMPL    1
    #elif defined(DEVICE_IS_OPENCL)
      #define USE_NATIVE_OPENCL_IMPL  1
    #endif
  #endif

  #if defined(USE_NATIVE_METAL_IMPL)

    #define swi2(A,a,b)     (A).a##b
    #define swi3(A,a,b,c)   (A).a##b##c

    #define swi2S(a,b,c,d)   a.b##c = d

  #else

    #define swi2(A,a,b)     to_float2((A).a,(A).b)
    #define swi3(A,a,b,c)   to_float3((A).a,(A).b,(A).c)

    #define swi2S(a,b,c,d)   {float2 tmp = d; (a).b = tmp.x; (a).c = tmp.y;}

  #endif

// ----------------------------------------------------------------------------------------------------------
// mat2 implementation
// ----------------------------------------------------------------------------------------------------------

#if defined(USE_NATIVE_METAL_IMPL)

  typedef float2x2 mat2;

  #define to_mat2(A,B,C,D)   mat2((A),(B),(C),(D))

  #define mul_f2_mat2(A,B)   ((A)*(B))

#else

  typedef struct { float2 r0; float2 r1; } mat2;

  __DEVICE__ inline mat2 to_mat2      ( float  a, float  b, float c, float d)  { mat2 t; t.r0.x = a; t.r0.y = b; t.r1.x = c; t.r1.y = d;         return t; }

  __DEVICE__ inline float2 mul_f2_mat2( float2 v, mat2 m )
  {
    float2 t; t.x = v.x*m.r0.x + v.y*m.r0.y; t.y = v.x*m.r1.x + v.y*m.r1.y; return t;
  }

#endif // end of mat2 implementation

#if defined(USE_NATIVE_METAL_IMPL)

 #define fract_f2(A) fract(A)

 #define mod_f(a,b)  fmod((a),(b))

 #define sin_f3(i) sin(i)
 #define abs_f2(a) _fabs(a)
 #define abs_f3(a) _fabs(a)
 #define sqrt_f3(a) _sqrtf(a)
 #define sign_f(a) sign(a)

#else

  #if defined(USE_NATIVE_OPENCL_IMPL)

    #define reflect(I,N) (I-2.0f*dot(N,I)*N)

    #define fract(a) ((a)-_floor(a))  // oder Pointer bauen: gentype fract(gentype x, gentype *itpr)

 #define fract_f2(A) to_float2(fract((A).x),fract((A).y))
 #define mod_f(a,b) _fmod(a,b)
 #define sin_f3(i) sin(i)
 #define abs_f2(a) fabs(a)
 #define abs_f3(a) fabs(a)
 #define sqrt_f3(a) _sqrtf(a)
 #define sign_f(a) sign(a)

 #else // Generic

 #if defined(DEVICE_IS_OPENCL)
   __DEVICE__ float3 reflect(float3 I, float3 N) {return I - 2.0f * dot(N, I) * N;}
 #endif

    #define fract(a) ((a)-_floor(a))

 #define fract_f2(A) to_float2(fract((A).x),fract((A).y))
 #define mod_f(a,b) ((a)-(b)*_floor((a)/(b)))
 #define sin_f3(i) to_float3( _sinf((i).x), _sinf((i).y), _sinf((i).z))
 #define abs_f2(a) to_float2(_fabs((a).x), _fabs((a).y))
 #define abs_f3(a) to_float3(_fabs((a).x), _fabs((a).y),_fabs((a).z))
 #define sqrt_f3(a) to_float3(_sqrtf((a).x),_sqrtf((a).y),_sqrtf((a).z))
 #define sign_f(a) (a==0.0f?0.0f:a>0.0f?1.0f:-1.0f)

  #endif

#endif


]]
-- /*



-- // ------------------------------------------------------------------------
-- DCTL kernel implementation
-- // ------------------------------------------------------------------------

-- */
ShaderKernelCode =
[[

// ----------------------------------------------------------------------------------
// - Image                                                                          -
// ----------------------------------------------------------------------------------

#define texture(ch,uv) _tex2DVecN(ch, (uv).x, (uv).y, 15)
/*
    Decorated Christmas Spiral
    --------------------------

    Happy Christmas to you all the great Shadertoy community !

    It seems that the archimedian spiral can be used as a distance field with coordinates
    a quite neat way to create a repetition domain where you can put blinking balls and ribbons.

    Spirals are commonly use in art, and we may find this figure frequently in the nature.
    Of course there is several kinds of spirals. For example, the Logarithmic Spiral that IQ
    used in his awesome Snail shader and the ones built using arc of circles (multiple center spirals).

    Related references:

    Nyarchimedes Spiral - kibble
    https://www.shadertoy.com/view/lsS3WV

    Quick Lighting Tech - blackle
    https://www.shadertoy.com/view/ttGfz1

    soft shadows in raymarched SDFs - IQ
    https://iquilezles.org/articles/rmshadows

    outdoors lighting- IQ
    https://iquilezles.org/articles/outdoorslighting

    Cubic Truchet Pattern - Shane
    https://www.shadertoy.com/view/4lfcRl

*/

// #define AA

#define MAX_STEPS 256
#define MAX_DIST 10.0f
#define SURF_DIST 0.001f
#define TAU 6.283185f

#define S smoothstep
#define T (iTime)
#define PI 3.14159265f

__DEVICE__ mat2 rot(in float a) { float c = _cosf(a); float s = _sinf(a); return to_mat2(c, s, -s, c); }


__DEVICE__ float Hash21(float2 p) {
    p = fract_f2(p*to_float2(123.34f,233.53f));
    p += dot(p, p+23.234f);
    return fract(p.x*p.y);
}

__DEVICE__ float sdVerticalCapsule( float3 p, float r, float h )
{
  p.x -= clamp( p.x, 0.0f, h );
  return length( p ) - r;
}

__DEVICE__ float sdBox_f3(float3 p, float3 s) {
    p = abs_f3(p)-s;
  return length(_fmaxf(p, to_float3_s(0.0f)))+_fminf(_fmaxf(p.x, _fmaxf(p.y, p.z)), 0.0f);
}

__DEVICE__ float sdHexagram( in float2 p, in float r )
{
    const float4 k = to_float4(-0.5f,0.86602540378f,0.57735026919f,1.73205080757f);
    p = abs_f2(p);
    p -= 2.0f*_fminf(dot(swi2(k,x,y),p),0.0f)*swi2(k,x,y);
    p -= 2.0f*_fminf(dot(swi2(k,y,x),p),0.0f)*swi2(k,y,x);
    p -= to_float2(clamp(p.x,r*k.z,r*k.w),r);
    return length(p)*sign_f(p.y);
}

__DEVICE__ float sdBox( in float2 p, in float2 b )
{
    float2 d = abs_f2(p)-b;
    return length(_fmaxf(d,to_float2_s(0.0f))) + _fminf(_fmaxf(d.x,d.y),0.0f);
}

__DEVICE__ float braids(float3 p,float l, out float *id) {
    swi2S(p,y,z, mul_f2_mat2(swi2(p,y,z) , rot(p.x*3.14159f*0.5f)));
    swi2S(p,y,z, abs_f2(swi2(p,y,z))-0.25f); // 4 for the price of one
    swi2S(p,y,z, (swi2(p,y,z) + to_float2(p.z, -p.y))*_sqrtf(0.5f)); // Shortcut for 45-degrees rotation https://www.shadertoy.com/view/WsGyWR
    float2 sector=step(to_float2_s(0.0f),swi2(p,y,z));
    *id = sector.x + 2.0f * sector.y;

    swi2S(p,y,z, abs_f2(swi2(p,y,z))-0.05f);
    swi2S(p,y,z, mul_f2_mat2(swi2(p,y,z) , rot(p.x*3.14159f*4.0f)));
    swi2S(p,y,z, abs_f2(swi2(p,y,z))-0.02f);

    float d = sdVerticalCapsule(p,0.02f,l);
    return(d);
}

__DEVICE__ float carvings(float3 p,float l, out float *id) {
    p.x-=0.03f;
    float n = round(l);
    *id = clamp(round(p.x*2.0f),1.0f,n*2.0f-1.0f);
    p.x-= *id * 0.5f;
    swi2S(p,z,y, mul_f2_mat2(swi2(p,z,y) , rot(*id * 3.1415f*0.25f)));

    return _fminf(sdHexagram(swi2(p,x,y),0.045f),(sdBox(abs_f2(swi2(p,x,z))-0.033f,to_float2_s(0.022f)+0.006f)));
}

__DEVICE__ float balls(float3 p,float l, out float *id) {
    float rank = round(p.x);
    swi2S(p,y,z, mul_f2_mat2(swi2(p,y,z) , rot((rank+0.25f)*3.14159f*0.5f)));

    p.x -= clamp(rank,0.0f,l);
    float2 sector=step(to_float2_s(0.0f),swi2(p,y,z));
    *id = sector.x + 2.0f * sector.y;
    float r = 0.05f*(1.0f+ *id * 0.2f);

    swi2S(p,y,z, abs_f2(swi2(p,y,z)));
    swi2S(p,y,z, swi2(p,y,z) - to_float2(0.25f,0.25f));

    *id += 4.0f*rank;
    return length(p)-r;
}

__DEVICE__ float smax( float a, float b, float k )
{
    float h = _fmaxf(k-_fabs(a-b),0.0f);
    return _fmaxf(a, b) + h*h*0.25f/k;
}

__DEVICE__ float decoratedStick(float3 p, out float *m, out float *glowDist, float iTime) {
    float l = 40.0f;   // lenght of the stick
    float d = 1e10; // distance
    // materials : 1.0f=spiral 2.x=tubes 3.x=stars and squares 4.0f=inside spiral 5.0f Balls
    *m = 1.0f;    // materials
    *glowDist = 1e10;
    float core = length(to_float3(p.x-clamp(p.x,0.0f,l),p.y,p.z));
    float outer = core-0.25f;
    float inner = core-0.22f;
    // Stars and Littles windows carvings, change sign to have holes or bumps
    float id;
    float _carvings = -carvings(p,l,&id);
    d = smax(outer,_carvings,0.025f);
    if ( inner    < d ) { d = inner    ; *m = 4.0f+id/1024.0f ; }
    // Braids
    float _braids = braids(p,l,&id);
    if ( _braids < d ) { d=_braids ; *m= 2.0f + id/1024.0f ; }; // packing the ID in the material
    // Balls :-)
    float _balls = balls(p,l,&id);
    if ( _balls < d ) { d=_balls ; *m= 5.0f + id/1024.0f ; }; // packing the ID in the material
    // Some blinking
    float blink=1.0f-_cosf(5.0f*id+2.0f*T);
    *glowDist = _balls+blink*0.1f;
    return d;
}

// approximated !
__DEVICE__ float arclength(float turn) {
  float d = turn * turn;
  return d * PI;
}

__DEVICE__ float sdSegment( in float2 p, in float2 a, in float2 b )
{
    float2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0f, 1.0f );
    return length( pa - ba*h );
}

// arc length of archimedes spiral
__DEVICE__ float spiralLength(float b, float a) {
  // https://en.wikipedia.org/wiki/Archimedean_spiral
  return 0.5f*b*(a*_sqrtf(1.0f+a*a)+_logf(a+_sqrtf(1.0f+a*a)));
}

// SDF for Archimedean Spiral
// https://www.shadertoy.com/view/stB3WK
__DEVICE__ float spiralUV2(float2 p,float b, float a1r,float a2r, float strip, out float2 *uv) {

    float atn = _atan2f(p.y, p.x)/TAU; // sector from -0.5f to .5
    float a1n = a1r/TAU, a2n = a2r/TAU; // predivide allows to use fract for modulo TAU computations
    float w = b*TAU;
    float r = length(p)/w;
    float grad = r - atn; // radial distance gradien used for domain repetition using "round"
    float d = 1e9;
    if (a2n-a1n >= fract(atn-a1n)) // opened sector case test
    {
        (*uv).y = w*(grad-round(clamp(r,a1n+0.5f,a2n-0.5f)-atn));
        d=_fabs((*uv).y)-0.5f*strip;
    }
    // inner end
    float2 q = mul_f2_mat2(p,rot(a1r));
    q.x -= a1n*w;
    q.x -= clamp(q.x,-strip*0.5f,strip*0.5f);
    float db = length(q);
    // outer end
    q = mul_f2_mat2(p,rot(a2r));
    q.x -= a2n*w;
    q.x -= clamp(q.x,-strip*0.5f,strip*0.5f);
    db = _fminf(db,length(q));
    // interior / exterieur distance to ends
    d = d > 0.0f ? _fminf(d,db) : _fmaxf(d,-db);
    // UV calculations
    float turn = round(grad);
    float an = TAU*(turn + atn);
    (*uv).x = spiralLength(b,an)-spiralLength(b,a1r);
  return d;
}

__DEVICE__ float GetDist1(float3 p, out float *objID, out float *glowDist, out float *dC, float iTime ) {
    swi2S(p,x,z, mul_f2_mat2(swi2(p,x,z) , rot(T*0.1f)));
    swi2S(p,x,y, mul_f2_mat2(swi2(p,x,y) , rot(-_sinf(T*0.1f)*0.5f)));
    *glowDist = 1e10;
    *objID = 1.0f;
    float tmin = 0.0f, tmax = 2.0f;
    float2 uv;
    float d = 1e10;
    *dC = _fabs(p.y)-0.5f;
    if ( *dC < SURF_DIST ) {
        float dSpiral = spiralUV2(swi2(p,x,z),1.0f/TAU,(tmin+1.0f)*TAU,(tmax+2.0f)*TAU,1.0f, &uv);
        *dC = _fabs(dSpiral);
        if ( dSpiral < SURF_DIST-0.02f ) {
            float3 q = to_float3(uv.x, p.y, uv.y ); // spiral UV space
            d = decoratedStick(q-to_float3(0.5f,0.0f,0.0f),objID,glowDist, iTime);
        }
    }
    return d;
}

__DEVICE__ float GetDist2(float3 p, out float *glowDist, out float *dC, float iTime) {
    float objID;
    return GetDist1(p,&objID,glowDist,dC, iTime);
}

__DEVICE__ float GetDist(float3 p, float iTime) {
    float glowDist,objID,dC;
    return GetDist1(p,&objID,&glowDist,&dC, iTime);
}

__DEVICE__ float GetMat(float3 p, float iTime) {
    float glowDist,objID,dC;
    float d = GetDist1(p,&objID,&glowDist,&dC, iTime);
    return objID;
}

__DEVICE__ float RayMarch(float3 ro, float3 rd,out float *glowCumul, float iTime) {
    float dO=0.0f;
    float dS;
    float dC; // distance to cell boundaries
    float glowDist;
    *glowCumul=0.0f;
    for(int i=0; i<MAX_STEPS; i++) {
        float3 p = ro + rd*dO;
        dS = GetDist2(p,&glowDist,&dC, iTime);
        dO += _fminf(dS*0.9f,dC+0.05f);
        float at = 1.0f / (1.0f + _powf(glowDist*20.0f,3.0f) );
        *glowCumul+=at;
        if(dO>MAX_DIST || _fabs(dS)<SURF_DIST) break;
    }
    return dO;
}

__DEVICE__ float3 GetNormal(float3 p, float iTime) {
    float d = GetDist(p, iTime);
    float2 e = to_float2(0.001f, 0);

    float3 n = d - to_float3(
                            GetDist(p-swi3(e,x,y,y), iTime),
                            GetDist(p-swi3(e,y,x,y), iTime),
                            GetDist(p-swi3(e,y,y,x), iTime));

    return normalize(n);
}

__DEVICE__ float3 GetRayDir(float2 uv, float3 p, float3 l, float z) {
    float3 f = normalize(l-p),
        r = normalize(cross(to_float3(0,1,0), f)),
        u = cross(f,r),
        c = f*z,
        i = c + uv.x*r + uv.y*u,
        d = normalize(i);
    return d;
}

// https://iquilezles.org/articles/rmshadows
__DEVICE__ float calcSoftshadow( in float3 ro, in float3 rd, in float mint, in float tmax, float iTime )
{
    float res = 1.0f;
    float t = mint;
    for( int i=0; i<24; i++ )
    {
    float h = GetDist( ro + rd*t, iTime );
        float s = clamp(8.0f*h/t,0.0f,1.0f);
        res = _fminf( res, s*s*(3.0f-2.0f*s) );
        t += clamp( h, 0.02f, 0.2f );
        if( res<0.004f || t>tmax ) break;
    }
    return clamp( res, 0.0f, 1.0f );
}

__DEVICE__ float calcOcclusion( in float3 pos, in float3 nor, float iTime )
{
    float occ = 0.0f;
    float sca = 1.0f;
    for( int i=0; i<5; i++ )
    {
        float h = 0.01f + 0.11f*(float)(i)/4.0f;
        float3 opos = pos + h*nor;
        float d = GetDist( opos, iTime );
        occ += (h-d)*sca;
        sca *= 0.95f;
    }
    return clamp( 1.0f - 2.0f*occ, 0.0f, 1.0f );
}


__KERNEL__ void DecoratedChristmasSpiralFuse(__CONSTANTREF__ Params*  params, __TEXTURE2D_WRITE__ destinationTexture)
{
   DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);

   if (fusion_x >= params->width || fusion_y >= params->height)
     return;

  float2 iResolution = to_float2(params->iResolution[0], params->iResolution[1]);
  float  iTime       = params->iTime;
  float4 iMouse      = to_float4(params->iMouse[0],params->iMouse[1],params->iMouse[2],params->iMouse[3]);
  float4 fragColor   = to_float4_s(0.0f);
  float2 fragCoord   = to_float2(fusion_x,fusion_y);


  bool   AA = params->AA;
  float4 ColorBG = to_float4(params->ColorBG[0], params->ColorBG[1], params->ColorBG[2], params->ColorBG[3]);
  float4 Balls1 = to_float4(params->Balls1[0], params->Balls1[1], params->Balls1[2], params->Balls1[3]);
  float4 Balls2 = to_float4(params->Balls2[0], params->Balls2[1], params->Balls2[2], params->Balls2[3]);
  float4 Tube1 = to_float4(params->Tube1[0], params->Tube1[1], params->Tube1[2], params->Tube1[3]);
  float4 Tube2 = to_float4(params->Tube2[0], params->Tube2[1], params->Tube2[2], params->Tube2[3]);
  float4 Spiral = to_float4(params->Spiral[0], params->Spiral[1], params->Spiral[2], params->Spiral[3]);
  float4 Color1 = to_float4(params->Color1[0], params->Color1[1], params->Color1[2], params->Color1[3]);
  float4 Color2 = to_float4(params->Color2[0], params->Color2[1], params->Color2[2], params->Color2[3]);
  float4 Color3 = to_float4(params->Color3[0], params->Color3[1], params->Color3[2], params->Color3[3]);
  float4 Color4 = to_float4(params->Color4[0], params->Color4[1], params->Color4[2], params->Color4[3]);
  float4 Glow = to_float4(params->Glow[0], params->Glow[1], params->Glow[2], params->Glow[3]);
  float2 View1XY = to_float2(params->View1XY[0], params->View1XY[1]);
  float  View1Z = params->View1Z;
  float2 View2XY = to_float2(params->View2XY[0], params->View2XY[1]);
  float  View2Z = params->View2Z;
  float  Level0 = params->Level0;

  // --------

    float3 View1 = to_float3_aw(View1XY, View1Z);
    float3 View2 = to_float3_aw(View2XY, View2Z);

    float alpha = 1.0f;

    mat2 dummy;

    float3 col = to_float3_s(0);
    float3 tcol = to_float3_s(0);
    float3 target = to_float3(0,-0.7f,1.0f) + View1;
    float3 ro = to_float3(0, 0.7f, 3.3f) + View2;
    float2 m = swi2(iMouse,x,y) / iResolution-0.5f;
    float time=mod_f(T+10.0f,20.0f);
    float atime=1.0f;
    if ( iMouse.x > 0.0f ) {
        target = to_float3(0,-0.8f,0.0f)+ View1;
        ro = (to_float3(0, 0.5f, 2.0f)+ View2)*2.4f;
        swi2S(ro,y,z, mul_f2_mat2(swi2(ro,y,z) , rot(m.y*3.14f*0.5f)));
        swi2S(ro,x,z, mul_f2_mat2(swi2(ro,x,z) , rot(-m.x*6.2831f*2.0f)));
    } else
        ro.y+=S(0.0f,10.0f,time)-S(10.0f,20.0f,time);


    float dx_start = 0.0f, dy_start = 0.0f;
    if(!AA)
      dx_start = 1.0f, dy_start = 1.0f;

  for (float dx = dx_start; dx <= 1.0f; dx++)
    for (float dy = dy_start; dy <= 1.0f; dy++) {
      float2 uv = (fragCoord + to_float2(dx, dy) * 0.5f - 0.5f * iResolution) / iResolution.y;

    //float2 uv = (fragCoord - 0.5f * iResolution) / iResolution.y;


    float3 rd = GetRayDir(uv, ro, target, 1.0f);
    float3 bgcol = swi3(ColorBG,x,y,z)*(1.0f-_fabs(rd.y)); // fast gradient - "the sky will be blue" - https://youtu.be/Cfe5UQ-1L9Q?t=2795
    float glowCumul;
    float d = RayMarch(ro, rd,&glowCumul, iTime);
    if(d<MAX_DIST) {
        float3 pos = ro + rd * d;
        float m = GetMat(pos, iTime);
        float3 nor = GetNormal(pos, iTime);
        float3 ref = reflect(rd, nor);
        float3 c=to_float3_s(0);
        float ks = 1.0f;
        float occ = calcOcclusion( pos, nor, iTime );
        float3  sun_lig = normalize( to_float3(0.6f, 0.35f, 0.5f) );
        float sun_dif = clamp(dot( nor, sun_lig ), 0.0f, 1.0f );
        float3  sun_hal = normalize( sun_lig-rd );
        float sun_sha = calcSoftshadow( pos+0.01f*nor, sun_lig, 0.01f, 0.25f, iTime );
        float sun_spe = ks*_powf(clamp(dot(nor,sun_hal),0.0f,1.0f),8.0f)*sun_dif*(0.04f+0.96f*_powf(clamp(1.0f+dot(sun_hal,rd),0.0f,1.0f),5.0f));
        float sky_dif = _sqrtf(clamp( 0.5f+0.5f*nor.y, 0.0f, 1.0f ));
        float bou_dif = _sqrtf(clamp( 0.1f-0.9f*nor.y, 0.0f, 1.0f ))*clamp(1.0f-0.1f*pos.y,0.0f,1.0f);
        float3 lin = to_float3_s(0.0f);
        // materials
        if ( m >=5.0f ) {            // Balls
            float ballID = fract(m)*1024.0f;
            //c = fract(ballID*0.5f) > 0.0f ? to_float3(1.0f,0.1f,0.01f) : to_float3(0.6f,0.6f,0.2f)*0.5f;
            c = fract(ballID*0.5f) > 0.0f ? swi3(Balls1,x,y,z) : swi3(Balls2,x,y,z)*0.5f;
            float directionality=0.75f;
            float sharpness=0.5f;
            float spec = length(sin_f3(ref * 3.0f) * directionality + (1.0f - directionality)) / _sqrtf(3.0f);
            spec = spec + _powf(spec, 10.0f * sharpness);
            float blink=1.0f+_cosf(5.0f*ballID+2.0f*T);
            lin = to_float3_s(blink)*3.3f;
            c = spec * c;
        } else if ( m >=4.0f ) {     // bright inside spiral
            float starID=fract(m)*1024.0f;
            float blink=1.0f+_cosf(5.0f*starID+3.15f*T);
            c = swi3(Spiral,x,y,z)*0.3f;
            lin = to_float3_s(blink)*3.0f;
            float directionality=0.75f;
            float sharpness=0.5f;
            float spec = length(sin_f3(ref * 3.0f) * directionality + (1.0f - directionality)) / _sqrtf(3.0f);
            spec = spec + _powf(spec, 10.0f * sharpness);
            c = spec * c;
        } else if ( m >=3.0f ) {
            // Material Not used c = to_float3(0.3f,0.1f,0.01f);
        } else if ( m >=2.0f ) {     // tubes
            float ropeID=fract(m)*1024.0f;
            //c = ropeID>2.0f ? to_float3(0.5f,0.5f,0.01f)*0.25f : to_float3(0.01f,0.6f,0.01f)*0.1f;
            c = ropeID>2.0f ? swi3(Tube1,x,y,z)*0.25f : swi3(Tube2,x,y,z)*0.1f;
        } else if ( m >=1.0f ) {
            // spiral core
            // https://www.shadertoy.com/view/tlscDB
            c = to_float3(0.28f,0.2f,0.02f);
            float directionality=0.75f;
            float sharpness=0.7f;
            float spec = length(sin_f3(ref * 4.0f) * directionality + (1.0f - directionality)) / _sqrtf(3.0f);
            spec = spec + _powf(spec, 10.0f * sharpness);
            c =  spec * c * (0.3f+0.7f*sun_sha);
        }
        //lin += sun_dif*to_float3(8.10f,6.00f,4.20f)*sun_sha*0.5f;
        //lin += sky_dif*to_float3(0.50f,0.70f,1.00f)*occ*2.0f;
        //lin += bou_dif*to_float3(0.40f,1.00f,0.40f)*occ*2.0f;
        lin += sun_dif*swi3(Color1,x,y,z)*sun_sha*0.5f;
        lin += sky_dif*swi3(Color2,x,y,z)*occ*2.0f;
        lin += bou_dif*swi3(Color3,x,y,z)*occ*2.0f;

        col = c*lin;
        //col += sun_spe*to_float3(8.10f,6.00f,4.20f)*sun_sha;
        col += sun_spe*swi3(Color4,x,y,z)*sun_sha;
        // fog
        float fog=S(12.0f,5.0f,d);
        col = _mix(bgcol, col, fog);

    } else {
        col = bgcol;
        alpha = ColorBG.w;
    }
    //col += to_float3(0.1f,0.1f,0.01f)*glowCumul;
    col += swi3(Glow,x,y,z)*glowCumul;
    col = sqrt_f3(col);  // gamma correction
    tcol+=col;
    }

    if(AA)
      tcol /= 4.0f;

    fragColor = to_float4_aw(tcol,alpha);

  _tex2DVec4Write(destinationTexture, fusion_x, fusion_y, fragColor);
}
]]
-- /*



-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ShaderFuse.begin_create()

  ----- Inspector Panel Controls

  
  -- Speed Slider
  
  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",
  })
  
  -- iMouse Controls
  
  InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
  })
  
  InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged  = false,
    INPID_PreviewControl = "CrosshairControl",
    INP_Disabled = true,
  })
  
  InMouseDrag = self:AddInput("Mouse Button Pressed", "iMouseClick", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_DoNotifyChanged  = false,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    INP_Default = 0,
  })
  InAACheckbox = self:AddInput("AA", "AA", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
  })

 
 self:BeginControlNest("Colors", "Colors", false, {})
 self:BeginControlNest("ColorBG", "ColorBG", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "ColorBG",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColorBGColorR = self:AddInput("Red",   "ColorBGRed",   { INP_Default  = 0.10, IC_ControlID = 0, attrs})
    InColorBGColorG = self:AddInput("Green", "ColorBGGreen", { INP_Default  = 0.28, IC_ControlID = 1, attrs})
    InColorBGColorB = self:AddInput("Blue",  "ColorBGBlue",  { INP_Default  = 0.10, IC_ControlID = 2, attrs})
    InColorBGColorA = self:AddInput("Alpha", "ColorBGAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Balls1", "Balls1", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Balls1",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InBalls1ColorR = self:AddInput("Red",   "Balls1Red",   { INP_Default  = 1.0, IC_ControlID = 0, attrs})
    InBalls1ColorG = self:AddInput("Green", "Balls1Green", { INP_Default  = 0.1, IC_ControlID = 1, attrs})
    InBalls1ColorB = self:AddInput("Blue",  "Balls1Blue",  { INP_Default  = 0.01, IC_ControlID = 2, attrs})
    InBalls1ColorA = self:AddInput("Alpha", "Balls1Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Balls2", "Balls2", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Balls2",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InBalls2ColorR = self:AddInput("Red",   "Balls2Red",   { INP_Default  = 0.6, IC_ControlID = 0, attrs})
    InBalls2ColorG = self:AddInput("Green", "Balls2Green", { INP_Default  = 0.6, IC_ControlID = 1, attrs})
    InBalls2ColorB = self:AddInput("Blue",  "Balls2Blue",  { INP_Default  = 0.2, IC_ControlID = 2, attrs})
    InBalls2ColorA = self:AddInput("Alpha", "Balls2Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Tube1", "Tube1", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Tube1",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InTube1ColorR = self:AddInput("Red",   "Tube1Red",   { INP_Default  = 0.5, IC_ControlID = 0, attrs})
    InTube1ColorG = self:AddInput("Green", "Tube1Green", { INP_Default  = 0.5, IC_ControlID = 1, attrs})
    InTube1ColorB = self:AddInput("Blue",  "Tube1Blue",  { INP_Default  = 0.01, IC_ControlID = 2, attrs})
    InTube1ColorA = self:AddInput("Alpha", "Tube1Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Tube2", "Tube2", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Tube2",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InTube2ColorR = self:AddInput("Red",   "Tube2Red",   { INP_Default  = 0.01, IC_ControlID = 0, attrs})
    InTube2ColorG = self:AddInput("Green", "Tube2Green", { INP_Default  = 0.6, IC_ControlID = 1, attrs})
    InTube2ColorB = self:AddInput("Blue",  "Tube2Blue",  { INP_Default  = 0.01, IC_ControlID = 2, attrs})
    InTube2ColorA = self:AddInput("Alpha", "Tube2Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Spiral", "Spiral", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Spiral",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InSpiralColorR = self:AddInput("Red",   "SpiralRed",   { INP_Default  = 0.7, IC_ControlID = 0, attrs})
    InSpiralColorG = self:AddInput("Green", "SpiralGreen", { INP_Default  = 0.7, IC_ControlID = 1, attrs})
    InSpiralColorB = self:AddInput("Blue",  "SpiralBlue",  { INP_Default  = 0.1, IC_ControlID = 2, attrs})
    InSpiralColorA = self:AddInput("Alpha", "SpiralAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Color1", "Color1", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Color1",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColor1ColorR = self:AddInput("Red",   "Color1Red",   { INP_Default  = 8.10, IC_ControlID = 0, attrs})
    InColor1ColorG = self:AddInput("Green", "Color1Green", { INP_Default  = 6.00, IC_ControlID = 1, attrs})
    InColor1ColorB = self:AddInput("Blue",  "Color1Blue",  { INP_Default  = 4.20, IC_ControlID = 2, attrs})
    InColor1ColorA = self:AddInput("Alpha", "Color1Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Color2", "Color2", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Color2",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColor2ColorR = self:AddInput("Red",   "Color2Red",   { INP_Default  = 0.50, IC_ControlID = 0, attrs})
    InColor2ColorG = self:AddInput("Green", "Color2Green", { INP_Default  = 0.70, IC_ControlID = 1, attrs})
    InColor2ColorB = self:AddInput("Blue",  "Color2Blue",  { INP_Default  = 1.00, IC_ControlID = 2, attrs})
    InColor2ColorA = self:AddInput("Alpha", "Color2Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Color3", "Color3", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Color3",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColor3ColorR = self:AddInput("Red",   "Color3Red",   { INP_Default  = 0.40, IC_ControlID = 0, attrs})
    InColor3ColorG = self:AddInput("Green", "Color3Green", { INP_Default  = 1.00, IC_ControlID = 1, attrs})
    InColor3ColorB = self:AddInput("Blue",  "Color3Blue",  { INP_Default  = 0.40, IC_ControlID = 2, attrs})
    InColor3ColorA = self:AddInput("Alpha", "Color3Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Color4", "Color4", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Color4",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InColor4ColorR = self:AddInput("Red",   "Color4Red",   { INP_Default  = 8.10, IC_ControlID = 0, attrs})
    InColor4ColorG = self:AddInput("Green", "Color4Green", { INP_Default  = 6.00, IC_ControlID = 1, attrs})
    InColor4ColorB = self:AddInput("Blue",  "Color4Blue",  { INP_Default  = 4.20, IC_ControlID = 2, attrs})
    InColor4ColorA = self:AddInput("Alpha", "Color4Alpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()

  self:BeginControlNest("Glow", "Glow", true, {})

    ctrl_grp_cnt = (ctrl_grp_cnt==nil) and 1 or (ctrl_grp_cnt+1)

    attrs = {
      ICS_Name = "Glow",
      LINKID_DataType = "Number",
      INPID_InputControl = "ColorControl",
      INP_MinScale = 0.0,
      INP_MaxScale = 1.0,
      IC_ControlGroup = ctrl_grp_cnt,
    }

    InGlowColorR = self:AddInput("Red",   "GlowRed",   { INP_Default  = 0.1, IC_ControlID = 0, attrs})
    InGlowColorG = self:AddInput("Green", "GlowGreen", { INP_Default  = 0.1, IC_ControlID = 1, attrs})
    InGlowColorB = self:AddInput("Blue",  "GlowBlue",  { INP_Default  = 0.01, IC_ControlID = 2, attrs})
    InGlowColorA = self:AddInput("Alpha", "GlowAlpha", { INP_Default  = 1.0, IC_ControlID = 3, attrs})

  self:EndControlNest()
self:EndControlNest()

  InView1XYPoint = self:AddInput("View1XY", "View1XY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InView1ZSlider = self:AddInput("View1Z", "View1Z", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InView2XYPoint = self:AddInput("View2XY", "View2XY", {
      LINKID_DataType    = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      INP_DefaultX          = 0.0,
      INP_DefaultY          = 0.0,
  })

  InView2ZSlider = self:AddInput("View2Z", "View2Z", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -10.0,
          INP_MaxScale       = 10.0,
          INP_Default        = 0.0,
      })

  InLevel0Slider = self:AddInput("Level0", "Level0", {
          LINKID_DataType    = "Number",
          INPID_InputControl = "SliderControl",
          INP_MinScale       = -1.0,
          INP_MaxScale       = 1.0,
          INP_Default        = 0.0,
      })



  Sep3 = self:AddInput(string.rep("_", 152), "Separator3", {
    LINKID_DataType     = "Text",
    INPID_InputControl  = "LabelControl",
    INP_External        = false,
    INP_Passive         = true,
    IC_Visible          = true,
    INP_DoNotifyChanged = true,
    IC_NoLabel          = true,
  })
  
  
  
  ----- Size & Depth
  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
    INP_DoNotifyChanged = true,
    INP_Default        = 0,
    INP_Integer        = true,
    ICD_Width          = 1,
	  { CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	  { CCS_AddString  = "Image0", },
    { CCS_AddString  = "1920x1080", },
	  { CCS_AddString  = "1200x675", },
	  { CCS_AddString  = "800x450", },
	  { CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer         = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
  
  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
    INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
    { CCS_AddString  = "Default", },
    { CCS_AddString  = "int8", },
    { CCS_AddString  = "int16", },
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
    ICS_ControlPage  = "Image",
  })
  
  InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false }) 

  ----- In/Out


  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main       = 1,
  })


  ShaderFuse.end_create()

end



-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------


function Process(req)

	-- Imagesize and Depth
  if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InChannel0:GetValue(req) ~= nil) then
			   Width = InChannel0:GetValue(req).Width
			   Height = InChannel0:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value 
		end
	end	
  
  -- Alle ( int und float )
  if (InDepth:GetValue(req).Value > 0) then
	  if InDepth:GetValue(req).Value == 1 then 
	    SourceDepth = 5 
    else 
	    if InDepth:GetValue(req).Value == 2 then 
	        SourceDepth = 6 
	    else 
	        if InDepth:GetValue(req).Value == 3 then 
 		        SourceDepth = 7 
		    	else
			      SourceDepth = 8
	        end
		  end
	  end
	end

  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width  = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth  = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }

  local dst   = Image(imgattrs)
  local black = Pixel({R=0,G=0,B=0,A=0})
  dst:Fill(black)

  if req:IsPreCalc() then
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end



  node = DVIPComputeNode(req,
    "DecoratedChristmasSpiralFuse", ShaderCompatibilityCode..ShaderKernelCode,
    "Params", ShaderParameters
  )

  -- Extern texture or create a new one

  -- DCTL parameters

  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}


  params = node:GetParamBlock(ShaderParameters)

  params.iResolution[0] = dst.Width
  params.iResolution[1] = dst.Height
  params.iTime = (req.Time / framerate) * InFrequency:GetValue(req).Value
  
  -- iMouse
  
  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)
  
  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y
  
  if InMouseDrag:GetValue(req).Value ~= 0 then
    if params.iMouse[2]==-1 and params.iMouse[3]==-1 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = -1
    params.iMouse[3] = -1
  end
  
  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end
  
  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  if params.iMouse[2] == -1 and params.iMouse[3] == -1 then
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  else
    params.iMouse[2] = params.iMouse[2] * Width
    params.iMouse[3] = params.iMouse[3] * Height
  end

  params.AA = InAACheckbox:GetValue(req).Value
  params.ColorBG = {
    InColorBGColorR:GetValue(req).Value,
    InColorBGColorG:GetValue(req).Value,
    InColorBGColorB:GetValue(req).Value,InColorBGColorA:GetValue(req).Value
  }
  params.Balls1 = {
    InBalls1ColorR:GetValue(req).Value,
    InBalls1ColorG:GetValue(req).Value,
    InBalls1ColorB:GetValue(req).Value,InBalls1ColorA:GetValue(req).Value
  }
  params.Balls2 = {
    InBalls2ColorR:GetValue(req).Value,
    InBalls2ColorG:GetValue(req).Value,
    InBalls2ColorB:GetValue(req).Value,InBalls2ColorA:GetValue(req).Value
  }
  params.Tube1 = {
    InTube1ColorR:GetValue(req).Value,
    InTube1ColorG:GetValue(req).Value,
    InTube1ColorB:GetValue(req).Value,InTube1ColorA:GetValue(req).Value
  }
  params.Tube2 = {
    InTube2ColorR:GetValue(req).Value,
    InTube2ColorG:GetValue(req).Value,
    InTube2ColorB:GetValue(req).Value,InTube2ColorA:GetValue(req).Value
  }
  params.Spiral = {
    InSpiralColorR:GetValue(req).Value,
    InSpiralColorG:GetValue(req).Value,
    InSpiralColorB:GetValue(req).Value,InSpiralColorA:GetValue(req).Value
  }
  params.Color1 = {
    InColor1ColorR:GetValue(req).Value,
    InColor1ColorG:GetValue(req).Value,
    InColor1ColorB:GetValue(req).Value,InColor1ColorA:GetValue(req).Value
  }
  params.Color2 = {
    InColor2ColorR:GetValue(req).Value,
    InColor2ColorG:GetValue(req).Value,
    InColor2ColorB:GetValue(req).Value,InColor2ColorA:GetValue(req).Value
  }
  params.Color3 = {
    InColor3ColorR:GetValue(req).Value,
    InColor3ColorG:GetValue(req).Value,
    InColor3ColorB:GetValue(req).Value,InColor3ColorA:GetValue(req).Value
  }
  params.Color4 = {
    InColor4ColorR:GetValue(req).Value,
    InColor4ColorG:GetValue(req).Value,
    InColor4ColorB:GetValue(req).Value,InColor4ColorA:GetValue(req).Value
  }
  params.Glow = {
    InGlowColorR:GetValue(req).Value,
    InGlowColorG:GetValue(req).Value,
    InGlowColorB:GetValue(req).Value,InGlowColorA:GetValue(req).Value
  }
  params.View1XY = {InView1XYPoint:GetValue(req).X,InView1XYPoint:GetValue(req).Y}
  params.View1Z = InView1ZSlider:GetValue(req).Value
  params.View2XY = {InView2XYPoint:GetValue(req).X,InView2XYPoint:GetValue(req).Y}
  params.View2Z = InView2ZSlider:GetValue(req).Value
  params.Level0 = InLevel0Slider:GetValue(req).Value
  -- Resolution

  params.width  = dst.Width
  params.height = dst.Height

  -- Per channel time and resolution

  -- Set parameters and add I/O

  node:SetParamBlock(params)
  node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    
  node:AddOutput("dst", dst)
  
  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    dump(node:GetErrorLog())
	end

  OutImage:Set(req,dst)
  
  collectgarbage();
end


-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

function NotifyChanged(inp, param, time)
 	if (param ~= nil) then

		if inp == InSize then
		  if param.Value == 1 then
			  InWidth:SetAttrs({ IC_Visible = true })
			  InHeight:SetAttrs({ IC_Visible = true })
		  else
			  InWidth:SetAttrs({ IC_Visible = false })
			  InHeight:SetAttrs({ IC_Visible = false })
		  end
		  
		  if param.Value == 3 then --1920x1080
			  InWidth:SetSource(Number(1920),0,0)
			  InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			  InWidth:SetSource(Number(1200),0,0)
			  InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			  InWidth:SetSource(Number(800),0,0)
			  InHeight:SetSource(Number(450),0,0)
		  end
 	    if param.Value == 6 then --640x360
		    InWidth:SetSource(Number(640),0,0)
		    InHeight:SetSource(Number(360),0,0)
		  end
		end 

 	end
end
-- */
